<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Prolog的安装和基本使用</title>
      <link href="/2022/031650390.html"/>
      <url>/2022/031650390.html</url>
      
        <content type="html"><![CDATA[<h2 id="Prolog的安装"><a href="#Prolog的安装" class="headerlink" title="Prolog的安装"></a>Prolog的安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>访问官网<a href="https://www.swi-prolog.org/">SWI-Prolog</a> 在DOWNLOAD找到对应的二进制文件下载安装即可(建议选择配置环境变量)</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>也可以在官网安装，还可以用指令<br><code>sudo apt-get install swi-prolog</code></p><h2 id="Prolog的运行"><a href="#Prolog的运行" class="headerlink" title="Prolog的运行"></a>Prolog的运行</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>输入<code>swipl</code>启动Prolog运行环境</p><pre class=" language-lang-bash"><code class="language-lang-bash">?- write("Hello, world").Hello, world!true.</code></pre><p>退出 SWI-Prolog，可以使用<code>halt</code>命令：<code>?- halt.</code></p><h3 id="在线编译器"><a href="#在线编译器" class="headerlink" title="在线编译器"></a>在线编译器</h3><p><a href="https://swish.swi-prolog.org/">SWISH — SWI-Prolog for SHaring</a></p><h3 id="VSC"><a href="#VSC" class="headerlink" title="VSC"></a>VSC</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在VSC下载拓展VSC-Prolog</p><p>Settings中添加如下配置(prolog.executablePath修改为自己下载的路径)</p><pre><code>    "prolog.dialect": "swi", //prolog方言选择:swi(SWI-Prolog)或者ecl(ECLiPSe)    "prolog.executablePath": "D:\\Coder\\swipl\\bin\\swipl.exe", //指向prolog可执行文件    "prolog.linter.run": "onSave", //保存文件时进行代码检查    //"prolog.linter.delay": 500,  //使用"onType"时用到的选项     "prolog.format.enabled": true, //允许format源代码    "prolog.format.tabSize": 4,    //将tab替换为4个空格    "prolog.format.insertSpaces": true, //更偏向使用空格</code></pre><p>Launch中添加如下配置(runtimeExecutable修改为自己下载的路径)</p><pre><code>        {            "name": "Prolog Launch File",        //配置名称            "type": "prolog",       //配置类型            "request": "launch",    //请求配置类型,可以是启动launch或附加attach            "program": "${file}",   //将要进行调试的程序的完整路径            "startupQuery": "start",            "stopAtEntry": false,   //设为true时调试程序将暂停在程序入口处,否则将执行到第一个断点处            "cwd": "${fileDirname}",//调试程序时的工作目录,此处为源码文件所在目录            "env": {},              //传递给源文件的环境变量            "runtimeExecutable": "D:\\Coder\\swipl\\bin\\swipl.exe",  //调试进程的可执行文件               "runtimeArgs": [],      //传递给调试程序的命令行参数            "args": [],             //程序调试时传递给程序的命令行参数,这里设为空即可            "traceCmds": {          //介于vscode调试命令和prolog trace选项之间的映射                "continue": ["leap", "l"],                 "stepover": ["skip", "s"],                "stepinto": ["creep", "c"],                 "stepout": ["up", "u"]            },         }</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>编写的代码文件后缀为<code>.pl</code><br>在<code>.pl</code>的文件中右键选择Prolog: Load document 可以进入swi终端运行文件，类似地输入<code>halt.</code>可以终止服务<br>(ctrl+c 后输入h可以看到一些指令，ctrl+c后输入e也可以中断终端)</p><p><img src="https://static01.imgkr.com/temp/53c4d121669b434d9ab7fa72ad274e83.png" alt="VSC运行Prolog"></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h3><ul><li>小写字母开头的字符串=常量；</li><li>大写字母开头的字符串=变量。</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">?- write(abc).abctrue.?- write(Abc)._3386true.</code></pre><h3 id="关系和属性"><a href="#关系和属性" class="headerlink" title="关系和属性"></a>关系和属性</h3><p>两个对象之间的关系表示为：<code>关系名(主体，客体)</code></p><p>比如，kk的朋友是uzi，写成<code>friend(kk, uzi).</code>（注意这里不等同于<code>friend(uzi,kk)</code> 表示两者互为朋友需要两个代码都写上）</p><p>括号里面只有一个参数，表示对象拥有该属性<br>比如 kk 是卷王，写成<code>juanking(kk).</code></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是推理方法，即如何从一个论断得到另一个论断。</p><p>如规则：所有朋友关系都是相互的：</p><pre><code>friend(X, Y) :- friend(Y, X).</code></pre><p>上面代码中，<code>X</code>和<code>Y</code>都是大写，表示这是两个变量。<br>符号<code>:-</code>表示推理关系，含义是只要右为<code>true</code>，则左也为<code>true</code>（注意因果）</p><p>如果一条规则取决于多个条件，则条件之间使用逗号分隔，如</p><pre><code>mother(X, Y) :- child(Y,X), female(X).</code></pre><p>如果一条规则取决于某个条件为<code>false</code>，则在条件之前加上<code>\+</code>表示否定。</p><pre><code>onesidelove(X, Y) :- loves(X, Y), \+ loves(Y,X).</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>Prolog可以查询已经设定的条件。我们先写一个脚本<code>hello.pl</code>。</p><pre class=" language-lang-bash"><code class="language-lang-bash">friend(john, julia).friend(john, jack).friend(julia, sam).friend(julia, molly).</code></pre><p>然后在 SWI-Prolog 里面加载这个脚本。</p><pre class=" language-lang-bash"><code class="language-lang-bash">?- [hello].true.</code></pre><p>上面代码中，<code>true.</code>是返回的结果，表示加载成功。</p><p>然后，可以查询两个人是否为朋友。</p><pre class=" language-lang-bash"><code class="language-lang-bash">?- friend(john, jack).true.?- friend(john, sam).false.</code></pre><p><code>listing()</code>函数可以列出所有的朋友关系。</p><pre class=" language-lang-bash"><code class="language-lang-bash">?- listing(friend).friend(john, julia).friend(john, jack).friend(julia, sam).friend(julia, molly).true.</code></pre><p>还可以查询<code>john</code>有多少个朋友。</p><pre class=" language-lang-bash"><code class="language-lang-bash">?- friend(john, Who).Who = julia ;Who = jack.</code></pre><p>上面代码中，<code>Who</code>是变量名。任意的变量名都可以，只要首字母为大写。</p><h2 id="相关教程"><a href="#相关教程" class="headerlink" title="相关教程"></a>相关教程</h2><blockquote><p> <a href="https://zhzluke96.github.io/prolog-tut-cn/">前言 · Prolog 教程 (zhzluke96.github.io)</a></p><p>比较完善的Prolog体系教程</p><p><a href="https://ruanyifeng.com/blog/2019/01/prolog.html">Prolog 语言入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>简单的语法介绍，有几个例子可以快速入门</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现Web服务的工作方式及内部展现</title>
      <link href="/2022/022452009.html"/>
      <url>/2022/022452009.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Golang为实现Web服务提供了成熟的HTTP处理包，很大程度的简化了动态Web程序的开发。本文将基于《Build web application with Golang》及相关资料进行学习总结分析。</p><h2 id="Web工作原理"><a href="#Web工作原理" class="headerlink" title="Web工作原理"></a>Web工作原理</h2><h3 id="URL访问原理"><a href="#URL访问原理" class="headerlink" title="URL访问原理"></a>URL访问原理</h3><p>我们在使用网页时都是通过URL访问的，而一个URL会包含如下数据</p><pre><code>scheme://host[:port#]/path/.../[?query-string][#anchor]scheme    :    指定使用协议(http/https/ftp/...)host    :    HTPP服务器的IP地址或者域名(域名会经过解析转换为IP)port#    :    HTTP服务器未指明的默认端口是80path    :    访问资源的路径query-string    :    发送给HTTP服务器的数据anchor    :    锚点，是网页内部的定位点，浏览器加载页面后会自动滚动到锚点位置</code></pre><p>当然这里有绝对URL和相对URL的区别，绝对URL包含了完整的URL，相对URL则需要依据当前位置进行资源的定位，这里就不赘述了。</p><h3 id="用户访问Web总过程"><a href="#用户访问Web总过程" class="headerlink" title="用户访问Web总过程"></a>用户访问Web总过程</h3><p>首先我们从用户在访问一个Web站点的过程来看：</p><ol><li>客户端通过TCP/IP协议建立与服务器的TCP连接</li><li>客户端向服务端发送HTTP协议请求包(Request)，请求服务器的资源文档</li><li>服务端向客户端发送HTTP协议应答包(Response)，将处理后的数据返回给客户端</li><li>客户端渲染解释HTML文档</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://static01.imgkr.com/temp/cdda5e80aaff4a83a96870d1c3337eec.png" alt="用户访问Web服务过程"></h2><h3 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h3><p>这篇文章简单介绍了一下DNS解析的过程，解释了<strong>DNS服务网络</strong>是如何通过客户端的<strong>域名解析请求</strong>获取<strong>IP地址</strong>并回复的</p><p><a href="https://zhuanlan.zhihu.com/p/88260838">DNS原理及解析过程详解 - 知乎 (zhihu.com)</a></p><h3 id="HTTP请求包"><a href="#HTTP请求包" class="headerlink" title="HTTP请求包"></a>HTTP请求包</h3><p>请求包分为三个部分:</p><ul><li>请求行(Request line)</li><li>请求头(Request header)</li><li>主体(body)</li></ul><p>如：</p><pre><code>GET /domains/example/ HTTP/1.1        //请求行: 请求方法 请求URI HTTP协议/协议版本Host：www.iana.org                //服务端的主机名User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4            //浏览器信息Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    //客户端能接收的mineAccept-Encoding：gzip,deflate,sdch        //是否支持流压缩Accept-Charset：UTF-8,*;q=0.5        //客户端字符编码集//空行,用于分割请求头和消息体//消息体,请求资源参数,例如POST传递的参数</code></pre><h3 id="HTTP响应包"><a href="#HTTP响应包" class="headerlink" title="HTTP响应包"></a>HTTP响应包</h3><p>响应包分为三个部分：</p><ul><li>响应行(Response line)</li><li>响应头(Response header)</li><li>响应体(body)</li></ul><p>如：</p><pre><code>HTTP/1.1 200 OK                        //状态行Server: nginx/1.0.8                    //服务器使用的WEB软件名及版本Date:Date: Tue, 30 Oct 2012 04:14:25 GMT        //发送时间Content-Type: text/html                //服务器发送信息的类型Transfer-Encoding: chunked            //表示发送HTTP包是分段发的Connection: keep-alive                //保持连接状态Content-Length: 90                    //主体内容长度//空行 用来分割消息头和主体&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"... //消息体</code></pre><p>响应行(书中称状态行)包括：</p><ul><li>HTTP协议版本号</li><li>状态码</li><li>状态信息</li></ul><p>状态码是用来告诉HTTP客户端，HTTP服务器是否产生预期的Response，在HTTP/1.1协议中定义了5类状态码:</p><ul><li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li><li>2XX 成功 - 表示请求已被成功接收，理解，接受</li><li>3XX 重定向 - 要完成请求必须进行更进一步的处理</li><li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li><li>5XX 服务器端错误 - 服务器未能实现合法的请求</li></ul><h2 id="Golang的简单Web服务实现"><a href="#Golang的简单Web服务实现" class="headerlink" title="Golang的简单Web服务实现"></a>Golang的简单Web服务实现</h2><h3 id="服务的简单实现"><a href="#服务的简单实现" class="headerlink" title="服务的简单实现"></a>服务的简单实现</h3><p>这里是一个简单的Web服务实现代码</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (   "fmt"   "net/http"   "strings")func sayhelloName(w http.ResponseWriter, r *http.Request) {   // 解析参数，默认是不会解析的，需要解析了才能读取r中的表单元素   _ = r.ParseForm()   // 这些信息是输出到服务器端的打印信息   fmt.Println(r.Form)   fmt.Println("path", r.URL.Path)   // 这个写入到w的是输出到客户端的   _, _ = fmt.Fprintf(w, "Hello KK!")}func main() {   // 设置访问的路由   http.HandleFunc("/", sayhelloName)   // 设置监听的端口   _ = http.ListenAndServe(":9090", nil)}</code></pre><p>这里是采用Go的net/http库提供的默认路由</p><ul><li><code>http.HandleFunc("/", sayhelloName)</code>声明了默认路由的解析方法</li><li><code>http.ListenAndServe(":9090", nil)</code>设置了服务监听的端口和使用的路由</li><li>具体对请求包和响应包的操作可以参考<code>sayhelloName</code>函数</li></ul><h3 id="路由的简单实现"><a href="#路由的简单实现" class="headerlink" title="路由的简单实现"></a>路由的简单实现</h3><p>如果我们想自己写一个路由呢？</p><p>下面的代码使用MyMux类型作为<code>http.ListenAndServe()</code>的第二个参数，我们只用让MyMux类型实现ServeHTTP方法就可以正常工作</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "net/http")type MyMux struct {}func (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {    // 路由处理    if r.URL.Path == "/" {        sayhelloName(w, r)        return    }    http.NotFound(w, r)    return}func sayhelloName(w http.ResponseWriter, r *http.Request) {    // 访问路由    _, _ = fmt.Fprintf(w, "Hello KK!")}func main() {    // 自己写的路由    mux := &MyMux{}    // 监听    _ = http.ListenAndServe(":9090", mux)}</code></pre><h2 id="Golang实现Web的原理"><a href="#Golang实现Web的原理" class="headerlink" title="Golang实现Web的原理"></a>Golang实现Web的原理</h2><h3 id="服务运行机制"><a href="#服务运行机制" class="headerlink" title="服务运行机制"></a>服务运行机制</h3><p>Go执行Web服务的工作模式：</p><ol><li>创建<code>Listen Socket</code>监听端口，等待客户端请求</li><li><code>Listen Socket</code>接收到客户端请求得到<code>Client Socket</code></li><li><code>Client Socket</code>分配<code>Handler</code>处理客户端请求，返回数据给客户端</li></ol><p><img src="https://static01.imgkr.com/temp/70f82c2575be4f638a0f34b8e7c27eb7.png" alt="HTTP包执行流程"></p><h3 id="ListenAndServe原理"><a href="#ListenAndServe原理" class="headerlink" title="ListenAndServe原理"></a><code>ListenAndServe</code>原理</h3><p>对于上面的三个过程(监听端口，接收请求，分配Handler)，Go通过函数<code>ListenAndServe</code>进行处理</p><p><img src="https://static01.imgkr.com/temp/44750792f1c342d191f8774f8c193920.png" alt="ListenAndServe内部过程"></p><p><strong>监听端口：</strong><br>初始化一个server对象，调用<code>net.Listen("tcp",addr)</code>(用TCP协议搭建服务)，监控<code>ListenAndServe</code>第一个参数设置的端口</p><p><strong>接收请求：</strong><br>调用<code>srv.Serve(net.Listener)</code>函数接收处理请求，下面是其源码</p><pre class=" language-lang-Go"><code class="language-lang-Go">func (srv *Server) Serve(l net.Listener) error {    defer l.Close()    var tempDelay time.Duration // how long to sleep on accept failure    for {        rw, e := l.Accept()        if e != nil {            if ne, ok := e.(net.Error); ok && ne.Temporary() {                if tempDelay == 0 {                    tempDelay = 5 * time.Millisecond                } else {                    tempDelay *= 2                }                if max := 1 * time.Second; tempDelay > max {                    tempDelay = max                }                log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay)                time.Sleep(tempDelay)                continue            }            return e        }        tempDelay = 0        c, err := srv.newConn(rw)        if err != nil {            continue        }        go c.serve()    }}</code></pre><p>这个函数在内部先用Listener接收请求，然后创建Conn，最后开启一个goroutine进行处理(这里是高并发的体现)</p><blockquote><p>Conn是一种通用的面向流的网络连接，多个Goroutine可以同时调用Conn上的方法。</p></blockquote><p><strong>分配Handler：</strong><br>Coon先解析Request，获取相应的Handler(<code>ListenAndServe</code>第二个参数：路由器)。路由器通过url匹配，跳转到相应的handle函数，通过写入Response的信息返回给客户端。</p><h3 id="路由内部原理"><a href="#路由内部原理" class="headerlink" title="路由内部原理"></a>路由内部原理</h3><p>Golang为我们提供了默认的路由器:</p><pre class=" language-lang-Go"><code class="language-lang-Go">type ServeMux struct {    mu sync.RWMutex   //锁，由于请求涉及到并发处理，因此这里需要一个锁机制    m  map[string]muxEntry  // 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式    hosts bool // 是否在任意的规则中带有host信息}type muxEntry struct {    explicit bool   // 是否精确匹配    h        Handler // 这个路由表达式对应哪个handler    pattern  string  //匹配字符串}type Handler interface {    ServeHTTP(ResponseWriter, *Request)  // 路由实现器}</code></pre><blockquote><p>Handler是一个接口，而我们所写的函数并没有实现<code>ServeHTTP</code>这个接口函数，是因为<code>HTTP</code>包为我们提供了一个类型:<code>HandlerFunc</code>，他将我们所写的函数强制转换为了HandlerFunc类型实现了接口方法。</p><pre class=" language-lang-Go"><code class="language-lang-Go">type HandlerFunc func(ResponseWriter, *Request)// ServeHTTP calls f(w, r).func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {    f(w, r)}</code></pre></blockquote><p>在路由内部存储了我们设定的路由规则，当路由接收到用户请求的url，会与路由存储的map进行匹配，进而调用相应的handler进行处理。</p><p>下为相关的路由匹配源码</p><pre class=" language-lang-Go"><code class="language-lang-Go">func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {    if r.RequestURI == "*" {        w.Header().Set("Connection", "close")        w.WriteHeader(StatusBadRequest)        return    }    h, _ := mux.Handler(r)    h.ServeHTTP(w, r)}func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {    if r.Method != "CONNECT" {        if p := cleanPath(r.URL.Path); p != r.URL.Path {            _, pattern = mux.handler(r.Host, p)            return RedirectHandler(p, StatusMovedPermanently), pattern        }    }        return mux.handler(r.Host, r.URL.Path)}func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {    mux.mu.RLock()    defer mux.mu.RUnlock()    // Host-specific pattern takes precedence over generic ones    if mux.hosts {        h, pattern = mux.match(host + path)    }    if h == nil {        h, pattern = mux.match(path)    }    if h == nil {        h, pattern = NotFoundHandler(), ""    }    return}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用字符编码的介绍与相关问题</title>
      <link href="/2022/022043303.html"/>
      <url>/2022/022043303.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在我的日常生活里，时常能遇到一些朋友出现一些神奇的问题，比如：</p><ul><li>微信直接Copy代码然后编译/上传不通过（甚至搞崩某OJ）</li><li>拷贝别人的代码或者从不同编译器打开代码看到内部中文出现乱码</li><li>编程器在编译时不能输出或者支持中文字符</li><li>进行密码的转码时被一堆奇怪的格式转换弄的头大</li><li>玩游戏时输入的一些字会被识别成乱码</li></ul><p>在了解和帮助我的朋友们解答这些问题的同时，了解到了许多编码常识。<br>于是乎，本文将基于WIKI和一些相关资料，对生活中常见的一些编码进行简单的介绍，并介绍一下我对上述问题粗浅的理解。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><blockquote><p>Wiki： “<strong>字符编码</strong> (Character encoding)是把<strong>字符集</strong>中的<strong>字符</strong>编码成指定集合中的某一对象”</p></blockquote><p>简单的说，<strong>字符编码</strong>(Character encoding) 就是将字符转换成另一种便于计算机存储和传递的形式，例如二进制数字</p><p>比如将K编为 <code>00000001</code> (占用1 Byte) 并以此类推构成一个对应表</p><div class="table-container"><table><thead><tr><th>字符</th><th>编码</th></tr></thead><tbody><tr><td>K</td><td>00000001</td></tr><tr><td>b</td><td>00000002</td></tr><tr><td>i</td><td>00000003</td></tr><tr><td>s</td><td>00000004</td></tr></tbody></table></div><p>那么在我们这里设置的编码体系内 <code>00000001 00000001 00000002 00000003 00000004 00000004</code> 便对应着 <code>KKbiss</code></p><p>字符编码相关的一些概念: </p><ul><li><strong>码点</strong> : 码点（Code point）表示一个字符在字符集中所处的位置。可以理解为[<em>这是字符集中的第几个字符</em>]</li><li><strong>码元</strong> : 码元 (Code Unit) 表示一个编码体系中最短比特组合的单元，比如UTF-8的码元是8 bit, UTF-16的码元是 16 bit。</li><li><strong>现代编码模型</strong> : 相较于传统编码模型，<strong>现代编码模型</strong>将字符编码过程分为了五个层次，详细可以参考WIKI : <a href="https://zh.wikipedia.org/wiki/字符编码">字符编码 - 维基百科，自由的百科全书 (wikipedia.org)</a></li></ul><p>本文将涉及的一些字符编码：</p><div class="table-container"><table><thead><tr><th>标准</th><th>字符编码</th></tr></thead><tbody><tr><td>通用</td><td>ASCII</td></tr><tr><td>欧洲标准</td><td>ISO/IEC 8859</td></tr><tr><td>中国标准</td><td>GB 2312、GB 18030、GBK、Big5</td></tr><tr><td>Unicode</td><td>Unicode、UTF-8、UTF-16</td></tr></tbody></table></div><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p><strong>ASCII</strong>(<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange 美国信息交换标准代码) 应该是计算机学生最早接触的编码了，目前几乎所有的常见编码体系都会支持ASCII码(除了UTF-16和UTF-32)。</p><p>ASCII有一个特点是他分为了<strong>控制字符</strong>和<strong>可显示字符</strong>，原因是ASCII是由电报码发展而来，有一部分字符被用作表示<strong>文本开始、文本结束、换行</strong>等功能。</p><h4 id="控制字符"><a href="#控制字符" class="headerlink" title="控制字符"></a>控制字符</h4><p>ASCII控制字符的编号范围为[0-31]与127共33个字符<br>在大部分的终端系统里（cmd.exe、Linux Shell、FreeBSD)，控制字符都采用<strong>脱出字符表示法</strong>以表示，用<code>Ctrl</code>表示脱出字符，比如 cmd.exe 中最常用的<code>Ctrl+C</code>表示结束。</p><blockquote><p>脱出字符表示法: 以脱出字符 ‘^’ 开头，再接一个符号表示控制字符，如 ^C 为本文结束</p></blockquote><p><img src="https://static01.imgkr.com/temp/0d51ff589b994524b26430b7dd28b0d2.png" alt="ASCII控制字符"></p><blockquote><p>[图源:  <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII - 维基百科，自由的百科全书 (wikipedia.org)</a>]</p></blockquote><h4 id="可显示字符"><a href="#可显示字符" class="headerlink" title="可显示字符"></a>可显示字符</h4><p>ASCII可显示字符的编号范围为[32-126]共95个字符</p><p><img src="https://static01.imgkr.com/temp/e398113d5e5a4daa8c2a7390f553fe1b.png" alt="ASCII可显示字符"></p><blockquote><p>[图源:  <a href="https://zh.wikipedia.org/wiki/ASCII">ASCII - 维基百科，自由的百科全书 (wikipedia.org)</a>]</p></blockquote><h3 id="ISO-IEC-8859"><a href="#ISO-IEC-8859" class="headerlink" title="ISO/IEC 8859"></a>ISO/IEC 8859</h3><blockquote><p>Wiki : ISO 8859 是 国际标准化组织(ISO)及 国际电工委员会 (IEC) 联合制定的一系列8位元字符集的标准 </p></blockquote><p>ASCII收录的字符足够英语使用，但是对于欧洲许多国家来说就不够了。比如法语的重音符号、东欧语言的西里尔字母等等。ISO/IEC 8859的一系列字符标准因此而生。</p><p>ISO 8859字符集:</p><ul><li>ISO/IEC 8859-1 (Latin-1) - 西欧语言</li><li>ISO/IEC 8859-2 (Latin-2) - 中欧语言</li><li>ISO/IEC 8859-3 (Latin-3) - 南欧语言、世界语</li><li>ISO/IEC 8859-4 (Latin-4) - 北欧语言</li><li>ISO/IEC 8859-5 (Cyrillic) - 斯拉夫语言</li><li>ISO/IEC 8859-6 (Arabic) - 阿拉伯语</li><li>ISO/IEC 8859-7 (Greek) - 希腊语</li><li>ISO/IEC 8859-8 (Hebrew) - 希伯来语（视觉顺序）<ul><li>ISO 8859-8-I - 希伯来语（逻辑顺序）</li></ul></li><li>ISO/IEC 8859-9（Latin-5 或 Turkish）- 它把Latin-1的冰岛语字母换走，加入土耳其语字母。</li><li>ISO/IEC 8859-10（Latin-6 或 Nordic）- 北日耳曼语支，用来代替Latin-4。</li><li>ISO/IEC 8859-11 (Thai) - 泰语，从泰国 TIS620 标准字集演化而来。</li><li>ISO/IEC 8859-13（Latin-7 或 Baltic Rim）- 波罗的语族</li><li>ISO/IEC 8859-14（Latin-8 或 Celtic）- 凯尔特语族</li><li>ISO/IEC 8859-15 (Latin-9) - 西欧语言，加入Latin-1欠缺的芬兰语字母和大写法语重音字母，以及欧元（€）符号。</li><li>ISO/IEC 8859-16 (Latin-10) - 东南欧语言。主要供罗马尼亚语使用，并加入欧元符号。</li></ul><blockquote><p>[资料源：<a href="https://zh.wikipedia.org/wiki/ISO/IEC_8859">ISO/IEC 8859 - 维基百科，自由的百科全书 (wikipedia.org)</a>]</p></blockquote><p>一个有趣的事情，这个系列是没有ISO/IEC 8859-12的。<br>一个说法是它本来要设计成塞尔特语族字符集，但后来塞尔特语族变成了ISO 8859-14。另一个说法是它本来要预留给印度天城梵文，后来被搁置了。</p><p>另外ISO还有一个ISO 6438，是非洲字母的字符集，但是很少被采纳。</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>看到ISO/IEC 8859这一堆语言的字符集，是不是感觉很混乱，如果有一个体系能让呢么多的字符集统一起来，事情就会简单很多。</p><p><strong>Unicode</strong> (统一码) 整理、编码了世界上大部分的文字系统，换句话说，Unicode用数字把世界上所有的字符都表示了出来！</p><p><strong>Unicode 平面</strong></p><p>Unicode 编码空间由17个平面（Plane）组成，每个平面最多可以包含$2^{16} = 65536$个字符。第一个平面称为<strong>基本多语言平面 </strong> BMP(Basic Multilingual Plane) 或称<strong>第零平面</strong>(Plane 0) 其他平面均称为<strong>辅助平面</strong>(Supplementary Planes)。目前的汉字字符主要出现在第0,1,2平面中</p><p><strong>Unicode Zalgo Text</strong></p><blockquote><p>[来自周总的文章：<a href="https://darkyzhou.net/articles/character-encoding-you-must-know">关于字符编码，这些知识一定要知道 · Darky’s Blog (darkyzhou.net)</a>]</p></blockquote><p>这个文章出了点问题，你看这字都成乱码了：H̴͓̪̩̟̳̺̠̫̤͉̭̗̊̏͑e̷̛̮̠͖͕̝͍̤l̸̛̮͈͍̬̇̈͌́̌̑̎̿͌͝l̶͔͕̀̒̋͐ȍ̷̡̧̦̘̹̺̫̟̭̣͂̌͗̍̽͒̈͑̋̈́͂͑̄͠ ̴̨̲͓̙̺̰͖̞̯̼̝͚̦̐̈́͊̂̊́͊̚ͅw̷̝͍͑̋͐̂͘o̸̱̽̈̓̌̅̽̑́̔͒̃̏̅͗r̶͙͖̬͙̚͝ͅl̴̨͇͙͇̯̬͔̙̞͛̑̈̀͑̓̉̈́͒̾͠͝d̷̠͙̲̗̲̍̐̅</p><p>事实上这是Unicode Zalgo Text的特性，Unicode有着许多给前面的字符顶部或底部加上记号的特殊字符：Acute accent，通常用于拉丁语、希腊语等有特殊标记符的语言中</p><h3 id="UTF系列"><a href="#UTF系列" class="headerlink" title="UTF系列"></a>UTF系列</h3><p>理论上Unicode 只是一个大字符集，不是编码规范。而UTF-8、UTF-16、UTF-32就是提供的具体的编码规范。Unicode本身只是一个数字与字符对应的大字典。</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8可能是目前<strong>最常用</strong>的编码方式了，它的最大特点是<strong>可变长</strong>，即能使用不同字节数去表示Unicode的所有有效码点。</p><div class="table-container"><table><thead><tr><th>字节数</th><th>二进制编码格式</th></tr></thead><tbody><tr><td>1</td><td>0xxxxxxx</td></tr><tr><td>2</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>3</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>4</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>5</td><td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>6</td><td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table></div><p>UTF-8的编码规则</p><ul><li>在编码中开头连续出现的”1”的个数表示用该字符占用字节个数</li><li>凡是不属于首字节的字节都以<code>10</code>开头</li><li>x中的位置是真正用来表示Unicode数值的位置。</li></ul><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>如果你认真读了Unicode里平面的介绍，你会知道Unicode的一个编码平面有$2^{16}$个字符，而UTF-16便基于<strong>第零平面</strong>和<strong>辅助平面</strong>进行区分，前者内的字符占用2个字节，后者占用4个字节。</p><p>UTF-16对字符所处平面进行区分的依据是<strong>代理对</strong>(Surrogate Pair)</p><p><strong>代理对</strong>的原理：第零平面内从U+D800到U+DFFF是一个空段，这些码点并不对应任何字符，因而这些空段可以用来映射辅助平面的字符。<br>辅助平面的码点有22w+个，因此表示这些字符最少需要20个二进制位，UTF-16将这些二进制位分为两半：</p><ul><li>前10位映射在U+D800到U+DBFF，称为高位(H)</li><li>后10位映射在U+DC00到U+DFFF，称为低位(L)</li></ul><p>Unicode3.0 中给出了辅助平面字符的转换公式：</p><pre><code>H = Math.floor((c-0x10000) / 0x400)+0xD800L = (c - 0x10000) % 0x400 + 0xDC00</code></pre><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>UTF-32是定长的编码，其每个32位值代表一个Unicode码位，并且与该码位数值完全一致。</p><p>UTF-32可以直接通过Unicode码位进行索引，但是由于他定长的特性，空间浪费太大，因此大部分编码规则会采用UTF-8或UTF-16</p><blockquote><p>冷知识: Go语言的<code>rune</code>类型使用的是UTF-32编码</p></blockquote><h3 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h3><p>ISO 8859的提出可以解决欧洲国家多出来的字符，在Unicode标准出现前中国汉字的个数显然是不可能在原来ASCII的标准下装的完的。在此基础上，国家推出了GB 2312规范。其中GB是国标的缩写，指国家标准。</p><p>中文编码的包含关系图：</p><p><img src="https://static01.imgkr.com/temp/68b9235c67cb4f4d8ec0e767adf864b0.jpg" alt="中文编码的包含关系图"></p><blockquote><p>[图源：<a href="https://zhuanlan.zhihu.com/p/46216008">程序员必备：彻底弄懂常见的7种中文字符编码 - 知乎 (zhihu.com)</a>]</p></blockquote><h4 id="GB-T-2312"><a href="#GB-T-2312" class="headerlink" title="GB/T 2312"></a>GB/T 2312</h4><p>原GB 2312现在应该称GB/T 2312，因为2312标准并不能覆盖所有繁体字，在后来国家从强制标准转成了推荐标准，即”T”记号。</p><p>GB/T 2312对汉字进行分区，每区含有94个汉字／符号，共计94个区。用所在的区和位来表示字符（码位），因此称为区位码。<br>例如”万”在45区82位，则万的区位码为: 45, 82，分别处于高低位字节。</p><ul><li>01~09区（682个）：特殊符号、数字、英文字符、制表符等，包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母等在内的682个全角字符；</li><li>10~15区：空区，留待扩展；在附录3，第10区推荐作为 GB 1988–80 中的94个图形字符区域（即第3区字符之半形版本）。</li><li>16~55区（3755个）：常用汉字（也称一级汉字），按拼音排序；</li><li>56~87区（3008个）：非常用汉字（也称二级汉字），按部首/笔画排序；</li><li>88~94区：空区，留待扩展。</li></ul><h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>GB 2312没有完整收录<strong>一些汉字</strong>和<strong>繁体字</strong>，在其基础上进行拓展，形成了GBK<br>也是大部分人所接触的汉字编码形式(Windows简体中文版使用的就是GBK)</p><p><strong>汉字内码扩展规范</strong>(简称: GBK)，其中K表示”扩展”，GB表示”国标”</p><p>字符有一字节和双字节编码</p><ul><li>第一个字节在00–7F范围内为单字节，和ASCII保持一致，此范围内严格上说有96个文字和32个控制符号。</li><li>第一个字节在81-FE范围内为双字节<ul><li>第二字节一部分在40-7E范围内</li><li>第二字节其他领域在80-FE范围内</li></ul></li></ul><p>GBK的编码范围：</p><div class="table-container"><table><thead><tr><th style="text-align:center">范围</th><th style="text-align:center">第1字节</th><th style="text-align:center">第2字节</th><th style="text-align:center">编码数</th><th style="text-align:center">字数</th></tr></thead><tbody><tr><td style="text-align:center">水准GBK/1</td><td style="text-align:center">A1–A9</td><td style="text-align:center">A1–FE</td><td style="text-align:center">846</td><td style="text-align:center">717</td></tr><tr><td style="text-align:center">水准GBK/2</td><td style="text-align:center">B0–F7</td><td style="text-align:center">A1–FE</td><td style="text-align:center">6,768</td><td style="text-align:center">6,763</td></tr><tr><td style="text-align:center">水准GBK/3</td><td style="text-align:center">81–A0</td><td style="text-align:center">40–FE (7F除外)</td><td style="text-align:center">6,080</td><td style="text-align:center">6,080</td></tr><tr><td style="text-align:center">水准GBK/4</td><td style="text-align:center">AA–FE</td><td style="text-align:center">40–A0 (7F除外)</td><td style="text-align:center">8,160</td><td style="text-align:center">8,160</td></tr><tr><td style="text-align:center">水准GBK/5</td><td style="text-align:center">A8–A9</td><td style="text-align:center">40–A0 (7F除外)</td><td style="text-align:center">192</td><td style="text-align:center">166</td></tr><tr><td style="text-align:center">用户定义</td><td style="text-align:center">AA–AF</td><td style="text-align:center">A1–FE</td><td style="text-align:center">564</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">用户定义</td><td style="text-align:center">F8–FE</td><td style="text-align:center">A1–FE</td><td style="text-align:center">658</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">用户定义</td><td style="text-align:center">A1–A7</td><td style="text-align:center">40–A0 (7F除外)</td><td style="text-align:center">672</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">合计：</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">23,940</td><td style="text-align:center">21,886</td></tr></tbody></table></div><blockquote><p>[资料源：<a href="https://zh.wikipedia.org/wiki/汉字内码扩展规范">汉字内码扩展规范 - 维基百科，自由的百科全书 (wikipedia.org)</a>]</p></blockquote><h4 id="GB-18030"><a href="#GB-18030" class="headerlink" title="GB 18030"></a>GB 18030</h4><p>人类总是贪心的，GBK的两万多字也已经不够我们用了。于是，在GBK的基础上，变长的GB 18030解决了中文、日文、朝鲜语等的编码</p><p>GB 18030主要有以下特点：</p><ul><li>采用变长多<a href="https://zh.wikipedia.org/wiki/字节">字节</a>编码，每个字可以由1个、2个或4个字节组成。</li><li>编码空间庞大，最多可定义161万个字符。</li><li>完全支持Unicode，无需动用造字区即可支持中国国内少数民族文字、中日韩和繁体汉字以及emoji等字符。</li></ul><p>虽然GB 18030编码的字数远远多于GBK，但实际业务里GBK见得要常见的多，因为如果看一下GB 18030编码的文字，你会跟我一样觉得自己是个文盲233。</p><p><img src="https://static01.imgkr.com/temp/038868515f5d48399b0a75622f651abe.jpg" alt="GB18030编码的部分汉字"></p><p>下图展现了一些中文编码在前两个字节内的编码实现(兼容意味着下位面积同时也是上位面积)</p><ul><li>GB2312兼容ASCII</li><li>GBK兼容GB 2312</li><li>GB18030兼容GBK</li></ul><p><img src="https://static01.imgkr.com/temp/65eaed76a5144a5fb33627aacc66bbf3.jpg" alt="几种不同编码的前2字节值域"></p><blockquote><p>[图源：<a href="https://zhuanlan.zhihu.com/p/46216008">程序员必备：彻底弄懂常见的7种中文字符编码 - 知乎 (zhihu.com)</a>]</p></blockquote><h4 id="Big5"><a href="#Big5" class="headerlink" title="Big5"></a>Big5</h4><p> <strong>大五码</strong>(Big5)是使用繁体中文社群中常用的汉字标准(Windows繁体中文版使用Big5)</p><p>Big5虽普及于港澳台等繁体中文地区，但长期并非官方标准。用两个字节存储一个中文汉字。</p><p>Big5本身存在一些神奇的问题</p><ul><li><strong>冲码问题</strong>：因为低比特字符中包含了编程语言、shell、script中字符串或命令常用的特殊字符<code>@ A-Z [ \ ] ^ _ ` a-z { | } ~</code>因而许多软件无法正常处理以Big5编码的字符串或文件。于是这个问题又叫”許功蓋”(这三个字都有这个问题)</li><li><strong>画线字符相冲</strong>：例如<code>│維基百科│</code>以Big5码存储，显示时会变成<code>竟�穧坌鮈�</code></li></ul><h2 id="杂谈＆回答"><a href="#杂谈＆回答" class="headerlink" title="杂谈＆回答"></a>杂谈＆回答</h2><p>[更新中]</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/字符编码">字符编码 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/46216008">程序员必备：彻底弄懂常见的7种中文字符编码 - 知乎 (zhihu.com)</a></p><p><a href="https://darkyzhou.net/articles/character-encoding-you-must-know#介绍">关于字符编码，这些知识一定要知道 · Darky’s Blog (darkyzhou.net)</a></p><p>and 一些零散的其他资料…</p>]]></content>
      
      
      <categories>
          
          <category> 生活常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码-多表替换</title>
      <link href="/2021/121421377.html"/>
      <url>/2021/121421377.html</url>
      
        <content type="html"><![CDATA[<h2 id="playfair密码-Playfair-cipher-Playfair-square"><a href="#playfair密码-Playfair-cipher-Playfair-square" class="headerlink" title="playfair密码(Playfair cipher / Playfair square)"></a>playfair密码(Playfair cipher / Playfair square)</h2><h2 id="更新中！"><a href="#更新中！" class="headerlink" title="更新中！"></a>更新中！</h2>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> 古典密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 古典密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-美团网络安全高校挑战赛2021</title>
      <link href="/2021/121140268.html"/>
      <url>/2021/121140268.html</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="https://static01.imgkr.com/temp/6ab277a9adb04f4691829aa881e763b7.png" alt="Symbols.png"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于经常写文档的你，一定对LaTeX的特殊字符不陌生</p><p>将对应字符的首位连起来就是本题的flag了</p><h3 id="LaTeX代码"><a href="#LaTeX代码" class="headerlink" title="LaTeX代码"></a>LaTeX代码</h3><p><img src="https://static01.imgkr.com/temp/e513474ef4cc43e3bfce6a1a5467b558.png" alt="Symbols"></p><h2 id="hamburgerRSA"><a href="#hamburgerRSA" class="headerlink" title="hamburgerRSA"></a>hamburgerRSA</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre class=" language-lang-python"><code class="language-lang-python">import Crypto.Util.numberflag = open('flag.txt').read()nbit = 64while True:    p, q = Crypto.Util.number.getPrime(nbit), Crypto.Util.number.getPrime(nbit)    PP = int(str(p) + str(p) + str(q) + str(q))    QQ = int(str(q) + str(q) + str(p) + str(p))    if Crypto.Util.number.isPrime(PP) and Crypto.Util.number.isPrime(QQ):        breakn = PP * QQm = Crypto.Util.number.bytes_to_long(flag.encode())c = pow(m, 65537, n)print('n =', n)print('c =', c)n = 177269125756508652546242326065138402971542751112423326033880862868822164234452280738170245589798474033047460920552550018968571267978283756742722231922451193c = 47718022601324543399078395957095083753201631332808949406927091589044837556469300807728484035581447960954603540348152501053100067139486887367207461593404096</code></pre><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以把PP,QQ的生成过程拆分成以下过程</p><pre class=" language-lang-python"><code class="language-lang-python">while True:    p, q = getPrime(nbit), getPrime(nbit)    P = int(str(p) + str(p))    Q = int(str(q) + str(q))    PP = int(str(P) + str(Q))    QQ = int(str(Q) + str(P))    if isPrime(PP) and isPrime(QQ):        break</code></pre><p>分析一下N的生成过程：</p><script type="math/tex; mode=display">令x, y = len(p), len(q)\\P = 10^x p + p,\quad Q = 10^y q + q\\令x', y' = len(P), len(Q)\\PP = 10^{x'}P + P,\quad QQ = 10^{y'}Q + Q</script><script type="math/tex; mode=display">PP = 10^{x' + x}p + (10^{x'} + 10^{x} + 1)p    \\QQ = 10^{y' + y}q + (10^{y'} + 10^{y} + 1)q \\则N = PP \cdot QQ = 10^{x' + x + y' + y}p\cdot q + (...)p\cdot q + p\cdot q</script><p>省略号中的相较于$10^{x’+x+y’+y}$要小很多，相较于1要大很多</p><p>于是在N前面的某一部分等价于$p\cdot q$前面的某一部分，后面同理，即：</p><ul><li><code>str(N)[:?]</code> 等价于 <code>str(p*q)[:?]</code></li><li><code>str(N)[?:]</code> 等价于  <code>str(p*q)[?:]</code>.</li></ul><p>通过对省略号内部的分析，我们可以知道<strong>这一部分的长度肯定比$\min(x,y)$要长</strong></p><p>由于题目给出的N的长度为156，则PP的长度为78，p和q的长度之和为39。</p><p>又因为p，q是通过<code>Crypto.Util.number.getPrime(64)</code>生成的，则<strong>p和q的长度为19和20</strong></p><p>呢么我们可以确定$p\cdot q$已知的部分为前19和后19位。</p><p>$p\cdot q$的长度为39位，除却已知的，我们只需要爆破中间的一位即可找到p和q，进而获取flag啦！</p><p>这里可以通过<a href="http://factordb.com/index.php?query=177269125756508652526742722231922451193">factordb.com</a>对十个需要爆破的$p\cdot q$进行因式分解</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import Crypto.Util.numberdef decrypt_RSA(c, e, p, q):    phi = (p-1) * (q-1)    d = Crypto.Util.number.inverse(e, phi)    m = pow(c, d, p*q)    print(Crypto.Util.number.long_to_bytes(m))n = 177269125756508652546242326065138402971542751112423326033880862868822164234452280738170245589798474033047460920552550018968571267978283756742722231922451193c = 47718022601324543399078395957095083753201631332808949406927091589044837556469300807728484035581447960954603540348152501053100067139486887367207461593404096e = 65537# 爆破p,q# low = str(n)[-19:]# high = str(n)[:19]# for i in range(10):#     print(int(high + str(i) + low))# 解密p = 9788542938580474429q = 18109858317913867117P = int(str(p) + str(p))Q = int(str(q) + str(q))PP = int(str(P) + str(Q))QQ = int(str(Q) + str(P))N = PP * QQif N == n:    decrypt_RSA(c, e, PP, QQ)else:    print("error")</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WriteUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码-单表替换</title>
      <link href="/2021/121155226.html"/>
      <url>/2021/121155226.html</url>
      
        <content type="html"><![CDATA[<h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>恺撒密码（Caesar cipher）</strong>，或称<strong>恺撒加密</strong>、<strong>恺撒变换</strong>、<strong>变换加密</strong>，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p><p>其中根据偏移量不同，存在一些特定的凯撒密码：</p><ul><li>偏移量为10：Avocat(A→K)</li><li>偏移量为13：ROT13</li><li>偏移量为-5：Cassis (K 6)</li><li>偏移量为-6：Cassette (K 7)</li></ul><h3 id="破解方式"><a href="#破解方式" class="headerlink" title="破解方式"></a>破解方式</h3><p>对于已知偏移量的情况，直接通过脚本或者网站：<a href="https://ctf.bugku.com/tool/caesar">凯撒(Caesar)加密/解密 - Bugku CTF</a> 计算即可。</p><p>对于未知偏移量的情况，爆破26个偏移量即可。</p><h3 id="Caesar的拓展：基于秘钥的凯撒密码"><a href="#Caesar的拓展：基于秘钥的凯撒密码" class="headerlink" title="Caesar的拓展：基于秘钥的凯撒密码"></a>Caesar的拓展：基于秘钥的凯撒密码</h3><p>利用一个密钥，将密钥的每一位转换为数字（一般转化为字母表对应顺序的数字），分别以这一数字为<strong>对应位的偏移量</strong>加密明文的每一位字母。</p><p>如：</p><pre><code>明文: aaa bbb ccc密钥: ldm ldm ldm偏移量: 11 3 12 11 3 12 11 3 12密文: ldm men nfo</code></pre><h3 id="Caesar的拓展-移位密码"><a href="#Caesar的拓展-移位密码" class="headerlink" title="Caesar的拓展: 移位密码"></a>Caesar的拓展: 移位密码</h3><p>移位密码就是使凯撒密码拓展到<strong>数字、字母、特殊字符</strong>，常在<strong>ASCII码表</strong>上进行移位，破解方式与凯撒密码类似</p><h2 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><strong>简单替换密码(Simple Substitution Cipher)</strong>是设置一个字母对应表，每一种字母均唯一对应一种字母</p><h3 id="破解方式-1"><a href="#破解方式-1" class="headerlink" title="破解方式"></a>破解方式</h3><p>由于简单替换密码的密钥很难确定，最常见的解法是使用词频分析进行破解。</p><p>在线词频分析网站：<a href="http://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a></p><p>如：</p><p><img src="https://static01.imgkr.com/temp/66352edec4434ffca697aa8ae2db54a1.png" alt="image-20211209175539294"></p><h2 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p><strong>仿射密码</strong>是将字母表中的每个字母使用一个简单的数学函数对应一个数值，再将对应数值转换为字母</p><blockquote><p>当$a=1$ 时，仿射加密是凯撒加密。</p></blockquote><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><script type="math/tex; mode=display">E(x) = (ax+b)\mod m</script><p>其中</p><ul><li>$m$为编码系统中字母个数(通常为26)，</li><li>$a$需要与$m$互质，$b$任意。</li><li>x为明文按照某种编码对应的数字</li></ul><h4 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a>解密函数</h4><script type="math/tex; mode=display">D(x) = a^{-1}(x - b) \mod m</script><p>其中</p><ul><li>$a^{-1}$是$a$ 在$Z_m$群的乘法逆元</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>秘钥为(5, 8)进行加密<code>AFFINECIPHER</code></p><div class="table-container"><table><thead><tr><th style="text-align:left">明文</th><th style="text-align:left">A</th><th style="text-align:left">F</th><th style="text-align:left">F</th><th style="text-align:left">I</th><th style="text-align:left">N</th><th style="text-align:left">E</th><th style="text-align:left">C</th><th style="text-align:left">I</th><th style="text-align:left">P</th><th style="text-align:left">H</th><th style="text-align:left">E</th><th style="text-align:left">R</th></tr></thead><tbody><tr><td style="text-align:left">x</td><td style="text-align:left">0</td><td style="text-align:left">5</td><td style="text-align:left">5</td><td style="text-align:left">8</td><td style="text-align:left">13</td><td style="text-align:left">4</td><td style="text-align:left">2</td><td style="text-align:left">8</td><td style="text-align:left">15</td><td style="text-align:left">7</td><td style="text-align:left">4</td><td style="text-align:left">17</td></tr><tr><td style="text-align:left">y=5x+8</td><td style="text-align:left">8</td><td style="text-align:left">33</td><td style="text-align:left">33</td><td style="text-align:left">48</td><td style="text-align:left">73</td><td style="text-align:left">28</td><td style="text-align:left">18</td><td style="text-align:left">48</td><td style="text-align:left">83</td><td style="text-align:left">43</td><td style="text-align:left">28</td><td style="text-align:left">93</td></tr><tr><td style="text-align:left">$y\mod26$</td><td style="text-align:left">8</td><td style="text-align:left">7</td><td style="text-align:left">7</td><td style="text-align:left">22</td><td style="text-align:left">21</td><td style="text-align:left">2</td><td style="text-align:left">18</td><td style="text-align:left">22</td><td style="text-align:left">5</td><td style="text-align:left">17</td><td style="text-align:left">2</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">密文</td><td style="text-align:left">I</td><td style="text-align:left">H</td><td style="text-align:left">H</td><td style="text-align:left">W</td><td style="text-align:left">V</td><td style="text-align:left">C</td><td style="text-align:left">S</td><td style="text-align:left">W</td><td style="text-align:left">F</td><td style="text-align:left">R</td><td style="text-align:left">C</td><td style="text-align:left">P</td></tr></tbody></table></div><p>加密结果：<code>IHHWVCSWFRCP</code></p><h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p>1.先求解5关于模26的乘法逆元，为21</p><p>2.解密函数就是$D(x) = 21(x - 8) \mod 26$</p><p>3.解密如下:</p><div class="table-container"><table><thead><tr><th style="text-align:left">密文</th><th style="text-align:left">I</th><th style="text-align:left">H</th><th style="text-align:left">H</th><th style="text-align:left">W</th><th style="text-align:left">V</th><th style="text-align:left">C</th><th style="text-align:left">S</th><th style="text-align:left">W</th><th style="text-align:left">F</th><th style="text-align:left">R</th><th style="text-align:left">C</th><th style="text-align:left">P</th></tr></thead><tbody><tr><td style="text-align:left">y</td><td style="text-align:left">8</td><td style="text-align:left">7</td><td style="text-align:left">7</td><td style="text-align:left">22</td><td style="text-align:left">21</td><td style="text-align:left">2</td><td style="text-align:left">18</td><td style="text-align:left">22</td><td style="text-align:left">5</td><td style="text-align:left">17</td><td style="text-align:left">2</td><td style="text-align:left">15</td></tr><tr><td style="text-align:left">x = 21(y - 8)</td><td style="text-align:left">0</td><td style="text-align:left">-21</td><td style="text-align:left">-21</td><td style="text-align:left">294</td><td style="text-align:left">273</td><td style="text-align:left">-126</td><td style="text-align:left">210</td><td style="text-align:left">294</td><td style="text-align:left">-63</td><td style="text-align:left">189</td><td style="text-align:left">-126</td><td style="text-align:left">147</td></tr><tr><td style="text-align:left">$x\mod26$</td><td style="text-align:left">0</td><td style="text-align:left">5</td><td style="text-align:left">5</td><td style="text-align:left">8</td><td style="text-align:left">13</td><td style="text-align:left">4</td><td style="text-align:left">2</td><td style="text-align:left">8</td><td style="text-align:left">15</td><td style="text-align:left">7</td><td style="text-align:left">4</td><td style="text-align:left">17</td></tr><tr><td style="text-align:left">明文</td><td style="text-align:left">A</td><td style="text-align:left">F</td><td style="text-align:left">F</td><td style="text-align:left">I</td><td style="text-align:left">N</td><td style="text-align:left">E</td><td style="text-align:left">C</td><td style="text-align:left">I</td><td style="text-align:left">P</td><td style="text-align:left">H</td><td style="text-align:left">E</td><td style="text-align:left">R</td></tr></tbody></table></div><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p>一般来说，我们利用仿射密码时，其字符集都用的是字母表</p><ul><li><p>a的可能范围为$\phi(26)=\phi(2) \times \phi(13) = 12$</p></li><li><p>b的可能范围为26</p></li><li><p>密钥空间大小为$a \cdot b = 312$</p></li></ul><h4 id="在已知部分明文的情况下"><a href="#在已知部分明文的情况下" class="headerlink" title="在已知部分明文的情况下"></a>在已知部分明文的情况下</h4><p>通过：</p><script type="math/tex; mode=display">y_1=(ax_1+b)\mod{26} \\ y_2=(ax_2+b)\mod{26}</script><p>我们可以直接计算出$a,b$的大小，进而进行解密。</p><h4 id="在密文较长的情况下"><a href="#在密文较长的情况下" class="headerlink" title="在密文较长的情况下"></a>在密文较长的情况下</h4><p>可以考虑通过词频分析<a href="http://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a> </p><h2 id="Atbash-Cipher-埃特巴什码"><a href="#Atbash-Cipher-埃特巴什码" class="headerlink" title="Atbash Cipher(埃特巴什码)"></a>Atbash Cipher(埃特巴什码)</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>其实就是把原字母表的逆序作为映射，最后一个字母代表第一个字母，倒数第二个字母代表第二个字母。</p><p>明文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z </p><p>密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</p><h3 id="破解-1"><a href="#破解-1" class="headerlink" title="破解"></a>破解</h3><p>在线网站： <a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/">Practical Cryptography</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ctf-wiki.org/crypto/classical/monoalphabetic/#_17">单表代换加密 - CTF Wiki (ctf-wiki.org)</a></p><p><a href="https://blog.csdn.net/zmx2473162621/article/details/104030171#MD5_449">(31条消息) CTF密码学常见加密解密总结_Root_5476-CSDN博客_ctf音频波形图转化密码</a></p><p><a href="https://blog.csdn.net/Ahuuua/article/details/109189985">(31条消息) CTF密码学——常见编解码及加解密总结<em>Ahuuua的博客-CSDN博客</em>元音密码</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> 古典密码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 古典密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N的分解</title>
      <link href="/2021/120853668.html"/>
      <url>/2021/120853668.html</url>
      
        <content type="html"><![CDATA[<h2 id="在线软件的使用"><a href="#在线软件的使用" class="headerlink" title="在线软件的使用"></a>在线软件的使用</h2><h3 id="factordb"><a href="#factordb" class="headerlink" title="factordb"></a>factordb</h3><p><a href="http://factordb.com">http://factordb.com</a> 记录了部分大质数的分解，很多质数可以直接在这查找出质因数分解</p><h3 id="ECM"><a href="#ECM" class="headerlink" title="ECM"></a>ECM</h3><p><a href="https://www.alpertron.com.ar/ECM.HTM">https://www.alpertron.com.ar/ECM.HTM</a> 是ECM在线分解大整数的网站</p><h2 id="短除法"><a href="#短除法" class="headerlink" title="短除法"></a>短除法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从2开始暴力破解</p><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><pre class=" language-lang-python"><code class="language-lang-python">def factorization(n):    i = 2    ret = []    while i * i <= n:        while n % i == 0:            ret.append(i)            n //= i        i += 1    if n > 1:        ret.append(n)    return retif __name__ == '__main__':    print(factorization(int(input())))</code></pre><h3 id="Python代码2"><a href="#Python代码2" class="headerlink" title="Python代码2"></a>Python代码2</h3><p>(先打表出2到$n^{\frac 12}$之间的质数）</p><pre class=" language-lang-python"><code class="language-lang-python">pri = []MX = int(1e6)isprime = [True] * MXdef init():    global a, MX    for i in range(2, MX):        if isprime[i]:            pri.append(i)            for j in range(i + i, MX, i):                isprime[j] = Falsedef factorization(n):    global pri    ret = []    for i in pri:        if i * i > n:            break        while n % i == 0:            ret.append(i)            n //= i    ret.append(n)    return retif __name__ == '__main__':    init()    print(factorization(int(input())))</code></pre><h2 id="Miller-Rabin素性测试和离散对数Pollard-rho分解"><a href="#Miller-Rabin素性测试和离散对数Pollard-rho分解" class="headerlink" title="Miller-Rabin素性测试和离散对数Pollard_rho分解"></a>Miller-Rabin素性测试和离散对数Pollard_rho分解</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>暂无</p><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">"""用Miller-Rabin素性测试和离散对数Pollard_rho算法进行大数因数分解：复杂度: 0(n^1/4)适用范围: n 2-10^33"""import random# from math import log, log10from collections import Counterdef gcd(x, y):    return x if y == 0 else gcd(y, x % y)def fpow(a, x, n):    ans = 1    while x > 0:        if x & 1:            ans = ans * a % n        a = a * a % n        x >>= 1    return ans# there change the times of Rabin-MillerTIMES = 10def is_prime(n):    def check(a, n, x, t):        ret = fpow(a, x, n)        last = ret        for i in range(0, t):            ret = ret * ret % n            if ret == 1 and last != 1 and last != n - 1:                return True            last = ret        if ret != 1:            return True        return False    if not isinstance(n, int):        raise TypeError(str(n) + ' is not an integer!')    if n <= 0:        raise ValueError('%d <= 0' % n)    if n in {2, 3, 5, 7, 11}:        return True    for i in {2, 3, 5, 7, 11}:        if n % i == 0:            return False    x = n - 1    t = 0    while not x & 1:        x >>= 1        t += 1    for i in range(0, TIMES):        a = random.randint(1, n - 2)        if check(a, n, x, t):            return False    return Truedef pollard_rho_2(n, c):    x = random.randint(0, n)    i, k, y = 1, 2, x    while True:        i += 1        x = (x * x) % n + c        d = gcd(y - x, n)        if d != 1 and d != n:            return d        if y == x:            return n        if i == k:            y = x            k <<= 1def pollard_rho_1(n):    if not isinstance(n, int):        raise TypeError(str(n) + ' is not an integer!')    if n == 1:        return None    if is_prime(n):        return [n]    ans = []    p = n    while p >= n:        p = pollard_rho_2(p, random.randint(1, n - 1))    ans.extend(pollard_rho_1(p))    ans.extend(pollard_rho_1(n // p))    return ansdef factorization(n):    return Counter(pollard_rho_1(n))if __name__ == '__main__':    n = int(input())    print('len:', len(str(n)))    print(factorization(n))</code></pre><h2 id="Fermat分解"><a href="#Fermat分解" class="headerlink" title="Fermat分解"></a>Fermat分解</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>暂无</p><h3 id="Python代码-1"><a href="#Python代码-1" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">from isqrt import isqrtimport libnumdef fermat(n):    a = isqrt(n)    b2 = a * a - n    b = isqrt(n)    count = 0    while b * b != b2:        a = a + 1        b2 = a * a - n        b = isqrt(b2)        count += 1    p = a + b    q = a - b    assert n == p * q    return p, qif __name__ == '__main__':    N = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533    e = 65537    c = 168502910088858295634315070244377409556567637139736308082186369003227771936407321783557795624279162162305200436446903976385948677897665466290852769877562167487142385308027341639816401055081820497002018908896202860342391029082581621987305533097386652183849657065952062433988387640990383623264405525144003500286531262674315900537001845043225363148359766771033899680111076181672797077410584747509581932045540801777738548872747597899965366950827505529432483779821158152928899947837196391555666165486441878183288008753561108995715961920472927844877569855940505148843530998878113722830427807926679324241141182238903567682042410145345551889442158895157875798990903715105782682083886461661307063583447696168828687126956147955886493383805513557604179029050981678755054945607866353195793654108403939242723861651919152369923904002966873994811826391080318146260416978499377182540684409790357257490816203138499369634490897553227763563553981246891677613446390134477832143175248992161641698011195968792105201847976082322786623390242470226740685822218140263182024226228692159380557661591633072091945077334191987860262448385123599459647228562137369178069072804498049463136233856337817385977990145571042231795332995523988174895432819872832170029690848    p, q = fermat(N)    print("p:", p)    print("q:", q)    # 根据p,q求phi_n也即N的欧拉函数值    phi_n = (p-1)*(q-1)    # 求d    d = libnum.invmod(e, phi_n)    # 用d解密    flag = libnum.n2s(pow(c, d, N))    print(flag)</code></pre><h2 id="yafu"><a href="#yafu" class="headerlink" title="yafu"></a>yafu</h2><p><a href="https://sourceforge.net/projects/yafu/">https://sourceforge.net/projects/yafu/</a> </p><blockquote><p>注意：PowerShell可能存在兼容性问题</p></blockquote><p>yafu是一个项目，他综合了Fermat方法与Pollard rho方法。当p、q的取值差异过大或过于相近的时候，使用yafu可以快速的把n值分解出p、q值。</p><ul><li><p>终端进入到 yafu 所在目录</p></li><li><p>比较短的数，如84，可以直接输入命令：<code>.\yafu-x64.exe "factor(84)"</code>。</p></li><li><p>太长的数，将数用文本文件存放在yafu的目录下，运行命令：<code>.\yafu-x64.exe "factor(@)" -batchfile data.txt</code></p><p><code>data.txt</code>是你存放的文本文件，<strong>注意：文件最后一行一定要换行</strong></p></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://bbs.pediy.com/thread-266648.htm">[原创]Crypto-RSA大整数分解-LineCTF2021-babycrypto3</a></p><p><a href="https://www.tr0y.wang/2017/11/06/CTFRSA/#%E5%A4%A7%E6%95%B0%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95">RSA大礼包 - Tr0y’s Blog</a></p><p><a href="https://www.mrskye.cn/archives/18/">yafu 安装及使用 | SkYe231 Blog (mrskye.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA常见解题思路</title>
      <link href="/2021/120661227.html"/>
      <url>/2021/120661227.html</url>
      
        <content type="html"><![CDATA[<h2 id="已知-P-Q-e-求d"><a href="#已知-P-Q-e-求d" class="headerlink" title="已知(P, Q, e) 求d"></a>已知(P, Q, e) 求d</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>q：质数q</li><li>p：质数p</li><li>e：加密指数</li><li>d：解密指数</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">\phi(n) = (p - 1) * (q - 1)    \\ e*d \equiv 1 \mod\phi(n)</script><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2p = ...q = ...e = ...phi_n = (p-1)*(q-1)d = gmpy2.invert(e, phi_n)print(d)</code></pre><h2 id="已知-p-q-e-c-求m"><a href="#已知-p-q-e-c-求m" class="headerlink" title="已知(p,q,e,c) 求m"></a>已知(p,q,e,c) 求m</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>q：质数q</li><li>p：质数p</li><li>e：加密指数</li><li>c：密文c</li><li>m：明文m</li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">n = p * q, \quad \phi(n) = (p - 1) * (q - 1)\\ e*d \equiv 1 \mod \phi(n) \\ m = pow(c, d, n)</script><h3 id="Python代码-1"><a href="#Python代码-1" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2p =  ...q =  ...e =  ...c =  ...phi_n = (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)n = p * qm = gmpy2.powmod(c,d,n)print(str(m) )</code></pre><h2 id="已知-q-p-dq-dp-c-求m"><a href="#已知-q-p-dq-dp-c-求m" class="headerlink" title="已知(q,p,dq,dp,c) 求m"></a>已知(q,p,dq,dp,c) 求m</h2><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li>q：质数q</li><li>p：质数p</li><li>dq：dq ≡ d mod(q - 1)</li><li>dp：dp ≡ d mod(p - 1)</li><li>c：密文</li><li>m：明文</li></ul><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>由于中国剩余定理:</p><script type="math/tex; mode=display">\because m = c^d\ mod n \\ n = p * q \\ \therefore mp \equiv c^d\ mod p \quad ① \\ mq \equiv c^d\ mod q \quad ②</script><p>由①式，有</p><script type="math/tex; mode=display">c^d = k*p + mp \quad ③</script><p>将③式带入②式，有</p><script type="math/tex; mode=display">k * p \equiv (mp - mq) \mod q \\ k \equiv [p^{-1} * (mp - mq)] \mod q</script><p>将k带入③式，有</p><script type="math/tex; mode=display">c^d = \{[p^{-1} * (mp - mq)]\ mod q\} * p + mp</script><p>由费马小定理:</p><script type="math/tex; mode=display">\because d = dp + k_p * (p - 1) = dq + k_q * (q - 1)             \\   \therefore mp \equiv c^d \mod p \equiv c^{dp + k_p * (p - 1)} \mod p \equiv c^{dp} \mod p                          \\ mq \equiv c^d \mod q \equiv c^{dq + k_q * (q - 1)} \mod q \equiv c^{dq} \mod q</script><p>故:</p><script type="math/tex; mode=display">m \equiv c^d = \{[p^{-1} * (mp - mq)] \mod q\} * p + mp</script><h3 id="Python代码-2"><a href="#Python代码-2" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2p = ...q = ...dp = ...dq = ...c = ...I = gmpy2.invert(q,p)mp = pow(c,dp,p)mq = pow(c,dq,q)m = (((mp-mq)*I)%q)*p+mpprint(hex(m))</code></pre><h2 id="已知-e-大数n-dp-c-求m"><a href="#已知-e-大数n-dp-c-求m" class="headerlink" title="已知(e,大数n,dp,c) 求m"></a>已知(e,大数n,dp,c) 求m</h2><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul><li>n：大数字n</li><li>e：加密指数</li><li>dp：dp ≡ d mod (p - 1)</li><li>c：密文c</li><li>m：明文m</li></ul><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">\because e * d \equiv 1 \mod((p-1)(q-1))\\ dp \equiv d \mod(p - 1)    \\ \therefore e*dp \equiv e*d \mod(p-1) \\ \therefore e*d = k_1(p-1)(q-1) + 1 = k_2(p-1) + e*dp               \\ e*dp = (p - 1)(k_1(q-1) - k_2)+1</script><script type="math/tex; mode=display">\because dp < p  \\ \therefore e > (k_1(q-1) - k_2)\\ (k_1(q-1)-k_2) \in (1,e) \\遍历即可</script><h3 id="Python代码-3"><a href="#Python代码-3" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python"># 领航杯2019，EasyRSAimport gmpy2import libnume = ...n = ...dp = ...c = ...for i in range(1, e + 1):    if (dp * e - 1) % i == 0:        if n % (((dp * e - 1) // i) + 1) == 0:            p = ((dp * e - 1) // i) + 1            q = n // (((dp * e - 1) // i) + 1)            phi = (p - 1) * (q - 1)            d = gmpy2.invert(e, phi) % phi            print(libnum.n2s(pow(c, d, n)))</code></pre><h2 id="共模攻击：已知-n-e1-e2-c1-c2-求m"><a href="#共模攻击：已知-n-e1-e2-c1-c2-求m" class="headerlink" title="共模攻击：已知(n,e1,e2,c1,c2) 求m"></a>共模攻击：已知(n,e1,e2,c1,c2) 求m</h2><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul><li>n：大数字n</li><li>e1, e2：加密指数</li><li>c1, c2：密文c</li><li>m：明文m</li></ul><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>共模攻击</p><script type="math/tex; mode=display">c_1 = m^{e_1}\mod n             \\   c_2 = m^{e_2}\mod n</script><p>当e1, e2互质时，有</p><script type="math/tex; mode=display">ae_1 + be_2 = 1</script><p>利用拓展欧几里得算法，可求得(a, b)的一组解</p><script type="math/tex; mode=display">\\\begin{align*} c_1^a * c_2^b\mod n  &= ((m^{e_1}\mod n)^a * (m^{e_2}\mod n)^b)\mod n \\ &= m^{a*e_1+b*e_2}\mod n \end{align*}</script><script type="math/tex; mode=display">\because a * e_1 + b * e_2 = 1  \\ \therefore m\equiv c_1^a*c_2^b\mod n</script><h3 id="Python代码-4"><a href="#Python代码-4" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import binasciin = ...c1 = ...c2 = ...e1 = ...e2 = ...s = gmpy2.gcdext(e1,e2)a = s[1]b = s[2]if a < 0:    a = -a    c1 = gmpy2.invert(c1,n)else:    b = -b    c2 = gmpy2.invert(c2,n)m = (gmpy2.powmod(c1,a,n)*gmpy2.powmod(c2,b,n))%nprint(binascii.unhexlify(hex(m)[2:]))</code></pre><h2 id="n分解出多个质因数-求m"><a href="#n分解出多个质因数-求m" class="headerlink" title="n分解出多个质因数 求m"></a>n分解出多个质因数 求m</h2><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul><li>n：大数字n</li><li>e：加密指数</li><li>p0~pi：n的质因数</li><li>c：密文c</li><li>m：明文m</li></ul><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>n的质因数只影响φ的求值，依据<a href="https://www.notion.so/e18df727d3fa488bbc03275034893cb4">欧拉函数</a>求出φ即可。如n有三个质因数，则</p><script type="math/tex; mode=display">\phi(n) = (p_1 - 1)(p_2 - 1)(p_3 - 1)</script><h3 id="Python代码-5"><a href="#Python代码-5" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2from Crypto.Util.number import long_to_bytesn= ...e= ...c= ...# n的质因数p1 = ...p2 = ...p3 = ...phi = (p1 - 1) * (p2 - 1) * (p3 - 1)  d = gmpy2.invert(e, phi)  m = pow(c, d, n)  print long_to_bytes(m)</code></pre><h2 id="公钥私钥的文件处理"><a href="#公钥私钥的文件处理" class="headerlink" title="公钥私钥的文件处理"></a>公钥私钥的文件处理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>工具：</p><p><a href="https://www.jianshu.com/p/c945b0f0de0a">RSA工具集-openssl,rsatool,RsaCtfTool,RSAtool</a></p><ul><li>RsaCtfTool</li><li>openssl</li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>上代码：</p><p>获取公钥文件的公钥</p><pre class=" language-lang-python"><code class="language-lang-python">from Crypto.PublicKey import RSApath = '...'with open(path) as f:    key = RSA.import_key(f.read())    print('e = %d' % key.e)    print('n = %d' % key.n)</code></pre><p>私钥解密文件</p><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import rsap = ...q = ...n = ...e = ...d = int(gmpy2.invert(e, (p-1) * (q-1)))privatekey = rsa.PrivateKey(n, e, d, p, q)      # 根据已知参数，计算私钥path = "..."with open(path, "rb") as f:    print(rsa.decrypt(f.read(), privatekey).decode())       # 使用私钥对密文进行解密，并打印</code></pre><h2 id="低加密指数分解攻击-e-2-3"><a href="#低加密指数分解攻击-e-2-3" class="headerlink" title="低加密指数分解攻击(e = 2, 3)"></a>低加密指数分解攻击(e = 2, 3)</h2><h3 id="e-2"><a href="#e-2" class="headerlink" title="e = 2"></a>e = 2</h3><h4 id="直接开根"><a href="#直接开根" class="headerlink" title="直接开根"></a>直接开根</h4><script type="math/tex; mode=display">c = m^e \mod n</script><p>因为$e = 2$， 相当于$c$是$m$的平方对$n$取模</p><p>一般开根就可以了</p><p>代码:</p><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnumc = ...m = gmpy2.isqrt(c)m_text = libnum.n2s(int(m) )  #将十六进制转为字符print(m_text)</code></pre><h4 id="Rabin算法"><a href="#Rabin算法" class="headerlink" title="Rabin算法"></a>Rabin算法</h4><p>原理</p><p>对密文  $c \equiv m^2 \mod n$</p><ol><li><p>计算$m_p,m_q$:</p><script type="math/tex; mode=display">m_p = \sqrt c\mod p    \\m_q = \sqrt c\mod q</script><p>若$p, q$满足 $p\equiv q \equiv 3 \mod4$</p><p>则</p><script type="math/tex; mode=display">m_p = c^{\frac14(p+1)} \mod p    \\m_q = c^{\frac14(q+1)} \mod q</script></li><li><p>用拓展欧几里得算法计算$y_p,y_q$：</p><script type="math/tex; mode=display">y_p\cdot p + y_q\cdot q = 1</script></li><li><p>解密</p><script type="math/tex; mode=display">\begin{align}a &= (y_p\cdot p \cdot m_q + y_q\cdot q\cdot m_p) \mod n    \\b &= n - a    \\c &= (y_p\cdot p \cdot m_q - y_q\cdot q\cdot m_p) \mod n    \\d &= n - c\end{align}</script></li></ol><p>代码:</p><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnumn = gmpy2.mpz(87924348264132406875276140514499937145050893665602592992418171647042491658461)p = gmpy2.mpz(275127860351348928173285174381581152299)q = gmpy2.mpz(319576316814478949870590164193048041239)e = gmpy2.mpz(2)c = int(open('C:\\Users\\86189\\Desktop\\flag.enc', 'rb').read().hex(), 16)mp = pow(c, (p+1) // 4, p)mq = pow(c, (q+1) // 4, q)yp = gmpy2.invert(p, q)yq = gmpy2.invert(q, p)r = (yp * p * mq + yq * q * mp) % nrr = n - rs = (yp * p * mq - yq * q * mp) % nss = n - s# 四个明文print(libnum.n2s(int(r)))print(libnum.n2s(int(rr)))print(libnum.n2s(int(s)))print(libnum.n2s(int(ss)))</code></pre><h3 id="e-3"><a href="#e-3" class="headerlink" title="e = 3"></a>e = 3</h3><h4 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h4><script type="math/tex; mode=display">\because c = m^e \mod n \\ \therefore c + k*n = m^e</script><p>e很小的时候，k的值也会很小，所以可以直接爆破</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2,binascii,libnum,timen = ...e = 3c = ...m = 0for i in xrange(200000):    if gmpy2.iroot(c + n * i, e)[1] == 1:        m = gmpy2.iroot(c + n * i, e)[0]        print libnum,n2s(m)        break</code></pre><h2 id="低加密指数广播攻击-已知-n-i-c-i-e-，-求-m"><a href="#低加密指数广播攻击-已知-n-i-c-i-e-，-求-m" class="headerlink" title="低加密指数广播攻击(已知$n_i, c_i, e$， 求$m$)"></a>低加密指数广播攻击(已知$n_i, c_i, e$， 求$m$)</h2><h3 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h3><p>如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。</p><p>对于</p><script type="math/tex; mode=display">c_i = m^e \mod n_i</script><p>使用中国剩余定理，有:</p><script type="math/tex; mode=display">\begin{align}c_x &= m^e\mod \prod n_i \\&= m^e\mod n_1*n_2*...\end{align}</script><h3 id="Python代码1：中国剩余定理"><a href="#Python代码1：中国剩余定理" class="headerlink" title="Python代码1：中国剩余定理"></a>Python代码1：中国剩余定理</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnumdef CRT(data):    sum = 0    m = 1    for n in data:        m = m * n[0]    for n, c in data:        m1 = m / n        mr = gmpy2.invert(m1, n)        sum = sum + mr * m1 * c    return sum % mc1 = ...c2 = ...c3 = ...n1 = ...n2 = ...n3 = ...e = 3n = [n1, n2, n3]c = [c1, c2, c3]data = zip(n, c)m_e = CRT(data)m = gmpy2.iroot(m_e, e)[0]print m    # 输出明文数字 print libnum.n2s(m)   # 输出明文数字转为的字符串</code></pre><h3 id="Python代码2：自动爆破e"><a href="#Python代码2：自动爆破e" class="headerlink" title="Python代码2：自动爆破e"></a>Python代码2：自动爆破e</h3><pre class=" language-lang-python"><code class="language-lang-python">import randomfrom gmpy2 import invert, irootimport libnumdef broadcast(n1, n2 ,n3, c1, c2, c3):    n = [n1, n2, n3]    C = [c1, c2, c3]    N = 1    for i in n:        N *= i    Ni = []    for i in n:        Ni.append(N / i)    T = []    for i in xrange(3):        T.append(long(invert(Ni[i], n[i])))    X = 0    for i in xrange(3):        X += C[i] * Ni[i] * T[i]    m3 = X % N    m = iroot(m3, 3)    return m[0]if __name__=="__main__":    # e = ... （不需要）    c1 = ...    c2 = ...    c3 = ...    n1 = ...    n2 = ...    n3 = ...    m = broadcast(n1, n2 ,n3, c1, c2, c3)    print m    # 输出明文m    print libnum.n2s(m)   # 输出明文数字转化为字符串后的结果</code></pre><h2 id="低解密指数攻击-e太大-太小时"><a href="#低解密指数攻击-e太大-太小时" class="headerlink" title="低解密指数攻击(e太大/太小时)"></a>低解密指数攻击(e太大/太小时)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>低解密指数攻击，也称RSA维纳攻击(RSA Wiener Attack)，是一种基于连分数的特殊攻击类型</p><script type="math/tex; mode=display">e * d \equiv 1 \mod \phi(n)</script><p>满足条件：</p><ul><li>$d &lt; \frac13 n^{\frac14}$</li><li>$q &lt; p &lt; 2q$</li></ul><p>在上述条件下，可以通过Wiener Attack在多项式的时间内分解n</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在RSA中</p><script type="math/tex; mode=display">N = pq,\quad \phi(n) = (p - 1)(q - 1) \approx N \\\because ed \equiv 1\mod \phi(n)    \\\therefore ed - 1 = k * \phi(n),\quad 两边同除 d\phi(n) \\\therefore \frac e{\phi(n)} - \frac kd = \frac 1{d\phi(n)}    \\\because \phi(n) \approx N,\quad \frac 1{d\phi(n)}\approx 0 \\\therefore \frac eN 略大于 \frac kd</script><p>回顾一下已知条件，我们是知道$\frac eN$的，而Wiener告诉我们，计算$\frac eN$的连分数展开可以精准的覆盖$\frac kd$</p><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><ul><li><p>将$\frac eN$连分数展开(举例：$0, 1, \frac 12, \frac 23, …$ )</p></li><li><p>对每一个渐进分数，假设之成立</p><ul><li>则$k = 分子, d = 分母$，代入$ed - 1 = k * \phi(n)$，求得$\phi(n)$</li><li>通过$\phi(n) = (p - 1)(q - 1) = N - (p + q) + 1 ,\quad N = pq $ ， 求得$p+q$与$pq$的值</li><li>利用韦达定理，构造方程$x^2 - (p + q) * x + pq = 0$，求根得到p, q</li><li>验证p * q是否满足</li></ul></li></ul><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><pre class=" language-lang-python"><code class="language-lang-python">def continuedFra(x, y):    cF = []    while y:        cF += [x // y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)def getit(c):    cf = []    for i in range(1, len(c)):        cf.append(Simplify(c[:i]))    return cf# 求渐进分数def wienerAttack(e, n):    cf = continuedFra(e, n)    for (p2, p1) in getit(cf):        if p1 == 0:            continue        if e % p1 == 0 and p1 != 1:            return p1    print('not find!')n1 = 60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121e1 = 60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347d = wienerAttack(n1, e1)print(d)</code></pre><h3 id="Python代码2（多重基数的处理）"><a href="#Python代码2（多重基数的处理）" class="headerlink" title="Python代码2（多重基数的处理）"></a>Python代码2（多重基数的处理）</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2from Crypto.Util.number import *def transform(x, y):       # 使用辗转相处将分数 x/y 转为连分数的形式    res=[]    while y:        res.append(x // y)        x, y = y, x % y    return resdef continued_fraction(sub_res):    numerator,denominator = 1, 0    for i in sub_res[::-1]:      # 从sublist的后面往前循环        denominator, numerator = numerator, i * numerator + denominator    return denominator,numerator   # 得到渐进分数的分母和分子，并返回#求解每个渐进分数def sub_fraction(x, y):    res = transform(x, y)    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  #将连分数的结果逐一截取以求渐进分数    return res# 以上是获得e/n的连分数def get_pq(a, b, c):      # 由p+q和pq的值通过维达定理来求解p和q    par = gmpy2.isqrt(b * b - 4 * a * c)   # 由上述可得，开根号一定是整数，因为有解    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)    return x1, x2def wienerAttack(e, n):    for (d, k) in sub_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数        # if k==0:                     # 可能会出现连分数的第一个为0的情况，排除            # continue        # if (e*d-1)%k!=0:             # ed=1 (\pmod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)            # continue        if 250 <= d.bit_length() <= 256:            print(d)            global c            print(long_to_bytes(pow(c, d, n)))        else:            continue        phi = (e * d - 1) // k               # 这个结果就是 φ(n)        px, qy = get_pq(1, n - phi + 1, n)        if px * qy == n:            p, q = abs(int(px)), abs(int(qy))     # 可能会得到两个负数，负负得正未尝不会出现            d = gmpy2.invert(e, (p - 1) * (q - 1))     # 求ed=1 (\pmod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d            return d    print("该方法不适用")e = ...n = ...c = ...d = wienerAttack(e, n)print("d=", d)</code></pre><h2 id="两个N的模不互素"><a href="#两个N的模不互素" class="headerlink" title="两个N的模不互素"></a>两个N的模不互素</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">\begin{cases}n_1 = p_1 * q \\n_2 = p_2 * q \end{cases}\quad, q为n_1, n_2的公因数</script><p>找出$n_1, n_2$的公因数作为$q$，再对$n_1,n_2$分别除$q$，求得$p_1, p_2$，之后直接求解即可</p><h3 id="Python代码-6"><a href="#Python代码-6" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnume = ...c1 = ...c2 = ...n1 = ...n2 = ...q = gmpy2.gcd(n1, n2)assert (q != 1)p1 = n1 / qp2 = n2 / qd1 = gmpy2.invert(e, (q - 1) * (p1 - 1))d2 = gmpy2.invert(e, (q - 1) * (p2 - 1))m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)print libnum.n2s(m1) + libnum.n2s(m2)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/2021/120655226.html"/>
      <url>/2021/120655226.html</url>
      
        <content type="html"><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><script type="math/tex; mode=display">\phi(n) = \underline{从1到n中和n互素的数}的个数</script><script type="math/tex; mode=display">公式：\phi(n) = n * \prod(1 - \frac{1}{p_i}), \quad p_i是n的所有质因子</script><h3 id="规律："><a href="#规律：" class="headerlink" title="规律："></a>规律：</h3><ul><li><p>$n$为质数：</p><script type="math/tex; mode=display">\phi(n) = n - 1</script></li><li><p>$n = p^k$，$p$为素数：</p><script type="math/tex; mode=display">\phi(n) = p^k (1 - \frac1p)</script></li><li><p>当$m$和$n$互质：</p><script type="math/tex; mode=display">\phi(n * m) = \phi(n) \cdot \phi(m)</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密算法</title>
      <link href="/2021/120662112.html"/>
      <url>/2021/120662112.html</url>
      
        <content type="html"><![CDATA[<h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>公钥</p><script type="math/tex; mode=display">(E, N)</script></li><li><p>私钥</p><script type="math/tex; mode=display">(D, N)</script></li><li><p>密钥对</p><script type="math/tex; mode=display">(E, D, N)</script></li></ul><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><script type="math/tex; mode=display">密文 = 明文^E\mod N</script><h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><script type="math/tex; mode=display">明文 = 密文^D\mod N</script><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><ol><li><p>求<strong>N</strong></p><p>选取两个相对较大的质数<strong>P</strong>,<strong>Q</strong></p><script type="math/tex; mode=display">N = P \cdot Q</script></li><li><p>求<strong>φ(N)</strong>: 需要的中间量</p><script type="math/tex; mode=display">\phi(N) = (P - 1 ) \cdot (Q - 1)</script></li><li><p>求<strong>E</strong></p><p><strong>E</strong>是选取出来的满足特定条件的数，一般取0x10001</p><p><strong>E</strong>需要满足的条件：</p><ul><li>$1 &lt; E &lt; \phi(N)$</li><li>$gcd(E,\phi(N)) = 1$</li></ul></li><li><p>求<strong>D</strong></p><p><strong>D</strong>是通过<strong>E</strong>和<strong>φ(N)</strong>计算得出的数字</p><script type="math/tex; mode=display">(D\cdot E) \mod \phi(N) = 1</script><p><strong>D</strong>需要满足的条件：</p><ul><li>$1 &lt; D &lt; \phi(N)$</li><li>$(D\cdot E) \mod \phi(N) = 1$</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WriteUp-Hackergame 2021</title>
      <link href="/2021/111130106.html"/>
      <url>/2021/111130106.html</url>
      
        <content type="html"><![CDATA[<h1 id="WriteUp-Hackergame-2021"><a href="#WriteUp-Hackergame-2021" class="headerlink" title="WriteUp - Hackergame 2021"></a>WriteUp - Hackergame 2021</h1><p>这里是个初次接触Hackergame的萌新@Hanmur 的WP，虽然最后有不少题有思路，但是懒得写了QwQ</p><p>代码全丢了才知道要写WP，挠头</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><hr><blockquote><p> 为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！</p><p>提示：完成题目遇到困难？你可以参考 <a href="https://github.com/ustclug/hackergame2018-writeups/tree/master/official/qiandao">2018 年签到题题解</a>、<a href="https://github.com/ustclug/hackergame2019-writeups/blob/master/official/签到题/README.md">2019 年签到题题解</a> 和 <a href="https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/签到/README.md">2020 年签到题题解</a>。</p></blockquote><p><img src="https://static01.imgkr.com/temp/57846367ac244fe5801b1f10b0fd07c2.png" alt="image-20211031234211973"></p><p>（好像是第三还是第几道才写的题）</p><p>到页面后翻一页就可以看到上面的参数 <code>Page = 1</code></p><ul><li>可以获取当前时间戳输进去</li><li>可以用二分法多猜几次数字</li><li>可以用连点器加截屏检测爆破（bushi）</li></ul><h2 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h2><blockquote><p>为严防 flag 泄漏以及其他存在于未来所有可能的意外灾难，神通广大的 Z 同学不仅强制要求每一道题目都加上权限和资源的限制，还给所有参与 Hackergame 2021 命题的计算机施加了一层法术结界。任何试图从结界逃逸的 flag 都会被无情抹除。</p><p>而一位明面上是计算机学院的新生，实则为物理学院暗部核心成员的 X 同学，在 Hackergame 2021 命题组已经潜伏多时。妄想趁比赛开始的午时，借阳火正旺之势，冲破 Z 同学的结界，以图片而非明文的形式，将 flag 悄悄传递出来。</p><p>好在 Z 同学法力之深厚，不可管窥蠡测。在 flag 被传出去的前两天，就已预知此事并将图片中的 flag 无声消泯了。</p><p>只是，这位 X 同学，虽然不会退出 Vim，但是似乎对打开十六进制编辑器颇有造诣……</p><p><img src="https://hack.lug.ustc.edu.cn/media/629da242-b1b1-5f69-a623-1c13fcedf019/hex_editor.png" alt="hex_editor"></p></blockquote><p>很简单的一题，在010编辑器按照左边的16进制输入就看得到了，没有010编辑器的可以用代码自己写</p><h2 id="去吧！追寻自由的电波"><a href="#去吧！追寻自由的电波" class="headerlink" title="去吧！追寻自由的电波"></a>去吧！追寻自由的电波</h2><blockquote><p>（前情提要） 为了打破 Z 同学布下的结界，X 同学偷偷搬出社团的业余无线电台试图向外界通讯。</p><p>当然，如果只是这样还远远不够。遵依史称“老爹”的上古先贤的至理名言，必须要“用魔法打败魔法”。X 同学向上级申请到了科大西区同步辐射实验室设备的使用权限，以此打通次元空间，借助到另一个平行宇宙中 Z 同学的法力进行数据对冲，方才于乱中搏得一丝机会，将 flag 用无线电的形式发射了出去。</p><p>考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母。即使如此，打破次元的强大能量扭曲了时空，使得最终接受到的录音的速度有所改变。</p><p>为了保障同步辐射设备的持续运转，组织牺牲了大量的能源，甚至以东北部分地区无计划限电为代价，把这份沉甸甸的录音文件送到了你的手上。而刚刚起床没多久，试图抢签到题一血还失败了的你，可以不辜负同学们对你的殷切期望吗？</p><p>注：flag 花括号内只包含小写字母。</p></blockquote><p>英语听力现在开始）</p><p>在网上可以找到这个译码表</p><p><img src="https://static01.imgkr.com/temp/b28c2a0621c14907b840006a104813c8.png" alt="image-20211031235405633"></p><p>下载文件后可以明显发现音频的速度被加快了，将音频放进AU里调整一下 <code>伸缩与变调</code> 就可以获取到正常的音频了</p><p>我是直接硬听出了结果，不过后面好像知道有软件可以直接转译，真适合我这个有软件就用的懒逼哎</p><h2 id="猫咪问答"><a href="#猫咪问答" class="headerlink" title="猫咪问答"></a>猫咪问答</h2><blockquote><p>我猛然一看，就猛然看到这个猫咪问答，我直呼我直呼，上次看到这么这么的发言还是上次，这问答属于是典型的典型了，我之前还没发现，当我发现的时候我已经发现了，这问答就像一个问答，问答的内容充满了内容，我不禁感慨了一句感慨：希望下次看到这么这么的猫咪问答是下次。</p><p>提示：<strong>解出谜题不需要是科大在校学生</strong>。解题遇到困难？你可以参考 <a href="https://github.com/ustclug/hackergame2018-writeups/blob/master/official/ustcquiz/README.md">2018 年猫咪问答题解</a> 和 <a href="https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/猫咪问答++/README.md">2020 年猫咪问答++ 题解</a>。</p></blockquote><p>都是些通过搜索找得到的答案</p><pre><code>1. 2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？提示：输入格式为 YYYYMMDD，如 20211023。请不要回答 “能” 或者 “不能”。</code></pre><p>搜一下SEC@USTC看得到一个Contest，进去后在附属页面里可以找到</p><p><a href="https://web.archive.org/web/20181004003308/http://sec.ustc.edu.cn/doku.php/codes">https://web.archive.org/web/20181004003308/http://sec.ustc.edu.cn/doku.php/codes</a></p><pre><code>2. 中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？提示：是一个非负整数。</code></pre><p>在Hacakergame的主页进LUG的官网，找一下就看得到了</p><p><a href="https://lug.ustc.edu.cn/wiki/intro/#特色活动">中国科学技术大学 Linux 用户协会 - LUG @ USTC</a></p><p><img src="https://static01.imgkr.com/temp/701669ff295b43ccbd65119056c84e29.png" alt="image-20211101000225489"></p><pre><code>3. 中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？提示：正确答案的长度为 27，注意大小写。</code></pre><p>搜索“西区图书馆 活动室”就可以看到了</p><p><a href="https://lug.ustc.edu.cn/news/2016/06/new-activity-room-in-west-library/">西区图书馆新活动室启用 - LUG @ USTC</a></p><pre><code>4. 在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？提示：是一个非负整数。</code></pre><p>搜索SIGBOVIK 2021 可以找到这个PDF，在里面找到Newcomb-Benford相关内容即可</p><p><a href="http://sigbovik.org/2021/proceedings.pdf">sigbovik.org/2021/proceedings.pdf</a></p><pre><code>5. 不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？提示：正确答案的长度为 9。</code></pre><p>搜索Protocol Police，找到PDF后翻查一下就可以找到</p><p><a href="https://www.rfc-editor.org/rfc/rfc8962.html">RFC 8962: Establishing the Protocol Police (rfc-editor.org)</a></p><p><img src="https://static01.imgkr.com/temp/807061e4222b400e994f0ddab1b58690.png" alt="image-20211101001103902"></p><h2 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h2><blockquote><p>有一个人前来买瓜。</p><p>HQ：哥们，这瓜多少钱一斤啊？</p><p>你：两块钱一斤。</p><p>HQ：What’s up！这瓜皮子是金子做的还是瓜粒子是金子做的？</p><p>你：你瞧瞧现在哪有瓜啊？这都是大棚的瓜，只有 6 斤一个和 9 斤一个的，你嫌贵我还嫌贵呢。</p><p>（HQ 心里默默一算）</p><p>HQ：给我来 20 斤的瓜。</p><p>你：行！</p><p>HQ：行？这瓜能称出 20 斤吗？</p><p>你：我开水果摊的，还不会称重？</p><p>HQ：我问你这瓜能称出 20 斤吗？</p><p>你：你是故意找茬，是不是？你要不要吧！</p><p>HQ：你这瓜要是刚好 20 斤吗我肯定要啊。那它要是没有怎么办啊？</p><p>你：要是不是 20 斤，我自己吃了它，满意了吧？</p><p>（你开始选瓜称重）</p><p><strong>补充说明：当称的数字变为浮点数而不是整数时，HQ 不会认可最终的称重结果。</strong></p></blockquote><p>你找茬是吧？</p><p>测试一下后发现</p><ul><li><p>放入6斤的瓜如果是正数则不会上溢，是负数则正常增加</p></li><li><p>放入9斤的瓜如果正数则会出现上溢，是负数则会越加越负（成浮点）</p></li></ul><p>呢么思路就很清晰了，先放入足够多的9斤瓜，让斤数变负后，计算一下放多少6斤瓜会接近到0，再看看能不能凑到20，不能就重复几次，总可以堆出来（人懒不想算）</p><h2 id="透明的文件"><a href="#透明的文件" class="headerlink" title="透明的文件"></a>透明的文件</h2><blockquote><p>一个透明的文件，用于在终端中展示一个五颜六色的 flag。</p><p>可能是在 cmd.exe 等劣质终端中被长期使用的原因，这个文件失去了一些重要成分，变成了一堆乱码，也不会再显示出 flag 了。</p><p>注意：flag 内部的字符全部为小写字母。</p></blockquote><p>下载文件后得到一堆奇怪的乱码，由题目提示可以发现它是Linux Shell的终端颜色码</p><p>用Python在所有 <code>[</code> 前加上 <code>\e</code> 就可以在一个”优质终端”里运行出需要的图形了（然后这个笨比就在一堆劣质终端试完才跑虚拟机去跑）</p><p>代码被记忆清除了就不放图了</p><h2 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h2><blockquote><p>你的学长决定来一场说走就走的旅行。通过他发给你的照片来看，他应该是在酒店住下了。</p><p><img src="https://hack.lug.ustc.edu.cn/media/175efcf9-3959-5d4c-b9b4-cbc81850da77/travel-photo.jpg" alt="travel-photo"></p><p>从照片来看，酒店似乎在小区的一栋高楼里，附近还有一家 KFC 分店。突然，你意识到照片里透露出来的信息比表面上看起来的要多。</p><p>请观察照片并答对全部 5 道题以获取 flag。注意：图片未在其他地方公开发布过，也未采取任何隐写措施（通过手机拍摄屏幕亦可答题）。</p></blockquote><p>学长有闲又有钱，运气还好，不像我去个长沙回来就得写检讨（怒）</p><p>整张图片最显眼的肯定是那个蓝色KFC，简单找找就可以发现他是 <code>北戴河Tiffany KFC</code></p><p><img src="https://static01.imgkr.com/temp/a44cecd23fb44c89a252ffefbc3cb31f.png" alt="image-20211101002410117"></p><p>在百度地图上找到位置，仔细比对一下发现跟拍摄角度怎么都不符合，但是我们搜一下新澳海底世界（这个位置），瞧瞧我们发现了什么</p><p><img src="http://t1-q.mafengwo.net/s17/M00/C2/27/CoUBXl-dCC6AbiArABnA8ndj7wY568.jpg?imageMogr2%2Fthumbnail%2F%21690x450r%2Fgravity%2FCenter%2Fcrop%2F%21690x450%2Fquality%2F90%7Cwatermark%2F1%2Fimage%2FaHR0cDovL3QxLXEubWFmZW5nd28ubmV0L3MxMS9NMDAvNDQvOUIvd0tnQkVGc1A1UnlBRHY3cEFBQUhaWlVQUmxROTkwLnBuZw%3D%3D%2Fgravity%2FSouthEast%2Fdx%2F10%2Fdy%2F11" alt="img"></p><p>很明显了，这个KFC从地图上位置搬到了海豚馆的旁边，这下就符合了，之后在地图上找找对应信息就可以了</p><h2 id="FLAG助力大礼包"><a href="#FLAG助力大礼包" class="headerlink" title="FLAG助力大礼包"></a>FLAG助力大礼包</h2><blockquote><p>“听说没？【大砍刀】平台又双叒做活动啦！参与活动就送 0.5 个 flag 呢，攒满 1 个 flag 即可免费提取！”</p><p>“还有这么好的事情？我也要参加！”</p><p>“快点吧！我已经拿到 flag 了呢！再不参加 flag 就要发完了呢。”</p><p>“那怎么才能参加呢？”</p><p>“这还不简单！点击下面的链接就行”</p><p><strong>公告：本题在小概率情况下会产生操作时间限制无法重置的现象，表现为一直显示“操作速度太快了，请稍后再试！”，现已修复，请大家重新点击按钮后稍等几秒钟即可恢复。</strong></p></blockquote><p>这题很简单，找256个地方的人帮你助力一下就可以了，相信作为新时代大学生，广结良朋的你应该很容易就可以完成这个任务，我们看下一题(bushi)</p><p>很明显的一个IP伪造，Burp拦截一下Post的数据，在其中增加</p><pre><code>X-Forward-For: 1.1.1.1</code></pre><p>并把 <code>IP =</code> 后面的数值也更改成 <code>1.1.1.1</code> ，我们发现我们成功给自己助力了一刀，呢么我们多改几次数据，比如<code>2.2.2.2</code>，256次之后就可以做完啦！</p><p>好吧我们有更容易的方法，使用Burp的Intruder，从0到256爆破一遍，时间间隔设置成2s就刚好稳稳地可以在十分钟内完成256次助力。</p><h2 id="Amnesia"><a href="#Amnesia" class="headerlink" title="Amnesia"></a>Amnesia</h2><blockquote><p>你的程序只需要输出字符串 <code>Hello, world!</code>（结尾有无换行均可）并正常结束。</p><p>编译指令：<code>gcc -O file.c -m32</code></p><p>运行指令：<code>./a.out</code></p><p>编译器版本：Docker 镜像 <code>ustclug/debian:10</code> 中 <code>apt update &amp;&amp; apt -y upgrade &amp;&amp; apt install -y gcc=4:8.3.0-1 gcc-multilib=4:8.3.0-1</code> 的版本</p><p><strong>轻度失忆</strong></p><p>编译后 ELF 文件的 <code>.data</code> 和 <code>.rodata</code> 段会被清零。</p><p>连接题目：<code>nc 202.38.93.111 10051</code> 或<a href="http://202.38.93.111:10050/?token=1058%3AMEUCIQD7V9cVhsm8ZASKWsQmtEj7enU12QPOBk3xC%2FOCNcXrzQIgBI4aFDOhwvvz9XL9rqRw6Ed2j8DAX%2FmUQ4GGTHYK%2FRU%3D">网页终端</a></p><p>判题脚本：<a href="https://hack.lug.ustc.edu.cn/media/c4d3e46b-81aa-511d-a16c-e30cc5fda260/amnesia_1_checker.zip">下载</a></p><p><strong>记忆清除</strong></p><p>编译后 ELF 文件的 <code>.text</code> 段会被清零。</p><p>连接题目：<code>nc 202.38.93.111 10061</code> 或<a href="http://202.38.93.111:10060/?token=1058%3AMEUCIQD7V9cVhsm8ZASKWsQmtEj7enU12QPOBk3xC%2FOCNcXrzQIgBI4aFDOhwvvz9XL9rqRw6Ed2j8DAX%2FmUQ4GGTHYK%2FRU%3D">网页终端</a></p><p>判题脚本：<a href="https://hack.lug.ustc.edu.cn/media/c4d3e46b-81aa-511d-a16c-e30cc5fda260/amnesia_2_checker.zip">下载</a></p></blockquote><p>轻度失忆，虽然代码没了，但是这题我真的忍不住要给大家展示一下我的生草代码，以下代码是用Python生成，请问我这样可以成为88W行代码的大佬吗。</p><pre><code>#include &lt;stdio.h&gt;int main(){    char temp;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);    temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);    temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);    //dot    temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);    temp = 0;    temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        temp = 0;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;temp++;    printf("%c", temp);        return 0;}</code></pre><h2 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h2><blockquote><p>自从 <a href="https://github.com/ustclug/hackergame2018-writeups/tree/master/official/RSA_of_Z#解法-1">Hackergame 2018 公然揭露了大整数可以被神童口算分解的事实</a>，RSA 在 hackergame 中已经只能处于低分值的地位了。如果不在其名称前面加上 Easy 这个单词，似乎就会显得完全对不起其他题目。</p><p>更何况，在本题的附件中，你还获得了构造 p 和 q 的方式。数理基础扎实的你应该可以轻松解决这些问题吧。</p></blockquote><p>作为某靶场清空RSA题的男人，我觉得这题应该不会有什么问题，直接开场冲去抢一血，然后一切顺利，死活不过，眼看着前面一个个人写出来了。最终发现自己扔进RSA解码的p是原来的p之后狠狠地emo了，只在中大的内场拿了这题的一血。</p><p>代码没了，不过作为一血题还是重新写了一遍</p><p>这题其实就是常规的RSA解码，在P和Q上加了两个算法题而已</p><p><strong>P的算法</strong></p><p>原题给出的P提示</p><pre><code>def get_p():    x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451    y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439    value_p = sympy.nextprime((math.factorial(y)) % x)  # Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征    return value_p</code></pre><p>这里其实就是计算y的阶乘取模x的结果，我们可以写个函数</p><pre><code>def getPrime(A, B):    k = 1    for i in range(B+1, A):        k = (k*i) % A    res = (-gmpy2.invert(k, A)) % A    return sympy.nextprime(res)</code></pre><p>在 <code>get_p</code> 中调用 <code>getPrime(x, y)</code> 就可以得到P的值了</p><pre><code>p =  10569944080090591401315432556965818857327680380269154543273468441025963038065648915158194147019839932524599260058098616377893091051396090650574162446875263</code></pre><p><strong>Q的算法</strong></p><p>原题给出的Q提示</p><pre><code>def get_q():    value = [getPrime(256)]    for i in range(1, 10):        value.append(sympy.nextprime(value[i - 1]))    print("value[-1] = ", value[-1])    # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967    n = 1    for i in range(10):        n = n * value[i]    q = getPrime(512)    value_q = pow(q, e, n)    print("value_q = ", value_q)    # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819    return sympy.nextprime(q)</code></pre><p>细读一下代码，value先获取随机的一个质数，之后获取该指数后面9个质数</p><p>而我们知道了value的最后一个质数是<code>80096058210213458444437404275177554701604739094679033012396452382975889905967</code></p><p>呢么通过</p><pre><code>    value = 80096058210213458444437404275177554701604739094679033012396452382975889905967    for i in range(1, 10):        value = sympy.prevprime(value)        print("value = ", value)</code></pre><p>把value的第一个质数找出来，之后把原题代码中<code>value = [getPrime(256)]</code>的方括号内替换成这个质数，就可以获取到value的正确序列了:</p><pre><code>    value = [80096058210213458444437404275177554701604739094679033012396452382975889905121]    for i in range(1, 10):        value.append(sympy.nextprime(value[i - 1]))    print("value[-1] = ", value[-1])</code></pre><p>继续读代码，n是value每个元素的乘积，知道value_q的值，也知道了 <code>value_q = pow(q, e, n)</code> </p><p>很自然的我们由RSA的算法可以想到，<code>q = pow(value_q, d, n )</code>，其中d的值为<code>gmpy2.invert(e, phi_n)</code></p><p><code>phi(n)</code>当然不能用n简单取模，不过由于</p><ul><li><p>欧拉函数中<code>phi(n*m) = phi(n) * phi(m)</code>，</p></li><li><p>且对于质数k，有<code>phi(k) = k - 1</code></p></li></ul><p>我们就可以求出phi(n)的值，进而求出d的值</p><p>于是直接带入运算即可得到q。</p><pre><code>value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819    phi_n = 1    for i in range(10):        phi_n *= value[i] - 1    d = gmpy2.invert(e, phi_n)    q = pow(value_q, d, n)    print("q = ", q)</code></pre><p><strong>RSA解码</strong></p><p>所有需要的数据都获得了，直接扔进通用的RSA解码代码里，得到FLAG</p><pre><code>import gmpy2import binasciip = gmpy2.mpz(10569944080090591401315432556965818857327680380269154543273468441025963038065648915158194147019839932524599260058098616377893091051396090650574162446875263)q = gmpy2.mpz(10477925992460766451892208516181598312750484426056814542870756188277177949099084361476539803367804757559880919838828678145609717295215924948786830953571811)n = p * qe = gmpy2.mpz(65537)phi_n = (p-1)*(q-1)d = gmpy2.invert(e, phi_n)c = gmpy2.mpz(110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478)m = pow(c, d, n)print("十进制:\n%s" % m)m_hex = hex(m)[2:]print("十六进制:\n%s" % (m_hex,))# print("ascII:\n%s" % ((binascii.b2a_hex(hex(m)[2:])).decode('hex'),))print("ascii:\n%s" % (binascii.a2b_hex(m_hex).decode("utf8"),))</code></pre><p><img src="https://static01.imgkr.com/temp/44146d076d7b401d9a23920b11944d0a.png" alt="image-20211101012259731"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> WriteUp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WriteUp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
