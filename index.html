<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Go语言学习/字符串操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.385Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>go语言中字符串的实现使用<code>UTF-8</code>编码</p>
<p>字符串的值为<code>双引号（&quot;&quot;）</code>中的内容</p>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>go语言中定义一个多行字符串时，必须使用<code>反引号</code>字符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>反引号间换行被视作字符串中的换行</p>
<p>但是所有的转义字符无效，字符会原样输出</p>
<h1 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h1><table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
</tbody></table>
<p>反斜杠也可以打印出<code>&#39;</code> <code>&quot;</code> <code>\</code> 等特殊字符</p>
<h1 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h1><table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>len(str)</td>
<td>求长度</td>
</tr>
<tr>
<td>+或fmt.Sprintf</td>
<td>拼接字符串</td>
</tr>
<tr>
<td>strings.Split</td>
<td>分割</td>
</tr>
<tr>
<td>strings.contains</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>strings.HasPrefix, strings.HasSuffix</td>
<td>前缀/后缀判断</td>
</tr>
<tr>
<td>strings.Index(), strings.LastIndex()</td>
<td>子串出现的位置</td>
</tr>
<tr>
<td>strings.Join(a[]string, sep string)</td>
<td>join操作</td>
</tr>
</tbody></table>
<h1 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h1><p>字符串本身是无法被修改的，需要先将其转换成<code>[]rune</code>或<code>[]byte</code></p>
<p>完成后再转换为<code>string</code></p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;big&quot;</span></span><br><span class="line">byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">byteS1[<span class="number">0</span>] = <span class="string">&#x27;P&#x27;</span></span><br><span class="line">str := <span class="keyword">string</span>(byteS1)	<span class="comment">//str = &quot;Pig&quot;</span></span><br><span class="line"></span><br><span class="line">S2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">runeS2 := []<span class="keyword">rune</span>(s2)</span><br><span class="line">runeS2[<span class="number">0</span>] = <span class="string">&quot;晚&quot;</span></span><br><span class="line">str = <span class="keyword">string</span>(runeS2)	<span class="comment">//str = &quot;晚好&quot;</span></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" data-id="ckrwd22eg000vqcub32ph6szv" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.383Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go语言的指针相较于C语言中的指针，它不能偏移和运算。</p>
<p>指针的三个性质</p>
<ul>
<li>指针地址</li>
<li>指针类型</li>
<li>指针取值</li>
</ul>
<p>指针的两个操作符</p>
<ul>
<li>&amp;：取地址符</li>
<li>*：取值符</li>
</ul>
<h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>变量在运行时有一个地址，代表变量在内存的位置</p>
<p>所有值类型都有对应的指针类型，如<code>*int</code></p>
<h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><p>new的函数签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li>
<li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针</li>
</ul>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := <span class="built_in">new</span>(<span class="keyword">int</span>)	<span class="comment">//声明并申请一个int的空间</span></span><br><span class="line">	</span><br><span class="line">	*a = <span class="number">10</span>			<span class="comment">//赋值</span></span><br><span class="line">	</span><br><span class="line">	fmt.Println(*a)	<span class="comment">//打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="make"><a href="#make" class="headerlink" title="make"></a>make</h5><p>make也是内存分配的函数，区别于new，它只用于<code>slice</code>，<code>map</code>，<code>chan</code>的内存创建，且返回的类型是它们本身而不是指针类型。</p>
<p>make的函数签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>我们在使用<code>slice</code>、<code>map</code>、<code>channel</code>时，都需要使用make进行初始化</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">scoreMap[<span class="string">&quot;武子&quot;</span>] = <span class="number">90</span></span><br><span class="line">scoreMap[<span class="string">&quot;康康&quot;</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">fmt.<span class="built_in">println</span>(scoreMap)			<span class="comment">//输出：map[康康:100 武子:90]</span></span><br><span class="line">fmt.<span class="built_in">println</span>(scoreMap[<span class="string">&quot;武子&quot;</span>])	   <span class="comment">//输出：100</span></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%8C%87%E9%92%88/" data-id="ckrwd22ec000tqcub6dgq40og" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/运算符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.381Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>相加</td>
</tr>
<tr>
<td>-</td>
<td>相减</td>
</tr>
<tr>
<td>*</td>
<td>相乘</td>
</tr>
<tr>
<td>/</td>
<td>相除</td>
</tr>
<tr>
<td>%</td>
<td>求余</td>
</tr>
</tbody></table>
<p>注意： <code>++</code> 和 <code>--</code>是单独的语句，不是运算符</p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>是否相等</td>
</tr>
<tr>
<td>!=</td>
<td>是否不等</td>
</tr>
<tr>
<td>&gt;</td>
<td>是否大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>是否小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>是否大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>是否小于等于</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与逻辑运算</td>
</tr>
<tr>
<td>||</td>
<td>或逻辑运算</td>
</tr>
<tr>
<td>!</td>
<td>非逻辑运算</td>
</tr>
</tbody></table>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移n位</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移n位</td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>+=</td>
<td>相加后赋值</td>
</tr>
<tr>
<td>-=</td>
<td>相减后赋值</td>
</tr>
<tr>
<td>*=</td>
<td>相乘后赋值</td>
</tr>
<tr>
<td>/=</td>
<td>相除后赋值</td>
</tr>
<tr>
<td>%=</td>
<td>取模后赋值</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td>|=</td>
<td>按位或后赋值</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或后赋值</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="ckrwd22ej000xqcub3b0c24tx" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.379Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是同一种类型的数据集合</p>
<p>在Go语言中数组声明时确定长度和存放元素的类型</p>
<p>且数组是值类型的传递</p>
<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure>

<p>比如：<code>var a [5]int</code> 创建了一个名为a的长度为5的[5]int类型数组</p>
<p>数组的长度必须是常量，并且不能改变</p>
<p>数组可以通过下标访问，下标从<code>0</code>开始，最后一个元素是<code>len - 1</code></p>
<p>数组访问越界会panic</p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><ol>
<li>使用初始化列表设置数组元素的值</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;	<span class="comment">//[1 2 0]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以让编译器自行判定数组长度</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;	<span class="comment">//[1 2]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可以根据索引初始化数组</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [...]<span class="keyword">int</span>[<span class="number">1</span>:<span class="number">1</span>, <span class="number">3</span>:<span class="number">5</span>]	<span class="comment">//[0 1 0 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><ol>
<li><p>for循环遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Nihao&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++&#123;</span><br><span class="line">	fmt.<span class="built_in">println</span>(a[i])	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>for range遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [...]<span class="keyword">string</span>&#123;<span class="string">&quot;Hi&quot;</span>, <span class="string">&quot;Nihao&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a&#123;</span><br><span class="line">	fmt.<span class="built_in">println</span>(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>Go语言支持多维数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%95%B0%E7%BB%84/" data-id="ckrwd22eb000sqcubcjqk2wc3" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/切片" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%88%87%E7%89%87/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.377Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p><code>slice</code>切片是一个拥有相同类型元素的可变长度的序列</p>
<p>它是基于数组类型的一层封装</p>
<p>它非常的灵活，支持自动扩容</p>
<p>切片是一个引用类型</p>
<p>它内部包括<code>地址</code> <code>长度</code> <code>容量</code></p>
<p>切片一般用来快速地操作一块数据集合</p>
<h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>声明切片类型的语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []T</span><br></pre></td></tr></table></figure>

<p>其中<code>name</code>指变量名，<code>T</code>指切片中的元素类型</p>
<p>举例：定义一个存放<code>int</code>类型的切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isMe []<span class="keyword">bool</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量</p>
<p>可以通过<code>len()</code>函数求长度，<code>cap()</code>函数求容量</p>
<p>切片的容量是指底层数组的容量</p>
<p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20210721234733324.png" alt="image-20210721234733324"></p>
<h3 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">s1 := a1[<span class="number">0</span>:<span class="number">4</span>]	<span class="comment">//基于a1切割，左闭右开（左右都支持缺省）</span></span><br></pre></td></tr></table></figure>

<p>切片也可以从切片中再切片，方式和数组类似</p>
<h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>如果要动态地创建一个切片，我们需要使用<code>make()</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, size, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li><code>T</code>是切片的元素类型</li>
<li><code>size</code>是切片中元素的数量</li>
<li><code>cap</code>是切片的容量</li>
</ul>
<h3 id="切片之间不能相互比较"><a href="#切片之间不能相互比较" class="headerlink" title="切片之间不能相互比较"></a>切片之间不能相互比较</h3><p>不能用<code>==</code>操作符来判断两个切片是否含有全部相等元素</p>
<p>切片唯一合法的比较操作是和<code>nil</code>比较</p>
<p>一个<code>nil</code>的切片并没有底层数组</p>
<p><code>nil</code>值的切片的长度和容量都是0</p>
<p>但是并不是一个长度和容量都是0的切片是<code>nil</code></p>
<p>要判断一个切片是否为空，要用<code>len(s) == 0</code>来判断</p>
<h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><p>切片是引用！</p>
<p>切片是引用！</p>
<p>切片是引用！</p>
<h3 id="append-方法为切片增加元素"><a href="#append-方法为切片增加元素" class="headerlink" title="append()方法为切片增加元素"></a>append()方法为切片增加元素</h3><h5 id="append-可以为切片动态添加元素。"><a href="#append-可以为切片动态添加元素。" class="headerlink" title="append()可以为切片动态添加元素。"></a><code>append()</code>可以为切片动态添加元素。</h5><p>可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)        <span class="comment">// [1]</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// [1 2 3 4]</span></span><br><span class="line">	s2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;  </span><br><span class="line">	s = <span class="built_in">append</span>(s, s2...)    <span class="comment">// [1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>通过<code>var</code>声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="append方法使得切片扩容"><a href="#append方法使得切片扩容" class="headerlink" title="append方法使得切片扩容"></a><code>append</code>方法使得切片扩容</h5><p>当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。</p>
<p>“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//append()添加元素和切片扩容</span></span><br><span class="line">	<span class="keyword">var</span> numSlice []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		numSlice = <span class="built_in">append</span>(numSlice, i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;</span>, numSlice, <span class="built_in">len</span>(numSlice), <span class="built_in">cap</span>(numSlice), numSlice)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  <span class="built_in">cap</span>:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  <span class="built_in">cap</span>:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  <span class="built_in">cap</span>:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  <span class="built_in">cap</span>:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  <span class="built_in">cap</span>:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出：</p>
<ol>
<li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li>
<li>每次扩容后都是扩容前的2倍。</li>
</ol>
<h3 id="copy-函数复制切片"><a href="#copy-函数复制切片" class="headerlink" title="copy()函数复制切片"></a><code>copy()</code>函数复制切片</h3><p>由于切片是引用类型，所以直接将切片赋值给其他切片传递的是引用</p>
<p>而<code>copy()</code>函数将一个切片空间的数据复制到另外一个切片空间中</p>
<p><code>copy()</code>函数的使用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>srcSlice</code>: 数据来源切片</li>
<li><code>destSlice</code>: 目标切片</li>
<li><code>T</code>:类型</li>
</ul>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// copy()复制切片</span></span><br><span class="line">	destSlice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	srcSlice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="built_in">copy</span>(destSlice, srcSlice)     <span class="comment">//使用copy()函数</span></span><br><span class="line">	fmt.Println(destSlice) 	<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	fmt.Println(srcSlice) 	<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	srcSlice[<span class="number">0</span>] = <span class="number">1000</span>		<span class="comment">//改变srcSlice中的值</span></span><br><span class="line">	fmt.Println(destSlice)	<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">	fmt.Println(srcSlice) 	<span class="comment">//[1000 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言中没有删除切片元素的方法</p>
<p>我们可以用切片的特性删除元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">n = <span class="built_in">append</span>(n[:<span class="number">2</span>], n[<span class="number">3</span>:]...)		<span class="comment">//将除2号索引之外的元素加入n中</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%88%87%E7%89%87/" data-id="ckrwd22e8000qqcub045q4v1n" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/内存对齐" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.375Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="在-Go-中恰到好处的内存对齐"><a href="#在-Go-中恰到好处的内存对齐" class="headerlink" title="在 Go 中恰到好处的内存对齐"></a>在 Go 中恰到好处的内存对齐</h1><p>作者：<a target="_blank" rel="noopener" href="https://segmentfault.com/u/eddycjy"><strong>煎鱼</strong></a></p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?url=https://book.eddycjy.com/golang/talk/go-memory-align.html">在 Go 中恰到好处的内存对齐</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Part1 struct &#123;</span><br><span class="line">    a bool</span><br><span class="line">    b int32</span><br><span class="line">    c int8</span><br><span class="line">    d int64</span><br><span class="line">    e byte</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    fmt.Printf(&quot;bool size: %d\n&quot;, unsafe.Sizeof(bool(true)))</span><br><span class="line">    fmt.Printf(&quot;int32 size: %d\n&quot;, unsafe.Sizeof(int32(0)))</span><br><span class="line">    fmt.Printf(&quot;int8 size: %d\n&quot;, unsafe.Sizeof(int8(0)))</span><br><span class="line">    fmt.Printf(&quot;int64 size: %d\n&quot;, unsafe.Sizeof(int64(0)))</span><br><span class="line">    fmt.Printf(&quot;byte size: %d\n&quot;, unsafe.Sizeof(byte(0)))</span><br><span class="line">    fmt.Printf(&quot;string size: %d\n&quot;, unsafe.Sizeof(&quot;EDDYCJY&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool size: 1</span><br><span class="line">int32 size: 4</span><br><span class="line">int8 size: 1</span><br><span class="line">int64 size: 8</span><br><span class="line">byte size: 1</span><br><span class="line">string size: 16</span><br></pre></td></tr></table></figure>

<p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>
<p>真实情况是怎么样的呢？我们实际调用看看，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Part1 struct &#123;</span><br><span class="line">    a bool</span><br><span class="line">    b int32</span><br><span class="line">    c int8</span><br><span class="line">    d int64</span><br><span class="line">    e byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    part1 := Part1&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part1 size: 32, align: 8</span><br></pre></td></tr></table></figure>

<p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p>
<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p>
<p><img src="https://segmentfault.com/img/remote/1460000017527315?w=319&h=149" alt="image"></p>
<p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p>
<p><img src="https://segmentfault.com/img/remote/1460000017527316?w=424&h=149" alt="image"></p>
<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>
<h3 id="为什么要关心对齐"><a href="#为什么要关心对齐" class="headerlink" title="为什么要关心对齐"></a>为什么要关心对齐</h3><ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>
<li>你正在处理向量方面的指令</li>
<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>
</ul>
<p>另外作为一个工程师，你也很有必要学习这块知识点哦 :)</p>
<h3 id="为什么要做对齐"><a href="#为什么要做对齐" class="headerlink" title="为什么要做对齐"></a>为什么要做对齐</h3><ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li>
<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>
</ul>
<p><img src="https://segmentfault.com/img/remote/1460000017527317?w=574&h=424" alt="image"></p>
<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p>
<ol>
<li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>
<li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>
<li>合并 1-4 字节的数据</li>
<li>合并后放入寄存器</li>
</ol>
<p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p>
<p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法</p>
<h3 id="默认系数"><a href="#默认系数" class="headerlink" title="默认系数"></a>默认系数</h3><p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p>
<ul>
<li>32 位：4</li>
<li>64 位：8</li>
</ul>
<p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>
<h3 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    fmt.Printf(&quot;bool align: %d\n&quot;, unsafe.Alignof(bool(true)))</span><br><span class="line">    fmt.Printf(&quot;int32 align: %d\n&quot;, unsafe.Alignof(int32(0)))</span><br><span class="line">    fmt.Printf(&quot;int8 align: %d\n&quot;, unsafe.Alignof(int8(0)))</span><br><span class="line">    fmt.Printf(&quot;int64 align: %d\n&quot;, unsafe.Alignof(int64(0)))</span><br><span class="line">    fmt.Printf(&quot;byte align: %d\n&quot;, unsafe.Alignof(byte(0)))</span><br><span class="line">    fmt.Printf(&quot;string align: %d\n&quot;, unsafe.Alignof(&quot;EDDYCJY&quot;))</span><br><span class="line">    fmt.Printf(&quot;map align: %d\n&quot;, unsafe.Alignof(map[string]string&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool align: 1</span><br><span class="line">int32 align: 4</span><br><span class="line">int8 align: 1</span><br><span class="line">int64 align: 8</span><br><span class="line">byte align: 1</span><br><span class="line">string align: 8</span><br><span class="line">map align: 8</span><br></pre></td></tr></table></figure>

<p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p>
<h3 id="整体对齐"><a href="#整体对齐" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>
<h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li>
<li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
<h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>接下来我们一起分析一下，“它” 到底经历了些什么，影响了 “预期” 结果</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>bool</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>e</td>
<td>byte</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>25</td>
<td>7</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>32</td>
</tr>
</tbody></table>
<h3 id="成员对齐-1"><a href="#成员对齐-1" class="headerlink" title="成员对齐"></a>成员对齐</h3><ul>
<li>第一个成员 a<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 b<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>
</ul>
</li>
<li>第三个成员 c<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li>
</ul>
</li>
<li>第四个成员 d<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>
</ul>
</li>
<li>第五个成员 e<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li>
</ul>
</li>
</ul>
<h3 id="整体对齐-1"><a href="#整体对齐-1" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p>
<p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过本节的分析，可得知先前的 “推算” 为什么错误？</p>
<p>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p>
<h2 id="巧妙的结构体"><a href="#巧妙的结构体" class="headerlink" title="巧妙的结构体"></a>巧妙的结构体</h2><p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 :-)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type Part1 struct &#123;</span><br><span class="line">    a bool</span><br><span class="line">    b int32</span><br><span class="line">    c int8</span><br><span class="line">    d int64</span><br><span class="line">    e byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Part2 struct &#123;</span><br><span class="line">    e byte</span><br><span class="line">    c int8</span><br><span class="line">    a bool</span><br><span class="line">    b int32</span><br><span class="line">    d int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    part1 := Part1&#123;&#125;</span><br><span class="line">    part2 := Part2&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;part1 size: %d, align: %d\n&quot;, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class="line">    fmt.Printf(&quot;part2 size: %d, align: %d\n&quot;, unsafe.Sizeof(part2), unsafe.Alignof(part2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">part1 size: 32, align: 8part2 size: 16, align: 8</span><br></pre></td></tr></table></figure>

<p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p>
<p>接下来我们一起剖析一下 <code>Part2</code>，看看它的内部到底和上一位之间有什么区别，才导致了这样的结果？</p>
<h3 id="分析流程-1"><a href="#分析流程-1" class="headerlink" title="分析流程"></a>分析流程</h3><table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody><tr>
<td>e</td>
<td>byte</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>bool</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>16</td>
</tr>
</tbody></table>
<h4 id="成员对齐-2"><a href="#成员对齐-2" class="headerlink" title="成员对齐"></a>成员对齐</h4><ul>
<li>第一个成员 e<ul>
<li>类型为 byte</li>
<li>大小/对齐值为 1 字节</li>
<li>初始地址，偏移量为 0。占用了第 1 位</li>
</ul>
</li>
<li>第二个成员 c<ul>
<li>类型为 int8</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li>
</ul>
</li>
<li>第三个成员 a<ul>
<li>类型为 bool</li>
<li>大小/对齐值为 1 字节</li>
<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li>
</ul>
</li>
<li>第四个成员 b<ul>
<li>类型为 int32</li>
<li>大小/对齐值为 4 字节</li>
<li>根据规则1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li>
</ul>
</li>
<li>第五个成员 d<ul>
<li>类型为 int64</li>
<li>大小/对齐值为 8 字节</li>
<li>根据规则1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li>
</ul>
</li>
</ul>
<h4 id="整体对齐-2"><a href="#整体对齐-2" class="headerlink" title="整体对齐"></a>整体对齐</h4><p>符合规则 2，不需要额外对齐</p>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>Part2 内存布局：ecax|bbbb|dddd|dddd</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p>
<ul>
<li>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</li>
<li>Part2：ecax|bbbb|dddd|dddd</li>
</ul>
<p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p>
<p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p>
<p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p>
<p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" data-id="ckrwd22e6000oqcub2znvf4nu" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/流程控制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.373Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p>Go语言中<code>if</code>条件判断的格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>&#123;</span><br><span class="line">	分支<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span>&#123;</span><br><span class="line">	分支<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h1><p>Go语言中<code>for</code>循环的格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">	循环语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：打印1 - 100</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++&#123;</span><br><span class="line">    fmt.<span class="built_in">println</span>(i)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>也可以同时省略初始语句与结束语句，类似<code>while</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 条件表达式&#123;</span><br><span class="line">	循环语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h1><p>go语言中可以使用<code>for range</code>遍历数组，切片，字符串，map及通道</p>
<p>通过<code>for range</code>遍历的返回值有以下规律：</p>
<ol>
<li>数组，切片，字符串返回索引值</li>
<li>map返回键和值</li>
<li>通道只返回通道内的值</li>
</ol>
<h1 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h1><p>使用<code>switch</code>语句可方便地对大量数据进行条件判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n1 := <span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span>(n1)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	语句<span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	语句<span class="number">2</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	语句<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在go中一个分支可以有多个值</p>
<p>如：<code>case 1, 2, 3:</code></p>
</blockquote>
<blockquote>
<p>分支也可以使用表达式</p>
<p>如：<code>case age &lt; 25:</code></p>
</blockquote>
<blockquote>
<p><code>fallthrough</code>语法可以执行满足case的下一个case</p>
<p>是为了兼容C中的case而设计的</p>
</blockquote>
<h1 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h1><p><code>break</code>语句常用于中断当前for循环或跳出switch语句</p>
<p><code>continue</code>语句跳过当前循环的剩余语句，继续进行下一循环</p>
<p><code>goto</code>语句 将控制转移到被标记的语句</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" data-id="ckrwd22ei000wqcub8xk1faoj" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/结构体" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E4%BD%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.371Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有类，但是有结构体</p>
<p>通过结构体的<code>内嵌</code>配合<code>接口</code>实现“没有对象的面向对象编程”</p>
<h3 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h3><h5 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h5><p>Go语言中使用<code>type</code>关键字定义自定义类型</p>
<p>自定义类型的格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewType Type</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>这里<code>MyInt</code>是一个新的类型</p>
<h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名是<code>Go1.9</code>添加的功能</p>
<p>类型别名指：<code>TypeAlias</code>是<code>Type</code>的别名，他们本质上是同一个类型</p>
<p>类型别名的格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>

<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><h5 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h5><p>使用<code>Type</code>和<code>struct</code>定义结构体，格式为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">	字段名 字段类型</span><br><span class="line">	字段名 字段类型</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>类型名：表示结构体名称</li>
<li>字段名：结构体中元素名称</li>
<li>字段类型：结构体中元素类型</li>
</ul>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">	name, city	<span class="keyword">string</span></span><br><span class="line">	age			<span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结构体成员访问"><a href="#结构体成员访问" class="headerlink" title="结构体成员访问"></a>结构体成员访问</h5><p>通过<code>.</code>访问结构体的字段（成员变量）</p>
<h3 id="结构体的实例化"><a href="#结构体的实例化" class="headerlink" title="结构体的实例化"></a>结构体的实例化</h3><h5 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h5><p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> man person</span><br><span class="line">	man.name = <span class="string">&quot;康康&quot;</span></span><br><span class="line">	man.city = <span class="string">&quot;广州&quot;</span></span><br><span class="line">	man.age = <span class="number">17</span></span><br><span class="line">	</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, man)  </span><br><span class="line">    <span class="comment">//&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">	</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, man) </span><br><span class="line">    <span class="comment">//main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名实例化"><a href="#匿名实例化" class="headerlink" title="匿名实例化"></a>匿名实例化</h5><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;name <span class="keyword">string</span>; age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.name = <span class="string">&quot;康康&quot;</span></span><br><span class="line">    user.age = <span class="number">17</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">    <span class="comment">//main.person&#123;name:&quot;康康&quot;, age:17&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指针类型结构体"><a href="#指针类型结构体" class="headerlink" title="指针类型结构体"></a>指针类型结构体</h5><p>使用<code>new</code>得到结构体的地址:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = <span class="built_in">new</span>(person)</span><br><span class="line"><span class="comment">// man的类型为 *main.person</span></span><br></pre></td></tr></table></figure>

<p>Go语言里支持结构体指针直接使用<code>.</code>访问结构体的成员</p>
<p>即代码中<code>man.name = &quot;康康&quot;</code>在底层是<code>(*man).name</code> = “康康”</p>
<p>这是Go语言自动翻译的。</p>
<h3 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h3><p>没有初始化的结构体，成员变量都是对应的零值</p>
<h5 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h5><p>使用键值对初始化时，键对应字段，值对应初始值</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">man := person&#123;</span><br><span class="line">	name: <span class="string">&quot;康康&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;广州&quot;</span>,</span><br><span class="line">	age:  <span class="number">17</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, man) </span><br><span class="line"><span class="comment">//main.person&#123;name:&quot;康康&quot;, city:&quot;广州&quot;, age:17&#125;</span></span><br></pre></td></tr></table></figure>

<p>类似的，结构体指针也可以键值对初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">man := &amp;person&#123;</span><br><span class="line">	name: <span class="string">&quot;康康&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;广州&quot;</span>,</span><br><span class="line">	age:  <span class="number">17</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, man) </span><br><span class="line"><span class="comment">//&amp;main.person&#123;name:&quot;康康&quot;, city:&quot;广州&quot;, age:17&#125;</span></span><br></pre></td></tr></table></figure>

<p>某些字段没有初始值时可以不写，没有指定初始值的字段值为零值</p>
<h5 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h5><p>初始化结构体时可以只写值</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">man := &amp;person&#123;</span><br><span class="line">	<span class="string">&quot;康康&quot;</span>,</span><br><span class="line">	<span class="string">&quot;广州&quot;</span>,</span><br><span class="line">	<span class="number">17</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, man)</span><br><span class="line"><span class="comment">//&amp;main.person&#123;name:&quot;康康&quot;, city:&quot;广州&quot;, age:17&#125;</span></span><br></pre></td></tr></table></figure>

<p>用值的列表进行初始化时，结构体的所有字段都需要初始化</p>
<p>初始值的填充顺序需要和结构体的声明顺序一致。</p>
<h3 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h3><p>结构体占用一块连续的内存。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int8</span></span><br><span class="line">	b <span class="keyword">int8</span></span><br><span class="line">	c <span class="keyword">int8</span></span><br><span class="line">	d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">在 Go 中恰到好处的内存对齐</a></p>
<h5 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h5><p>空结构体是不占用空间的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Go语言中结构体没有构造函数，但是可以自己实现</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		city: city,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    man := newPerson(<span class="string">&quot;康康&quot;</span>，<span class="string">&quot;广州&quot;</span>， <span class="number">17</span>)</span><br><span class="line">    fmt.<span class="built_in">println</span>(man)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h3><p>Go语言中的<code>方法(Method)</code>是一种作用于特定类型变量的函数，这种特定类型变量叫做<code>接收者(Receiver)</code>。接收者类似c中<code>this</code></p>
<p>方法的定义格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span><span class="params">(返回参数)</span></span>&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>接收者变量：接收者变量官方建议命名是首字母的小写，如<code>Person</code>对应<code>p</code>，<code>Counter</code>对应<code>c</code></li>
</ul>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的梦想是学好数值计算与分析！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;康康&quot;</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>非本地类型不能定义方法，也就是说不能给别的包的类型定义方法</p>
</blockquote>
<h5 id="值类型与指针类型的接收者"><a href="#值类型与指针类型的接收者" class="headerlink" title="值类型与指针类型的接收者"></a>值类型与指针类型的接收者</h5><p>当方法的接收者是指针时，方法内对接收者的修改在方法外依然有效</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	man := NewPerson(<span class="string">&quot;康康&quot;</span>, <span class="number">17</span>)</span><br><span class="line">	fmt.Println(man.age) <span class="comment">// 17</span></span><br><span class="line">	p1.SetAge(<span class="number">18</span>)</span><br><span class="line">	fmt.Println(man.age) <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当方法的接收者是值类型时，方法内对接收者的修改在方法外无效。</p>
<h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h3><p>匿名字段：结构体允许成员字段在声明时没有字段名只有类型</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里Person类型的字段名默认为了类型名</p>
<p>因为字段名称必须唯一，所以同种类型的匿名字段只能有一个</p>
<h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>一个结构体中可以嵌套包含其他结构体或结构体指针</p>
<p>在嵌套结构体中也可以使用匿名字段</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体的”继承“"><a href="#结构体的”继承“" class="headerlink" title="结构体的”继承“"></a>结构体的”继承“</h3><p>Go语言中可以使用结构体实现其他语言中的继承</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cat 猫</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Feet    <span class="keyword">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cat := &amp;Cat&#123;</span><br><span class="line">		Feet: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">&quot;秋收&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.<span class="built_in">println</span>(cat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h3><p>结构体中</p>
<ul>
<li>字段大写开头表示可公开访问</li>
<li>字段小写开头表示私有访问（仅在定义当前结构体的包中可访问）</li>
</ul>
<h3 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h3><p>结构体-&gt;JSON</p>
<p>格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON数据, err := json.Marshal(结构体)</span><br></pre></td></tr></table></figure>

<p>JSON-&gt;结构体</p>
<p>格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = json.Unmarshal([]<span class="keyword">byte</span>(JSON字符串), 结构体)</span><br></pre></td></tr></table></figure>

<h3 id="结构体标签-TAG"><a href="#结构体标签-TAG" class="headerlink" title="结构体标签(TAG)"></a>结构体标签(TAG)</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来</p>
<p>TAG格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体tag由一个或多个键值对组成。</li>
<li>键与值使用冒号分隔，值用双引号括起来。</li>
<li>同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</li>
</ul>
<p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。例如不要在key和value之间添加空格。</p>
<p> 举例：Student的 <code>json tag</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">	Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">	name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换的json语句样例</span></span><br><span class="line"><span class="comment">//&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E7%BB%93%E6%9E%84%E4%BD%93/" data-id="ckrwd22ef000uqcubedds1ju8" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/接口" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.370Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>接口是一种抽象类型。</p>
<p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的体现。</p>
<p>接口做的事情是定义一个协议，不关心属性(数据)，只关心行为(方法)</p>
<h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>Go语言提倡面向接口编程</p>
<p>每个接口由数个方法组成，接口的定义格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名，Go的接口在命名时通常在单词后面添加<code>er</code></li>
<li>方法名：可以公有也可以私有</li>
<li>参数列表、返回值列表：参数变量名可以省略</li>
</ul>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个对象只要实现了接口中的全部方法，就实现了这个接口，所以接口就是一个需要实现的方法列表。</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义dog和cat两个结构体：</span></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>实现了接口，就可以通过接口实现多态</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">	</span><br><span class="line">    a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">	b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">	</span><br><span class="line">    x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">	x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">	</span><br><span class="line">    x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">	x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h3><p><strong>使用值接收者实现接口后</strong></p>
<p>不管是类型变量，还是指针类型变量，都可以赋给该接口变量</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">	x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">	x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用指针接收者实现接口后：</strong></p>
<p>只有指针类型变量可以赋给该接口变量</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">	x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">	x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h3><p>一个类型可以实现多个接口，且接口直接相互独立。</p>
<p>多个类型也可以实现一个接口。</p>
<h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>接口之间可以嵌套产生新的接口，这里类似继承的关系</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sayer</span><br><span class="line">	Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><h5 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h5><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个空接口x</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h5><p><strong>空接口作为函数的参数</strong></p>
<p>使用空接口实现可以接收任意类型的函数参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空接口作为map的值</strong></p>
<p>使用空接口实现可以保存任意值的字典。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h5 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h5><p>接口值是由<code>具体类型</code>和<code>具体类型的值</code>两部分组成，这两部分称为接口的<code>动态类型</code>和<code>动态值</code></p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><img src="https://www.liwenzhou.com/images/Go/interface/interface.png" alt="接口值图解"></p>
<h5 id="类型断言-1"><a href="#类型断言-1" class="headerlink" title="类型断言"></a>类型断言</h5><p>判断空接口中的值可以使用类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>x：表示类型为<code>interface&#123;&#125;</code>的变量</li>
<li>T：表示断言x可能的类型</li>
</ul>
<p>该函数返回两个参数</p>
<ul>
<li>参数一：x转化为T类型后的变量</li>
<li>参数二：如果断言正确则为<code>true</code>，否则为<code>false</code></li>
</ul>
<p>可以使用<code>switch</code>语句实现多次断言</p>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%8E%A5%E5%8F%A3/" data-id="ckrwd22ea000rqcub2vqye6bz" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Go语言学习/基本数据类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-08-03T17:50:53.368Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><p>整型可以分为两个大类</p>
<table>
<thead>
<tr>
<th>有符号整型</th>
<th>无符号整型</th>
</tr>
</thead>
<tbody><tr>
<td>int8</td>
<td>uint8</td>
</tr>
<tr>
<td>int16</td>
<td>uint16</td>
</tr>
<tr>
<td>int32</td>
<td>uint32</td>
</tr>
<tr>
<td>int64</td>
<td>uint64</td>
</tr>
</tbody></table>
<p>其中<code>uint8</code>对应<code>byte</code>型，<code>int16</code>对应<code>short</code>型，<code>int64</code>对应<code>long</code>型</p>
<p><strong>特殊整型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uint</td>
<td>随操作系统对应32或64</td>
</tr>
<tr>
<td>int</td>
<td>随操作系统对应32或64</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放指针</td>
</tr>
</tbody></table>
<p><strong>八进制&amp;十六进制</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span> 	<span class="comment">//10进制</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span>	<span class="comment">//8进制</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span> <span class="comment">//16进制</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>二进制</th>
<th>八进制</th>
<th>十进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>%b</td>
<td>%o</td>
<td>%d</td>
<td>%x</td>
</tr>
</tbody></table>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数分为<code>float32</code>和<code>float64</code></p>
<p>遵循<code>IEEE 754</code>标准</p>
<p>对应符号<code>%f</code></p>
<h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>复数分为<code>complex64</code>和<code>complex128</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span> </span><br></pre></td></tr></table></figure>

<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>布尔值<code>bool</code> 只有两个值：<code>true</code>和<code>false</code></p>
<p>默认值为<code>false</code></p>
<p>go语言中不允许将整数型强制转换成布尔型</p>
<p>go语言中也不允许参与数值运算</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Go语言类型转换格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>

<p><code>type_name</code>为类型，<code>expression</code>为表达式</p>
<p>举例：将整型转换为浮点型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line"><span class="keyword">var</span> floatNum <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line">floatNum = <span class="keyword">float32</span>(intNum)	<span class="comment">//floatNum = 17</span></span><br></pre></td></tr></table></figure>

<p>Go不支持隐式类型转化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="ckrwd22e7000pqcub0pkxcz6f" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%8C%87%E9%92%88/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E6%95%B0%E7%BB%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/04/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%88%87%E7%89%87/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>