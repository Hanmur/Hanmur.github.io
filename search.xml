<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>N的分解</title>
      <link href="/2021/120853668.html"/>
      <url>/2021/120853668.html</url>
      
        <content type="html"><![CDATA[<h2 id="在线软件的使用"><a href="#在线软件的使用" class="headerlink" title="在线软件的使用"></a>在线软件的使用</h2><h3 id="factordb"><a href="#factordb" class="headerlink" title="factordb"></a>factordb</h3><p><a href="http://factordb.com">http://factordb.com</a> 记录了部分大质数的分解，很多质数可以直接在这查找出质因数分解</p><h3 id="ECM"><a href="#ECM" class="headerlink" title="ECM"></a>ECM</h3><p><a href="https://www.alpertron.com.ar/ECM.HTM">https://www.alpertron.com.ar/ECM.HTM</a> 是ECM在线分解大整数的网站</p><h2 id="短除法"><a href="#短除法" class="headerlink" title="短除法"></a>短除法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从2开始暴力破解</p><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><pre class=" language-lang-python"><code class="language-lang-python">def factorization(n):    i = 2    ret = []    while i * i <= n:        while n % i == 0:            ret.append(i)            n //= i        i += 1    if n > 1:        ret.append(n)    return retif __name__ == '__main__':    print(factorization(int(input())))</code></pre><h3 id="Python代码2"><a href="#Python代码2" class="headerlink" title="Python代码2"></a>Python代码2</h3><p>(先打表出2到$n^{\frac 12}$之间的质数）</p><pre class=" language-lang-python"><code class="language-lang-python">pri = []MX = int(1e6)isprime = [True] * MXdef init():    global a, MX    for i in range(2, MX):        if isprime[i]:            pri.append(i)            for j in range(i + i, MX, i):                isprime[j] = Falsedef factorization(n):    global pri    ret = []    for i in pri:        if i * i > n:            break        while n % i == 0:            ret.append(i)            n //= i    ret.append(n)    return retif __name__ == '__main__':    init()    print(factorization(int(input())))</code></pre><h2 id="Miller-Rabin素性测试和离散对数Pollard-rho分解"><a href="#Miller-Rabin素性测试和离散对数Pollard-rho分解" class="headerlink" title="Miller-Rabin素性测试和离散对数Pollard_rho分解"></a>Miller-Rabin素性测试和离散对数Pollard_rho分解</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>暂无</p><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">"""用Miller-Rabin素性测试和离散对数Pollard_rho算法进行大数因数分解：复杂度: 0(n^1/4)适用范围: n 2-10^33"""import random# from math import log, log10from collections import Counterdef gcd(x, y):    return x if y == 0 else gcd(y, x % y)def fpow(a, x, n):    ans = 1    while x > 0:        if x & 1:            ans = ans * a % n        a = a * a % n        x >>= 1    return ans# there change the times of Rabin-MillerTIMES = 10def is_prime(n):    def check(a, n, x, t):        ret = fpow(a, x, n)        last = ret        for i in range(0, t):            ret = ret * ret % n            if ret == 1 and last != 1 and last != n - 1:                return True            last = ret        if ret != 1:            return True        return False    if not isinstance(n, int):        raise TypeError(str(n) + ' is not an integer!')    if n <= 0:        raise ValueError('%d <= 0' % n)    if n in {2, 3, 5, 7, 11}:        return True    for i in {2, 3, 5, 7, 11}:        if n % i == 0:            return False    x = n - 1    t = 0    while not x & 1:        x >>= 1        t += 1    for i in range(0, TIMES):        a = random.randint(1, n - 2)        if check(a, n, x, t):            return False    return Truedef pollard_rho_2(n, c):    x = random.randint(0, n)    i, k, y = 1, 2, x    while True:        i += 1        x = (x * x) % n + c        d = gcd(y - x, n)        if d != 1 and d != n:            return d        if y == x:            return n        if i == k:            y = x            k <<= 1def pollard_rho_1(n):    if not isinstance(n, int):        raise TypeError(str(n) + ' is not an integer!')    if n == 1:        return None    if is_prime(n):        return [n]    ans = []    p = n    while p >= n:        p = pollard_rho_2(p, random.randint(1, n - 1))    ans.extend(pollard_rho_1(p))    ans.extend(pollard_rho_1(n // p))    return ansdef factorization(n):    return Counter(pollard_rho_1(n))if __name__ == '__main__':    n = int(input())    print('len:', len(str(n)))    print(factorization(n))</code></pre><h2 id="Fermat分解"><a href="#Fermat分解" class="headerlink" title="Fermat分解"></a>Fermat分解</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>暂无</p><h3 id="Python代码-1"><a href="#Python代码-1" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">from isqrt import isqrtimport libnumdef fermat(n):    a = isqrt(n)    b2 = a * a - n    b = isqrt(n)    count = 0    while b * b != b2:        a = a + 1        b2 = a * a - n        b = isqrt(b2)        count += 1    p = a + b    q = a - b    assert n == p * q    return p, qif __name__ == '__main__':    N = 966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533    e = 65537    c = 168502910088858295634315070244377409556567637139736308082186369003227771936407321783557795624279162162305200436446903976385948677897665466290852769877562167487142385308027341639816401055081820497002018908896202860342391029082581621987305533097386652183849657065952062433988387640990383623264405525144003500286531262674315900537001845043225363148359766771033899680111076181672797077410584747509581932045540801777738548872747597899965366950827505529432483779821158152928899947837196391555666165486441878183288008753561108995715961920472927844877569855940505148843530998878113722830427807926679324241141182238903567682042410145345551889442158895157875798990903715105782682083886461661307063583447696168828687126956147955886493383805513557604179029050981678755054945607866353195793654108403939242723861651919152369923904002966873994811826391080318146260416978499377182540684409790357257490816203138499369634490897553227763563553981246891677613446390134477832143175248992161641698011195968792105201847976082322786623390242470226740685822218140263182024226228692159380557661591633072091945077334191987860262448385123599459647228562137369178069072804498049463136233856337817385977990145571042231795332995523988174895432819872832170029690848    p, q = fermat(N)    print("p:", p)    print("q:", q)    # 根据p,q求phi_n也即N的欧拉函数值    phi_n = (p-1)*(q-1)    # 求d    d = libnum.invmod(e, phi_n)    # 用d解密    flag = libnum.n2s(pow(c, d, N))    print(flag)</code></pre><h2 id="yafu"><a href="#yafu" class="headerlink" title="yafu"></a>yafu</h2><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://bbs.pediy.com/thread-266648.htm">[原创]Crypto-RSA大整数分解-LineCTF2021-babycrypto3</a></p><p><a href="https://www.tr0y.wang/2017/11/06/CTFRSA/#%E5%A4%A7%E6%95%B0%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95">RSA大礼包 - Tr0y’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见解题思路</title>
      <link href="/2021/120661227.html"/>
      <url>/2021/120661227.html</url>
      
        <content type="html"><![CDATA[<h2 id="已知-P-Q-e-求d"><a href="#已知-P-Q-e-求d" class="headerlink" title="已知(P, Q, e) 求d"></a>已知(P, Q, e) 求d</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>q：质数q</li><li>p：质数p</li><li>e：加密指数</li><li>d：解密指数</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">\phi(n) = (p - 1) * (q - 1)    \\ e*d \equiv 1 \mod\phi(n)</script><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2p = ...q = ...e = ...phi_n = (p-1)*(q-1)d = gmpy2.invert(e, phi_n)print(d)</code></pre><h2 id="已知-p-q-e-c-求m"><a href="#已知-p-q-e-c-求m" class="headerlink" title="已知(p,q,e,c) 求m"></a>已知(p,q,e,c) 求m</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul><li>q：质数q</li><li>p：质数p</li><li>e：加密指数</li><li>c：密文c</li><li>m：明文m</li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">n = p * q, \quad \phi(n) = (p - 1) * (q - 1)\\ e*d \equiv 1 \mod \phi(n) \\ m = pow(c, d, n)</script><h3 id="Python代码-1"><a href="#Python代码-1" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2p =  ...q =  ...e =  ...c =  ...phi_n = (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)n = p * qm = gmpy2.powmod(c,d,n)print(str(m) )</code></pre><h2 id="已知-q-p-dq-dp-c-求m"><a href="#已知-q-p-dq-dp-c-求m" class="headerlink" title="已知(q,p,dq,dp,c) 求m"></a>已知(q,p,dq,dp,c) 求m</h2><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul><li>q：质数q</li><li>p：质数p</li><li>dq：dq ≡ d mod(q - 1)</li><li>dp：dp ≡ d mod(p - 1)</li><li>c：密文</li><li>m：明文</li></ul><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>由于中国剩余定理:</p><script type="math/tex; mode=display">\because m = c^d\ mod n \\ n = p * q \\ \therefore mp \equiv c^d\ mod p \quad ① \\ mq \equiv c^d\ mod q \quad ②</script><p>由①式，有</p><script type="math/tex; mode=display">c^d = k*p + mp \quad ③</script><p>将③式带入②式，有</p><script type="math/tex; mode=display">k * p \equiv (mp - mq) \mod q \\ k \equiv [p^{-1} * (mp - mq)] \mod q</script><p>将k带入③式，有</p><script type="math/tex; mode=display">c^d = \{[p^{-1} * (mp - mq)]\ mod q\} * p + mp</script><p>由费马小定理:</p><script type="math/tex; mode=display">\because d = dp + k_p * (p - 1) = dq + k_q * (q - 1)             \\   \therefore mp \equiv c^d \mod p \equiv c^{dp + k_p * (p - 1)} \mod p \equiv c^{dp} \mod p                          \\ mq \equiv c^d \mod q \equiv c^{dq + k_q * (q - 1)} \mod q \equiv c^{dq} \mod q</script><p>故:</p><script type="math/tex; mode=display">m \equiv c^d = \{[p^{-1} * (mp - mq)] \mod q\} * p + mp</script><h3 id="Python代码-2"><a href="#Python代码-2" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2p = ...q = ...dp = ...dq = ...c = ...I = gmpy2.invert(q,p)mp = pow(c,dp,p)mq = pow(c,dq,q)m = (((mp-mq)*I)%q)*p+mpprint(hex(m))</code></pre><h2 id="已知-e-大数n-dp-c-求m"><a href="#已知-e-大数n-dp-c-求m" class="headerlink" title="已知(e,大数n,dp,c) 求m"></a>已知(e,大数n,dp,c) 求m</h2><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul><li>n：大数字n</li><li>e：加密指数</li><li>dp：dp ≡ d mod (p - 1)</li><li>c：密文c</li><li>m：明文m</li></ul><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">\because e * d \equiv 1 \mod((p-1)(q-1))\\ dp \equiv d \mod(p - 1)    \\ \therefore e*dp \equiv e*d \mod(p-1) \\ \therefore e*d = k_1(p-1)(q-1) + 1 = k_2(p-1) + e*dp               \\ e*dp = (p - 1)(k_1(q-1) - k_2)+1</script><script type="math/tex; mode=display">\because dp < p  \\ \therefore e > (k_1(q-1) - k_2)\\ (k_1(q-1)-k_2) \in (1,e) \\遍历即可</script><h3 id="Python代码-3"><a href="#Python代码-3" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python"># 领航杯2019，EasyRSAimport gmpy2import libnume = ...n = ...dp = ...c = ...for i in range(1, e + 1):    if (dp * e - 1) % i == 0:        if n % (((dp * e - 1) // i) + 1) == 0:            p = ((dp * e - 1) // i) + 1            q = n // (((dp * e - 1) // i) + 1)            phi = (p - 1) * (q - 1)            d = gmpy2.invert(e, phi) % phi            print(libnum.n2s(pow(c, d, n)))</code></pre><h2 id="共模攻击：已知-n-e1-e2-c1-c2-求m"><a href="#共模攻击：已知-n-e1-e2-c1-c2-求m" class="headerlink" title="共模攻击：已知(n,e1,e2,c1,c2) 求m"></a>共模攻击：已知(n,e1,e2,c1,c2) 求m</h2><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul><li>n：大数字n</li><li>e1, e2：加密指数</li><li>c1, c2：密文c</li><li>m：明文m</li></ul><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>共模攻击</p><script type="math/tex; mode=display">c_1 = m^{e_1}\mod n             \\   c_2 = m^{e_2}\mod n</script><p>当e1, e2互质时，有</p><script type="math/tex; mode=display">ae_1 + be_2 = 1</script><p>利用拓展欧几里得算法，可求得(a, b)的一组解</p><script type="math/tex; mode=display">\\\begin{align*} c_1^a * c_2^b\mod n  &= ((m^{e_1}\mod n)^a * (m^{e_2}\mod n)^b)\mod n \\ &= m^{a*e_1+b*e_2}\mod n \end{align*}</script><script type="math/tex; mode=display">\because a * e_1 + b * e_2 = 1  \\ \therefore m\equiv c_1^a*c_2^b\mod n</script><h3 id="Python代码-4"><a href="#Python代码-4" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import binasciin = ...c1 = ...c2 = ...e1 = ...e2 = ...s = gmpy2.gcdext(e1,e2)a = s[1]b = s[2]if a < 0:    a = -a    c1 = gmpy2.invert(c1,n)else:    b = -b    c2 = gmpy2.invert(c2,n)m = (gmpy2.powmod(c1,a,n)*gmpy2.powmod(c2,b,n))%nprint(binascii.unhexlify(hex(m)[2:]))</code></pre><h2 id="n分解出多个质因数-求m"><a href="#n分解出多个质因数-求m" class="headerlink" title="n分解出多个质因数 求m"></a>n分解出多个质因数 求m</h2><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul><li>n：大数字n</li><li>e：加密指数</li><li>p0~pi：n的质因数</li><li>c：密文c</li><li>m：明文m</li></ul><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>n的质因数只影响φ的求值，依据<a href="https://www.notion.so/e18df727d3fa488bbc03275034893cb4">欧拉函数</a>求出φ即可。如n有三个质因数，则</p><script type="math/tex; mode=display">\phi(n) = (p_1 - 1)(p_2 - 1)(p_3 - 1)</script><h3 id="Python代码-5"><a href="#Python代码-5" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2from Crypto.Util.number import long_to_bytesn= ...e= ...c= ...# n的质因数p1 = ...p2 = ...p3 = ...phi = (p1 - 1) * (p2 - 1) * (p3 - 1)  d = gmpy2.invert(e, phi)  m = pow(c, d, n)  print long_to_bytes(m)</code></pre><h2 id="公钥私钥的文件处理"><a href="#公钥私钥的文件处理" class="headerlink" title="公钥私钥的文件处理"></a>公钥私钥的文件处理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>工具：</p><p><a href="https://www.jianshu.com/p/c945b0f0de0a">RSA工具集-openssl,rsatool,RsaCtfTool,RSAtool</a></p><ul><li>RsaCtfTool</li><li>openssl</li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>上代码：</p><p>获取公钥文件的公钥</p><pre class=" language-lang-python"><code class="language-lang-python">from Crypto.PublicKey import RSApath = '...'with open(path) as f:    key = RSA.import_key(f.read())    print('e = %d' % key.e)    print('n = %d' % key.n)</code></pre><p>私钥解密文件</p><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import rsap = ...q = ...n = ...e = ...d = int(gmpy2.invert(e, (p-1) * (q-1)))privatekey = rsa.PrivateKey(n, e, d, p, q)      # 根据已知参数，计算私钥path = "..."with open(path, "rb") as f:    print(rsa.decrypt(f.read(), privatekey).decode())       # 使用私钥对密文进行解密，并打印</code></pre><h2 id="低加密指数分解攻击-e-2-3"><a href="#低加密指数分解攻击-e-2-3" class="headerlink" title="低加密指数分解攻击(e = 2, 3)"></a>低加密指数分解攻击(e = 2, 3)</h2><h3 id="e-2"><a href="#e-2" class="headerlink" title="e = 2"></a>e = 2</h3><h4 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h4><script type="math/tex; mode=display">c = m^e \mod n</script><p>因为$e = 2$， 相当于$c$是$m$的平方对$n$取模</p><p>一般开根就可以了</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnumc = ...m = gmpy2.isqrt(c)m_text = libnum.n2s(int(m) )  #将十六进制转为字符print(m_text)</code></pre><h3 id="e-3"><a href="#e-3" class="headerlink" title="e = 3"></a>e = 3</h3><h4 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h4><script type="math/tex; mode=display">\because c = m^e \mod n \\ \therefore c + k*n = m^e</script><p>e很小的时候，k的值也会很小，所以可以直接爆破</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2,binascii,libnum,timen = ...e = 3c = ...m = 0for i in xrange(200000):    if gmpy2.iroot(c + n * i, e)[1] == 1:        m = gmpy2.iroot(c + n * i, e)[0]        print libnum,n2s(m)        break</code></pre><h2 id="低加密指数广播攻击-已知-n-i-c-i-e-，-求-m"><a href="#低加密指数广播攻击-已知-n-i-c-i-e-，-求-m" class="headerlink" title="低加密指数广播攻击(已知$n_i, c_i, e$， 求$m$)"></a>低加密指数广播攻击(已知$n_i, c_i, e$， 求$m$)</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。</p><p>对于</p><script type="math/tex; mode=display">c_i = m^e \mod n_i</script><p>使用中国剩余定理，有:</p><script type="math/tex; mode=display">\begin{align}c_x &= m^e\mod \prod n_i \\&= m^e\mod n_1*n_2*...\end{align}</script><h3 id="Python代码1：中国剩余定理"><a href="#Python代码1：中国剩余定理" class="headerlink" title="Python代码1：中国剩余定理"></a>Python代码1：中国剩余定理</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnumdef CRT(data):    sum = 0    m = 1    for n in data:        m = m * n[0]    for n, c in data:        m1 = m / n        mr = gmpy2.invert(m1, n)        sum = sum + mr * m1 * c    return sum % mc1 = ...c2 = ...c3 = ...n1 = ...n2 = ...n3 = ...e = 3n = [n1, n2, n3]c = [c1, c2, c3]data = zip(n, c)m_e = CRT(data)m = gmpy2.iroot(m_e, e)[0]print m    # 输出明文数字 print libnum.n2s(m)   # 输出明文数字转为的字符串</code></pre><h3 id="Python代码2：自动爆破e"><a href="#Python代码2：自动爆破e" class="headerlink" title="Python代码2：自动爆破e"></a>Python代码2：自动爆破e</h3><pre class=" language-lang-python"><code class="language-lang-python">import randomfrom gmpy2 import invert, irootimport libnumdef broadcast(n1, n2 ,n3, c1, c2, c3):    n = [n1, n2, n3]    C = [c1, c2, c3]    N = 1    for i in n:        N *= i    Ni = []    for i in n:        Ni.append(N / i)    T = []    for i in xrange(3):        T.append(long(invert(Ni[i], n[i])))    X = 0    for i in xrange(3):        X += C[i] * Ni[i] * T[i]    m3 = X % N    m = iroot(m3, 3)    return m[0]if __name__=="__main__":    # e = ... （不需要）    c1 = ...    c2 = ...    c3 = ...    n1 = ...    n2 = ...    n3 = ...    m = broadcast(n1, n2 ,n3, c1, c2, c3)    print m    # 输出明文m    print libnum.n2s(m)   # 输出明文数字转化为字符串后的结果</code></pre><h2 id="低解密指数攻击-e太大-太小时"><a href="#低解密指数攻击-e太大-太小时" class="headerlink" title="低解密指数攻击(e太大/太小时)"></a>低解密指数攻击(e太大/太小时)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>低解密指数攻击，也称RSA维纳攻击(RSA Wiener Attack)，是一种基于连分数的特殊攻击类型</p><script type="math/tex; mode=display">e * d \equiv 1 \mod \phi(n)</script><p>满足条件：</p><ul><li>$d &lt; \frac13 n^{\frac14}$</li><li>$q &lt; p &lt; 2q$</li></ul><p>在上述条件下，可以通过Wiener Attack在多项式的时间内分解n</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在RSA中</p><script type="math/tex; mode=display">N = pq,\quad \phi(n) = (p - 1)(q - 1) \approx N \\\because ed \equiv 1\mod \phi(n)    \\\therefore ed - 1 = k * \phi(n),\quad 两边同除 d\phi(n) \\\therefore \frac e{\phi(n)} - \frac kd = \frac 1{d\phi(n)}    \\\because \phi(n) \approx N,\quad \frac 1{d\phi(n)}\approx 0 \\\therefore \frac eN 略大于 \frac kd</script><p>回顾一下已知条件，我们是知道$\frac eN$的，而Wiener告诉我们，计算$\frac eN$的连分数展开可以精准的覆盖$\frac kd$</p><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><ul><li><p>将$\frac eN$连分数展开(举例：$0, 1, \frac 12, \frac 23, …$ )</p></li><li><p>对每一个渐进分数，假设之成立</p><ul><li>则$k = 分子, d = 分母$，代入$ed - 1 = k * \phi(n)$，求得$\phi(n)$</li><li>通过$\begin{cases}\phi(n) = (p - 1)(q - 1) = N - (p + q) + 1 \ N = pq \end{cases}$ ， 求得$p+q$与$pq$的值</li><li>利用韦达定理，构造方程$x^2 - (p + q) * x + pq = 0$，求根得到p, q</li><li>验证p * q是否满足</li></ul></li></ul><h3 id="Python代码1"><a href="#Python代码1" class="headerlink" title="Python代码1"></a>Python代码1</h3><pre class=" language-lang-python"><code class="language-lang-python">def continuedFra(x, y):    cF = []    while y:        cF += [x // y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)def getit(c):    cf = []    for i in range(1, len(c)):        cf.append(Simplify(c[:i]))    return cf# 求渐进分数def wienerAttack(e, n):    cf = continuedFra(e, n)    for (p2, p1) in getit(cf):        if p1 == 0:            continue        if e % p1 == 0 and p1 != 1:            return p1    print('not find!')n1 = 60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121e1 = 60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347d = wienerAttack(n1, e1)print(d)</code></pre><h3 id="Python代码2（多重基数的处理）"><a href="#Python代码2（多重基数的处理）" class="headerlink" title="Python代码2（多重基数的处理）"></a>Python代码2（多重基数的处理）</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2from Crypto.Util.number import *def transform(x, y):       # 使用辗转相处将分数 x/y 转为连分数的形式    res=[]    while y:        res.append(x // y)        x, y = y, x % y    return resdef continued_fraction(sub_res):    numerator,denominator = 1, 0    for i in sub_res[::-1]:      # 从sublist的后面往前循环        denominator, numerator = numerator, i * numerator + denominator    return denominator,numerator   # 得到渐进分数的分母和分子，并返回#求解每个渐进分数def sub_fraction(x, y):    res = transform(x, y)    res = list(map(continued_fraction, (res[0:i] for i in range(1, len(res)))))  #将连分数的结果逐一截取以求渐进分数    return res# 以上是获得e/n的连分数def get_pq(a, b, c):      # 由p+q和pq的值通过维达定理来求解p和q    par = gmpy2.isqrt(b * b - 4 * a * c)   # 由上述可得，开根号一定是整数，因为有解    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)    return x1, x2def wienerAttack(e, n):    for (d, k) in sub_fraction(e, n):  # 用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数        # if k==0:                     # 可能会出现连分数的第一个为0的情况，排除            # continue        # if (e*d-1)%k!=0:             # ed=1 (\pmod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n)            # continue        if 250 <= d.bit_length() <= 256:            print(d)            global c            print(long_to_bytes(pow(c, d, n)))        else:            continue        phi = (e * d - 1) // k               # 这个结果就是 φ(n)        px, qy = get_pq(1, n - phi + 1, n)        if px * qy == n:            p, q = abs(int(px)), abs(int(qy))     # 可能会得到两个负数，负负得正未尝不会出现            d = gmpy2.invert(e, (p - 1) * (q - 1))     # 求ed=1 (\pmod  φ(n))的结果，也就是e关于 φ(n)的乘法逆元d            return d    print("该方法不适用")e = ...n = ...c = ...d = wienerAttack(e, n)print("d=", d)</code></pre><h2 id="两个N的模不互素"><a href="#两个N的模不互素" class="headerlink" title="两个N的模不互素"></a>两个N的模不互素</h2><h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h3><script type="math/tex; mode=display">\begin{cases}n_1 = p_1 * q \\n_2 = p_2 * q \end{cases}\quad, q为n_1, n_2的公因数</script><p>找出$n_1, n_2$的公因数作为$q$，再对$n_1,n_2$分别除$q$，求得$p_1, p_2$，之后直接求解即可</p><h3 id="Python代码-6"><a href="#Python代码-6" class="headerlink" title="Python代码"></a>Python代码</h3><pre class=" language-lang-python"><code class="language-lang-python">import gmpy2import libnume = ...c1 = ...c2 = ...n1 = ...n2 = ...q = gmpy2.gcd(n1, n2)assert (q != 1)p1 = n1 / qp2 = n2 / qd1 = gmpy2.invert(e, (q - 1) * (p1 - 1))d2 = gmpy2.invert(e, (q - 1) * (p2 - 1))m1 = pow(c1, d1, n1)m2 = pow(c2, d2, n2)print libnum.n2s(m1) + libnum.n2s(m2)</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/2021/120655226.html"/>
      <url>/2021/120655226.html</url>
      
        <content type="html"><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><script type="math/tex; mode=display">\phi(n) = \underline{从1到n中和n互素的数}的个数</script><script type="math/tex; mode=display">公式：\phi(n) = n * \prod(1 - \frac{1}{p_i}), \quad p_i是n的所有质因子</script><h3 id="规律："><a href="#规律：" class="headerlink" title="规律："></a>规律：</h3><ul><li><p>$n$为质数：</p><script type="math/tex; mode=display">\phi(n) = n - 1</script></li><li><p>$n = p^k$，$p$为素数：</p><script type="math/tex; mode=display">\phi(n) = p^k *(1 - \frac1p)</script></li><li><p>当$m$和$n$互质：</p><script type="math/tex; mode=display">\phi(n * m) = \phi(n) * \phi(m)</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密算法</title>
      <link href="/2021/120662112.html"/>
      <url>/2021/120662112.html</url>
      
        <content type="html"><![CDATA[<h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>公钥</p><script type="math/tex; mode=display">(E, N)</script></li><li><p>私钥</p><script type="math/tex; mode=display">(D, N)</script></li><li><p>密钥对</p><script type="math/tex; mode=display">(E, D, N)</script></li></ul><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><script type="math/tex; mode=display">密文 = 明文^E\ mod N</script><h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><script type="math/tex; mode=display">明文 = 密文^D\ mod N</script><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><ol><li><p>求<strong>N</strong></p><p>选取两个相对较大的质数<strong>P</strong>,<strong>Q</strong></p><script type="math/tex; mode=display">N = P * Q</script></li><li><p>求<strong>φ(N)</strong>: 需要的中间量</p><script type="math/tex; mode=display">\phi(N) = (P - 1 ) * (Q - 1)</script></li><li><p>求<strong>E</strong></p><p><strong>E</strong>是选取出来的满足特定条件的数，一般取0x10001</p><p><strong>E</strong>需要满足的条件：</p><ul><li><strong>1 &lt; E &lt; φ(N)</strong></li><li><strong>gcd(E,φ(N)) = 1</strong></li></ul></li><li><p>求<strong>D</strong></p><p><strong>D</strong>是通过<strong>E</strong>和<strong>φ(N)</strong>计算得出的数字</p><script type="math/tex; mode=display">(D*E) \ mod \phi(N) = 1</script><p><strong>D</strong>需要满足的条件：</p><ul><li><strong>1 &lt; E &lt; φ(N)</strong></li><li><strong>gcd(E,φ(N)) = 1</strong></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Crypto </category>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time包</title>
      <link href="/2021/120344858.html"/>
      <url>/2021/120344858.html</url>
      
        <content type="html"><![CDATA[<h1 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h1><p>time包提供了时间的显示和测量用的函数。日历的计算采用的是公历。</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p><code>time.Time</code>类型表示时间。我们可以通过<code>time.Now()</code>函数获取当前的时间对象，进而获取时间对象的年月日时分秒等信息</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func timeDemo() {    now := time.Now() //获取当前时间    fmt.Printf("current time:%v\n", now)    year := now.Year()     //年    month := now.Month()   //月    day := now.Day()       //日    hour := now.Hour()     //小时    minute := now.Minute() //分钟    second := now.Second() //秒    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)}</code></pre><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。又称Unix时间戳（UnixTimestamp）。</p><p>举例：基于时间对象获取时间戳：</p><pre class=" language-lang-go"><code class="language-lang-go">func timestampDemo() {    now := time.Now()            //获取当前时间    timestamp1 := now.Unix()     //时间戳    timestamp2 := now.UnixNano() //纳秒时间戳    fmt.Printf("current timestamp1:%v\n", timestamp1)    fmt.Printf("current timestamp2:%v\n", timestamp2)}</code></pre><p>使用<code>time.Unix()</code>函数可以将时间戳转为时间格式。</p><pre class=" language-lang-go"><code class="language-lang-go">func timestampDemo2(timestamp int64) {    timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式    fmt.Println(timeObj)    year := timeObj.Year()     //年    month := timeObj.Month()   //月    day := timeObj.Day()       //日    hour := timeObj.Hour()     //小时    minute := timeObj.Minute() //分钟    second := timeObj.Second() //秒    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)}</code></pre><h2 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h2><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code>表示一段时间间隔，可表示的最长时间段大约290年。</p><p>time包中定义的时间间隔类型的常量如下：</p><pre class=" language-lang-go"><code class="language-lang-go">const (    Nanosecond  Duration = 1    Microsecond          = 1000 * Nanosecond    Millisecond          = 1000 * Microsecond    Second               = 1000 * Millisecond    Minute               = 60 * Second    Hour                 = 60 * Minute)</code></pre><p>例如：<code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p><h2 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>Go语言的时间对象有提供Add方法：增加若干时间</p><pre class=" language-lang-go"><code class="language-lang-go">func (t Time) Add(d Duration) Time</code></pre><p>举例：求一个小时之后的时间</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    now := time.Now()    later := now.Add(time.Hour) // 当前时间加1小时后的时间    fmt.Println(later)}</code></pre><h3 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h3><p>求两个时间对象所指时间之间的差值：</p><pre class=" language-lang-go"><code class="language-lang-go">func (t Time) Sub(u Time) Duration</code></pre><p>返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。</p><p>要获取时间点t-d（d为Duration），可以使用t.Add(-d)。</p><h3 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h3><pre class=" language-lang-go"><code class="language-lang-go">func (t Time) Equal(u Time) bool</code></pre><p>判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。</p><p>本方法和用t==u不同，这种方法还会比较地点和时区信息。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><pre class=" language-lang-go"><code class="language-lang-go">func (t Time) Before(u Time) bool</code></pre><p>如果t代表的时间点在u之前，返回真；否则返回假。</p><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><pre class=" language-lang-go"><code class="language-lang-go">func (t Time) After(u Time) bool</code></pre><p>如果t代表的时间点在u之后，返回真；否则返回假。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>使用<code>time.Tick(时间间隔)</code>来设置定时器，定时器的本质上是一个通道（channel）。</p><pre class=" language-lang-go"><code class="language-lang-go">func tickDemo() {    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器    for i := range ticker {        fmt.Println(i)//每秒都会执行的任务    }}</code></pre><h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><p>时间类型有一个自带的方法<code>Format</code>进行格式化。</p><blockquote><p>注意：Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>，而是<code>2006年1月2号15点04分</code></p><p>这个字串是按照美国人好记忆的日期书写顺序写的一个1234567。1月2号下午3时4分5秒 06年 7时区</p><p>补充：如果想格式化为12小时方式，需指定<code>PM</code>。</p></blockquote><pre class=" language-lang-go"><code class="language-lang-go">func formatDemo() {    now := time.Now()    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan    // 24小时制    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))    // 12小时制    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))    fmt.Println(now.Format("2006/01/02 15:04"))    fmt.Println(now.Format("15:04 2006/01/02"))    fmt.Println(now.Format("2006/01/02"))}</code></pre><h3 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h3><pre class=" language-lang-go"><code class="language-lang-go">now := time.Now()fmt.Println(now)// 加载时区loc, err := time.LoadLocation("Asia/Shanghai")if err != nil {    fmt.Println(err)    return}// 按照指定时区和指定格式解析字符串时间timeObj, err := time.ParseInLocation("2006/01/02 15:04:05", "2019/08/04 14:15:20", loc)if err != nil {    fmt.Println(err)    return}fmt.Println(timeObj)fmt.Println(timeObj.Sub(now))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>strconv包</title>
      <link href="/2021/120338718.html"/>
      <url>/2021/120338718.html</url>
      
        <content type="html"><![CDATA[<h1 id="strconv包"><a href="#strconv包" class="headerlink" title="strconv包"></a>strconv包</h1><p>strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数：</p><p> <code>Atoi()</code>、<code>Itoa()</code>、parse系列、format系列、append系列。</p><p>更多函数请查看<a href="https://golang.org/pkg/strconv/">官方文档</a>。</p><h2 id="string与int类型转换"><a href="#string与int类型转换" class="headerlink" title="string与int类型转换"></a>string与int类型转换</h2><p>这一组函数是我们平时编程中用的最多的。</p><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p><pre class=" language-lang-go"><code class="language-lang-go">func Atoi(s string) (i int, err error)</code></pre><p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p><pre class=" language-lang-go"><code class="language-lang-go">s1 := "100"i1, err := strconv.Atoi(s1)if err != nil {    fmt.Println("can't convert to int")} else {    fmt.Printf("type:%T value:%#v\n", i1, i1) //type:int value:100}</code></pre><h3 id="Itia"><a href="#Itia" class="headerlink" title="Itia()"></a>Itia()</h3><p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p><pre class=" language-lang-go"><code class="language-lang-go">func Itia(i int) string</code></pre><p>示例代码如下：</p><pre class=" language-lang-go"><code class="language-lang-go">i2 := 200s2 := strconv.Itia(i2)fmt.Printf("type:%T value:%#v\n", s2, s2) //type:string value:"200"</code></pre><blockquote><p>【扩展阅读】这是C语言遗留下的典故。C语言中没有string类型而是用字符数组(array)表示字符串，所以<code>Itia</code>对很多C系的程序员很好理解。</p></blockquote><h2 id="Parse系列函数"><a href="#Parse系列函数" class="headerlink" title="Parse系列函数"></a>Parse系列函数</h2><p>Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</p><h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><pre class=" language-lang-go"><code class="language-lang-go">func ParseBool(str string) (value bool, err error)</code></pre><p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p><h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><pre class=" language-lang-go"><code class="language-lang-go">func ParseInt(s string, base int, bitSize int) (i int64, err error)</code></pre><p>返回字符串表示的整数值，接受正负号。</p><p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p><p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p><p>返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p><h3 id="ParseUnit"><a href="#ParseUnit" class="headerlink" title="ParseUnit()"></a>ParseUnit()</h3><pre class=" language-lang-go"><code class="language-lang-go">func ParseUint(s string, base int, bitSize int) (n uint64, err error)</code></pre><p><code>ParseUint</code>类似<code>ParseInt</code>但不接受正负号，用于无符号整型。</p><h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><pre class=" language-lang-go"><code class="language-lang-go">func ParseFloat(s string, bitSize int) (f float64, err error)</code></pre><p>解析一个表示浮点数的字符串并返回其值。</p><p>如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。</p><p>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；</p><p>返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><pre class=" language-lang-go"><code class="language-lang-go">b, err := strconv.ParseBool("true")f, err := strconv.ParseFloat("3.1415", 64)i, err := strconv.ParseInt("-2", 10, 64)u, err := strconv.ParseUint("2", 10, 64)</code></pre><p>这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p><h2 id="Format系列函数"><a href="#Format系列函数" class="headerlink" title="Format系列函数"></a>Format系列函数</h2><p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p><h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><pre class=" language-lang-go"><code class="language-lang-go">func FormatBool(b bool) string</code></pre><p>根据b的值返回”true”或”false”。</p><h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><pre class=" language-lang-go"><code class="language-lang-go">func FormatInt(i int64, base int) string</code></pre><p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p><h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><pre class=" language-lang-go"><code class="language-lang-go">func FormatUint(i uint64, base int) string</code></pre><p>是FormatInt的无符号整数版本。</p><h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><pre class=" language-lang-go"><code class="language-lang-go">func FormatFloat(f float64, fmt byte, prec, bitSize int) string</code></pre><p>函数将浮点数表示为字符串并返回。</p><p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p><p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p><p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><pre class=" language-lang-go"><code class="language-lang-go">s1 := strconv.FormatBool(true)s2 := strconv.FormatFloat(3.1415, 'E', -1, 64)s3 := strconv.FormatInt(-2, 16)s4 := strconv.FormatUint(2, 16)</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="isPrint"><a href="#isPrint" class="headerlink" title="isPrint()"></a>isPrint()</h3><pre class=" language-lang-go"><code class="language-lang-go">func IsPrint(r rune) bool</code></pre><p>返回一个字符是否是可打印的，和<code>unicode.IsPrint</code>一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p><h3 id="CanBackquote"><a href="#CanBackquote" class="headerlink" title="CanBackquote()"></a>CanBackquote()</h3><pre class=" language-lang-go"><code class="language-lang-go">func CanBackquote(s string) bool</code></pre><p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>除上文列出的函数外，<code>strconv</code>包中还有Append系列、Quote系列等函数。具体用法可查看<a href="https://golang.org/pkg/strconv/">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log包</title>
      <link href="/2021/120334166.html"/>
      <url>/2021/120334166.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言标准库log介绍"><a href="#Go语言标准库log介绍" class="headerlink" title="Go语言标准库log介绍"></a>Go语言标准库log介绍</h1><p>无论是软件开发的调试阶段还是软件上线之后的运行阶段，日志一直都是非常重要的一个环节，我们也应该养成在程序中记录日志的好习惯。</p><h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p><h2 id="使用Logger"><a href="#使用Logger" class="headerlink" title="使用Logger"></a>使用Logger</h2><p><code>log</code>包定义了<code>Logger</code>类型，该类型提供了一些格式化输出的方法。</p><p>本包也提供了一个预定义的“标准”<code>logger</code>，可以通过调用下列函数使用</p><ul><li><code>Print系列</code>(Print|Printf|Println）</li><li><code>Fatal系列</code>（Fatal|Fatalf|Fatalln）</li><li><code>Panic系列</code>（Panic|Panicf|Panicln）</li></ul><p>举例：通过<code>log</code>包来调用上面提到的方法，默认它们会将日志信息打印到终端界面：</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "log")func main() {    log.Println("这是一条很普通的日志。")    v := "很普通的"    log.Printf("这是一条%s日志。\n", v)    log.Fatalln("这是一条会触发fatal的日志。")    log.Panicln("这是一条会触发panic的日志。")}</code></pre><p>编译并执行上面的代码会得到如下输出：</p><pre class=" language-lang-bash"><code class="language-lang-bash">2021/08/19 20:29:43 这是一条很普通的日志。2021/08/19 20:29:43 这是一条很普通的日志。2021/08/19 20:29:43 这是一条会触发fatal的日志。</code></pre><p><code>logger</code>会打印每条日志信息的日期、时间，默认输出到系统的标准错误。</p><p><code>Fatal</code>系列函数会在写入日志信息后调用<code>os.Exit(1)</code>。</p><p><code>Panic</code>系列函数会在写入日志信息后<code>panic</code>。</p><h2 id="配置logger"><a href="#配置logger" class="headerlink" title="配置logger"></a>配置logger</h2><h3 id="标准logger的配置"><a href="#标准logger的配置" class="headerlink" title="标准logger的配置"></a>标准logger的配置</h3><p>默认情况下的logger只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。<code>log</code>标准库中为我们提供了定制这些设置的方法。</p><p><code>log</code>标准库中的<code>Flags</code>函数会返回标准logger的输出配置，而<code>SetFlags</code>函数用来设置标准logger的输出配置。</p><pre class=" language-lang-go"><code class="language-lang-go">func Flags() intfunc SetFlags(flag int)</code></pre><h3 id="flag选项"><a href="#flag选项" class="headerlink" title="flag选项"></a>flag选项</h3><p><code>log</code>标准库提供了如下的flag选项，它们是一系列定义好的常量。</p><pre class=" language-lang-go"><code class="language-lang-go">const (    // 控制输出日志信息的细节，不能控制输出的顺序和格式。    // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message    Ldate         = 1 << iota     // 日期：2009/01/23    Ltime                         // 时间：01:23:23    Lmicroseconds                 // 微秒级别的时间：01:23:23.123123（用于增强Ltime位）    Llongfile                     // 文件全路径名+行号： /a/b/c/d.go:23    Lshortfile                    // 文件名+行号：d.go:23（会覆盖掉Llongfile）    LUTC                          // 使用UTC时间    LstdFlags     = Ldate | Ltime // 标准logger的初始值)</code></pre><p>举例：在记录日志之前设置标准logger的输出选项：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)    log.Println("这是一条很普通的日志。")}</code></pre><p>编译执行后得到的输出结果：</p><pre class=" language-lang-go"><code class="language-lang-go">2021/08/19 20:39:31.855723 C:/Users/86189/go/src/GoLearn/test/test.go:9: 这是一条很普通的日志。</code></pre><h3 id="配置日志前缀"><a href="#配置日志前缀" class="headerlink" title="配置日志前缀"></a>配置日志前缀</h3><p><code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p><pre class=" language-lang-go"><code class="language-lang-go">func Prefix() stringfunc SetPrefix(prefix string)</code></pre><p>其中<code>Prefix</code>函数用来查看标准logger的输出前缀，<code>SetPrefix</code>函数用来设置输出前缀。</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)    log.Println("这是一条很普通的日志。")    log.SetPrefix("[Hanmur]")    log.Println("这是一条很普通的日志。")}</code></pre><p>输出结果：</p><pre class=" language-lang-bash"><code class="language-lang-bash">2021/08/19 20:35:49.421980 C:/Users/86189/go/src/GoLearn/test/test.go:9: 这是一条很普通的日志。[Hanmur]2021/08/19 20:35:49.431919 C:/Users/86189/go/src/GoLearn/test/test.go:11: 这是一条很普通的日志。</code></pre><p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p><h3 id="配置日志输出位置"><a href="#配置日志输出位置" class="headerlink" title="配置日志输出位置"></a>配置日志输出位置</h3><pre class=" language-lang-go"><code class="language-lang-go">func SetOutput(w io.Writer)</code></pre><p><code>SetOutput</code>函数用来设置标准logger的输出目的地，默认是标准错误输出。</p><p>例如，下面的代码会把日志输出到同目录下的<code>xx.log</code>文件中。</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    //打开文件    logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)    if err != nil {        fmt.Println("open log file failed, err:", err)        return    }    //设置日志输出文件    log.SetOutput(logFile)    //设置日志输出格式    log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)    //日志输出    log.Println("这是一条很普通的日志。")    log.SetPrefix("[Hanmur]")    log.Println("这是一条很普通的日志。")}</code></pre><p>如果要使用标准的logger，我们通常会把上面的配置操作写到<code>init</code>函数中：</p><pre class=" language-lang-go"><code class="language-lang-go">func init() {    logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)    if err != nil {        fmt.Println("open log file failed, err:", err)        return    }    log.SetOutput(logFile)    log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)}</code></pre><h2 id="创建logger"><a href="#创建logger" class="headerlink" title="创建logger"></a>创建logger</h2><p><code>log</code>标准库中还提供了一个创建新logger对象的构造函数–<code>New</code>，支持我们创建自己的logger示例。</p><p><code>New</code>函数的签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func New(out io.Writer, prefix string, flag int) *Logger</code></pre><p>New创建一个Logger对象。其中，</p><ul><li>参数out设置日志信息写入的目的地。</li><li>参数prefix会添加到生成的每一条日志前面。</li><li>参数flag定义日志的属性（时间、文件等等）。</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    logger := log.New(os.Stdout, "<New>", log.Lshortfile|log.Ldate|log.Ltime)    logger.Println("这是自定义的logger记录的日志。")}</code></pre><p>将上面的代码编译执行之后，得到结果如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash"><New>2021/08/19 20:38:55 test.go:10: 这是自定义的logger记录的日志。</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go内置的log库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如<a href="https://github.com/sirupsen/logrus">logrus</a>、<a href="https://github.com/uber-go/zap">zap</a>等。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-net包</title>
      <link href="/2021/120322993.html"/>
      <url>/2021/120322993.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础之net-http"><a href="#Go语言基础之net-http" class="headerlink" title="Go语言基础之net/http"></a>Go语言基础之net/http</h1><p>Go语言内置的<code>net/http</code>包十分的优秀，提供了HTTP客户端和服务端的实现。</p><h2 id="net-http介绍"><a href="#net-http介绍" class="headerlink" title="net/http介绍"></a>net/http介绍</h2><p>Go语言内置的<code>net/http</code>包提供了HTTP客户端和服务端的实现。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><h3 id="基本的HTTP-HTTPS请求"><a href="#基本的HTTP-HTTPS请求" class="headerlink" title="基本的HTTP/HTTPS请求"></a>基本的HTTP/HTTPS请求</h3><p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p><pre class=" language-lang-go"><code class="language-lang-go">resp, err := http.Get("http://example.com/")...resp, err := http.Post("http://example.com/upload", "image/jpeg", &buf)...resp, err := http.PostForm("http://example.com/form",    url.Values{"key": {"Value"}, "id": {"123"}})</code></pre><p>程序在使用完response后必须关闭回复的主体。</p><pre class=" language-lang-go"><code class="language-lang-go">resp, err := http.Get("http://example.com/")if err != nil {    // handle error}defer resp.Body.Close()body, err := ioutil.ReadAll(resp.Body)// ...</code></pre><h3 id="GET请求示例"><a href="#GET请求示例" class="headerlink" title="GET请求示例"></a>GET请求示例</h3><p>使用<code>net/http</code>包编写一个简单的发送HTTP请求的Client端，代码如下：</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "io/ioutil"    "net/http")func main() {    resp, err := http.Get("https://www.baidu.com/")    if err != nil {        fmt.Printf("get failed, err:%v\n", err)        return    }    defer resp.Body.Close()    body, err := ioutil.ReadAll(resp.Body)    if err != nil {        fmt.Printf("read from resp.Body failed, err:%v\n", err)        return    }    fmt.Print(string(body))}</code></pre><p>将上面的代码保存之后编译成可执行文件，执行之后就能在终端打印<code>baidu.com</code>网站首页的内容了，我们的浏览器其实就是一个发送和接收HTTP协议数据的客户端，我们平时通过浏览器访问网页其实就是从网站的服务器接收HTTP数据，然后浏览器会按照HTML、CSS等规则将网页渲染展示出来。</p><h3 id="带参数的GET请求示例"><a href="#带参数的GET请求示例" class="headerlink" title="带参数的GET请求示例"></a>带参数的GET请求示例</h3><p>关于GET请求的参数需要使用Go语言内置的<code>net/url</code>这个标准库来处理。</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    apiUrl := "http://127.0.0.1:9090/get"    // URL param    data := url.Values{}    data.Set("name", "小王子")    data.Set("age", "18")    u, err := url.ParseRequestURI(apiUrl)    if err != nil {        fmt.Printf("parse url requestUrl failed, err:%v\n", err)    }    u.RawQuery = data.Encode() // URL encode    fmt.Println(u.String())    resp, err := http.Get(u.String())    if err != nil {        fmt.Printf("post failed, err:%v\n", err)        return    }    defer resp.Body.Close()    b, err := ioutil.ReadAll(resp.Body)    if err != nil {        fmt.Printf("get resp failed, err:%v\n", err)        return    }    fmt.Println(string(b))}</code></pre><p>对应的Server端HandlerFunc如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func getHandler(w http.ResponseWriter, r *http.Request) {    defer r.Body.Close()    data := r.URL.Query()    fmt.Println(data.Get("name"))    fmt.Println(data.Get("age"))    answer := `{"status": "ok"}`    w.Write([]byte(answer))}</code></pre><h3 id="Post请求示例"><a href="#Post请求示例" class="headerlink" title="Post请求示例"></a>Post请求示例</h3><p>上面演示了使用<code>net/http</code>包发送<code>GET</code>请求的示例，发送<code>POST</code>请求的示例代码如下：</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "io/ioutil"    "net/http"    "strings")// net/http post demofunc main() {    url := "http://127.0.0.1:9090/post"    // 表单数据    //contentType := "application/x-www-form-urlencoded"    //data := "name=小王子&age=18"    // json    contentType := "application/json"    data := `{"name":"小王子","age":18}`    resp, err := http.Post(url, contentType, strings.NewReader(data))    if err != nil {        fmt.Printf("post failed, err:%v\n", err)        return    }    defer resp.Body.Close()    b, err := ioutil.ReadAll(resp.Body)    if err != nil {        fmt.Printf("get resp failed, err:%v\n", err)        return    }    fmt.Println(string(b))}</code></pre><p>对应的Server端HandlerFunc如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func postHandler(w http.ResponseWriter, r *http.Request) {    defer r.Body.Close()    // 1. 请求类型是application/x-www-form-urlencoded时解析form数据    r.ParseForm()    fmt.Println(r.PostForm) // 打印form数据    fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))    // 2. 请求类型是application/json时从r.Body读取数据    b, err := ioutil.ReadAll(r.Body)    if err != nil {        fmt.Printf("read request.Body failed, err:%v\n", err)        return    }    fmt.Println(string(b))    answer := `{"status": "ok"}`    w.Write([]byte(answer))}</code></pre><h3 id="自定义Client"><a href="#自定义Client" class="headerlink" title="自定义Client"></a>自定义Client</h3><p>要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：</p><pre class=" language-lang-go"><code class="language-lang-go">client := &http.Client{    CheckRedirect: redirectPolicyFunc,}resp, err := client.Get("http://example.com")// ...req, err := http.NewRequest("GET", "http://example.com", nil)// ...req.Header.Add("If-None-Match", `W/"wyzzy"`)resp, err := client.Do(req)// ...</code></pre><h3 id="自定义Transport"><a href="#自定义Transport" class="headerlink" title="自定义Transport"></a>自定义Transport</h3><p>要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：</p><pre class=" language-lang-go"><code class="language-lang-go">tr := &http.Transport{    TLSClientConfig:    &tls.Config{RootCAs: pool},    DisableCompression: true,}client := &http.Client{Transport: tr}resp, err := client.Get("https://example.com")</code></pre><p>Client和Transport类型都可以安全的被多个goroutine同时使用。出于效率考虑，应该一次建立、尽量重用。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="默认的Server"><a href="#默认的Server" class="headerlink" title="默认的Server"></a>默认的Server</h3><p>ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。</p><p>Handle和HandleFunc函数可以向DefaultServeMux添加处理器。</p><pre class=" language-lang-go"><code class="language-lang-go">http.Handle("/foo", fooHandler)http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {    fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))})log.Fatal(http.ListenAndServe(":8080", nil))</code></pre><h3 id="默认的Server示例"><a href="#默认的Server示例" class="headerlink" title="默认的Server示例"></a>默认的Server示例</h3><p>使用Go语言中的<code>net/http</code>包来编写一个简单的接收HTTP请求的Server端示例，<code>net/http</code>包是对net包的进一步封装，专门用来处理HTTP协议的数据。具体的代码如下：</p><pre class=" language-lang-go"><code class="language-lang-go">// http serverfunc sayHello(w http.ResponseWriter, r *http.Request) {    fmt.Fprintln(w, "Hello 康康！")}func main() {    http.HandleFunc("/", sayHello)    err := http.ListenAndServe(":9090", nil)    if err != nil {        fmt.Printf("http server failed, err:%v\n", err)        return    }}</code></pre><p>将上面的代码编译之后执行，打开你电脑上的浏览器在地址栏输入<code>127.0.0.1:9090</code>回车，此时就能够看到如下页面了。<img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20210828190935720.png" alt="image-20210828190935720"></p><h3 id="自定义Server"><a href="#自定义Server" class="headerlink" title="自定义Server"></a>自定义Server</h3><p>要管理服务端的行为，可以创建一个自定义的Server：</p><pre class=" language-lang-go"><code class="language-lang-go">s := &http.Server{    Addr:           ":8080",    Handler:        myHandler,    ReadTimeout:    10 * time.Second,    WriteTimeout:   10 * time.Second,    MaxHeaderBytes: 1 << 20,}log.Fatal(s.ListenAndServe())</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fmt占位符</title>
      <link href="/2021/120325228.html"/>
      <url>/2021/120325228.html</url>
      
        <content type="html"><![CDATA[<h1 id="fmt占位符"><a href="#fmt占位符" class="headerlink" title="fmt占位符"></a>fmt占位符</h1><h2 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h2><div class="table-container"><table><thead><tr><th>%T</th><th>查看类型</th></tr></thead><tbody><tr><td>%v</td><td>查看值</td></tr><tr><td>%p</td><td>查看地址</td></tr><tr><td>%+v</td><td>类似%v，但输出时会添加字段名</td></tr><tr><td>%#v</td><td>值的Go语法表示</td></tr><tr><td>%%</td><td>百分号</td></tr></tbody></table></div><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%t</td><td style="text-align:center">true或false</td></tr></tbody></table></div><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%b</td><td style="text-align:center">表示为二进制</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">该值对应的unicode码值</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">表示为十进制</td></tr><tr><td style="text-align:center">%o</td><td style="text-align:center">表示为八进制</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">表示为十六进制，使用a-f</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">表示为十六进制，使用A-F</td></tr><tr><td style="text-align:center">%U</td><td style="text-align:center">表示为Unicode格式：U+1234，等价于”U+%04X”</td></tr><tr><td style="text-align:center">%q</td><td style="text-align:center">该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td></tr></tbody></table></div><h2 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%b</td><td style="text-align:center">无小数部分、二进制指数的科学计数法，如-123456p-78</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">科学计数法，如-1234.456e+78</td></tr><tr><td style="text-align:center">%E</td><td style="text-align:center">科学计数法，如-1234.456E+78</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">有小数部分但无指数部分，如123.456</td></tr><tr><td style="text-align:center">%F</td><td style="text-align:center">等价于%f</td></tr><tr><td style="text-align:center">%g</td><td style="text-align:center">根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td></tr><tr><td style="text-align:center">%G</td><td style="text-align:center">根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td></tr></tbody></table></div><h2 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h2><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%s</td><td style="text-align:center">直接输出字符串或者[]byte</td></tr><tr><td style="text-align:center">%q</td><td style="text-align:center">该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">每个字节用两字符十六进制数表示（使用a-f</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">每个字节用两字符十六进制数表示（使用A-F）</td></tr></tbody></table></div><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%p</td><td style="text-align:center">表示为十六进制，并加上前导的0x</td></tr></tbody></table></div><h2 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h2><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%f</td><td style="text-align:center">默认宽度，默认精度</td></tr><tr><td style="text-align:center">%9f</td><td style="text-align:center">宽度9，默认精度</td></tr><tr><td style="text-align:center">%.2f</td><td style="text-align:center">默认宽度，精度2</td></tr><tr><td style="text-align:center">%9.2f</td><td style="text-align:center">宽度9，精度2</td></tr><tr><td style="text-align:center">%9.f</td><td style="text-align:center">宽度9，精度0</td></tr></tbody></table></div><h2 id="其他flag"><a href="#其他flag" class="headerlink" title="其他flag"></a>其他flag</h2><div class="table-container"><table><thead><tr><th style="text-align:center">占位符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">’+’</td><td style="text-align:center">总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td></tr><tr><td style="text-align:center">’ ‘</td><td style="text-align:center">对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td></tr><tr><td style="text-align:center">’-’</td><td style="text-align:center">在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td></tr><tr><td style="text-align:center">’#’</td><td style="text-align:center">八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td></tr><tr><td style="text-align:center">‘0’</td><td style="text-align:center">使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fmt包</title>
      <link href="/2021/120327403.html"/>
      <url>/2021/120327403.html</url>
      
        <content type="html"><![CDATA[<h1 id="fmt包"><a href="#fmt包" class="headerlink" title="fmt包"></a>fmt包</h1><p>Go中<code>fmt包</code>实现输入输出类似C语言的I/O</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p><code>Print</code>函数会将内容输出到系统的标准输出</p><ul><li><code>Print</code>直接输出内容</li><li><code>Printf</code>支持格式化输出字符串</li><li><code>Println</code>会在输出内容结尾增加换行符</li></ul><p>三个函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func Print(a ...interface{}) (n int, err error)func Printf(format string, a ...interface{}) (n int, err error)func Println(a ...interface{}) (n int, err error)</code></pre><h3 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h3><p><code>Fprint</code>函数会将内容输出到一个<code>io.Writer</code>接口类型的变量<code>w</code>中，是用于文件处理的函数。</p><p>三个函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func Fprint(w io.Writer, a ...interface{}) (n int, err error)func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)func Fprintln(w io.Writer, a ...interface{}) (n int, err error)</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">// 向标准输出写入内容fmt.Fprintln(os.Stdout, "向标准输出写入内容")// 打开文件fileObj, err := os.OpenFile("./xx.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)if err != nil {    fmt.Println("打开文件出错，err:", err)    return}name := "康康"// 向打开的文件句柄中写入内容fmt.Fprintf(fileObj, "往文件中写入信息：%s", name)</code></pre><blockquote><p>注意：只要满足<code>io.Writer</code>接口的类型都支持写入。</p></blockquote><h3 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h3><p><code>Sprint</code>系列函数会把传入的数据生成并返回一个字符串。</p><p>三个函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func Sprint(a ...interface{}) stringfunc Sprintf(format string, a ...interface{}) stringfunc Sprintln(a ...interface{}) string</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">s1 := fmt.Sprint("康康")name := "康康"age := 18s2 := fmt.Sprintf("name:%s,age:%d", name, age)s3 := fmt.Sprintln("康康")fmt.Println(s1, s2, s3)</code></pre><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><p><code>Errorf</code>函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p><pre class=" language-lang-go"><code class="language-lang-go">func Errorf(format string, a ...interface{}) error</code></pre><p>通常使用这种方式来自定义错误类型，例如：</p><pre class=" language-lang-go"><code class="language-lang-go">err := fmt.Errorf("这是一个错误")</code></pre><blockquote><p>Go1.13版本为<code>fmt.Errorf</code>函数新加了一个<code>%w</code>占位符用来生成一个可以包裹Error的Wrapping Error。</p><pre class=" language-lang-go"><code class="language-lang-go">e := errors.New("原始错误e")w := fmt.Errorf("Wrap了一个错误%w", e)</code></pre></blockquote><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="mt-Scan"><a href="#mt-Scan" class="headerlink" title="mt.Scan"></a>mt.Scan</h3><p>函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func Scan(a ...interface{}) (n int, err error)</code></pre><ul><li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var (        name    string        age     int        married bool    )    fmt.Scan(&name, &age, &married)    fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)}</code></pre><p><code>fmt.Scan</code>从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</p><h3 id="fmt-Scanf"><a href="#fmt-Scanf" class="headerlink" title="fmt.Scanf"></a>fmt.Scanf</h3><p>函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func Scanf(format string, a ...interface{}) (n int, err error)</code></pre><ul><li>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var (        name    string        age     int        married bool    )    fmt.Scanf("1:%s 2:%d 3:%t", &name, &age, &married)    fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)}</code></pre><p><code>fmt.Scanf</code>不同于<code>fmt.Scan</code>简单的以空格作为输入数据的分隔符，<code>fmt.Scanf</code>为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。</p><p>比如此时要输入数据应该输入</p><pre class=" language-lang-go"><code class="language-lang-go">1:康康 2：17 3:false</code></pre><h3 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h3><p>函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func Scanln(a ...interface{}) (n int, err error)</code></pre><ul><li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li><li>本函数返回成功扫描的数据个数和遇到的任何错误。</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var (        name    string        age     int        married bool    )    fmt.Scanln(&name, &age, &married)    fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)}</code></pre><p><code>fmt.Scanln</code>遇到回车就结束扫描</p><h3 id="bufio-NewReader"><a href="#bufio-NewReader" class="headerlink" title="bufio.NewReader"></a>bufio.NewReader</h3><p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用<code>bufio</code>包来实现。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func bufioDemo() {    reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象    fmt.Print("请输入内容：")    text, _ := reader.ReadString('\n') // 读到换行    text = strings.TrimSpace(text)    fmt.Printf("%#v\n", text)}</code></pre><h3 id="Fscan系列"><a href="#Fscan系列" class="headerlink" title="Fscan系列"></a>Fscan系列</h3><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从<code>io.Reader</code>中读取数据。</p><pre class=" language-lang-go"><code class="language-lang-go">func Fscan(r io.Reader, a ...interface{}) (n int, err error)func Fscanln(r io.Reader, a ...interface{}) (n int, err error)func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)</code></pre><h3 id="Sscan系列"><a href="#Sscan系列" class="headerlink" title="Sscan系列"></a>Sscan系列</h3><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p><pre class=" language-lang-go"><code class="language-lang-go">func Sscan(str string, a ...interface{}) (n int, err error)func Sscanln(str string, a ...interface{}) (n int, err error)func Sscanf(str string, format string, a ...interface{}) (n int, err error)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flag包</title>
      <link href="/2021/120316921.html"/>
      <url>/2021/120316921.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言标准库flag基本使用"><a href="#Go语言标准库flag基本使用" class="headerlink" title="Go语言标准库flag基本使用"></a>Go语言标准库flag基本使用</h1><p>Go语言内置的<code>flag</code>包实现了命令行参数的解析，<code>flag</code>包使得开发命令行工具更为简单。</p><h2 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h2><p>如果只是简单的想要获取命令行参数，可以像下面的代码示例一样使用<code>os.Args</code>来获取命令行参数。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "os")//os.Args demofunc main() {    //os.Args是一个[]string    if len(os.Args) > 0 {        for index, arg := range os.Args {            fmt.Printf("args[%d]=%v\n", index, arg)        }    }}</code></pre><p>将上面的代码执行<code>go build -o "args_demo"</code>编译之后，执行：</p><pre class=" language-lang-bash"><code class="language-lang-bash">$ ./args_demo a b c dargs[0]=./args_demoargs[1]=aargs[2]=bargs[3]=cargs[4]=d</code></pre><p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p><h2 id="flag包基本使用"><a href="#flag包基本使用" class="headerlink" title="flag包基本使用"></a>flag包基本使用</h2><p>本文介绍了flag包的常用函数和基本用法，更详细的内容请查看<a href="https://studygolang.com/pkgdoc">官方文档</a>。</p><h3 id="导入flag包"><a href="#导入flag包" class="headerlink" title="导入flag包"></a>导入flag包</h3><pre class=" language-lang-go"><code class="language-lang-go">import flag</code></pre><h3 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h3><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">flag参数</th><th style="text-align:center">有效值</th></tr></thead><tbody><tr><td style="text-align:center">字符串flag</td><td style="text-align:center">合法字符串</td></tr><tr><td style="text-align:center">整数flag</td><td style="text-align:center">1234、0664、0x1234等类型，也可以是负数。</td></tr><tr><td style="text-align:center">浮点数flag</td><td style="text-align:center">合法浮点数</td></tr><tr><td style="text-align:center">bool类型flag</td><td style="text-align:center">1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td></tr><tr><td style="text-align:center">时间段flag</td><td style="text-align:center">任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。</td></tr></tbody></table></div><h3 id="定义命令行flag参数"><a href="#定义命令行flag参数" class="headerlink" title="定义命令行flag参数"></a>定义命令行flag参数</h3><p>有以下两种常用的定义命令行<code>flag</code>参数的方法。</p><h4 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h4><p>基本格式如下：</p><p><code>flag.Type(flag名, 默认值, 帮助信息)*Type</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><pre class=" language-lang-go"><code class="language-lang-go">name := flag.String("name", "张三", "姓名")age := flag.Int("age", 18, "年龄")married := flag.Bool("married", false, "婚否")delay := flag.Duration("d", 0, "时间间隔")</code></pre><p>需要注意的是，此时<code>name</code>、<code>age</code>、<code>married</code>、<code>delay</code>均为对应类型的指针。</p><h4 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h4><p>基本格式如下： <code>flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</code> 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：</p><pre class=" language-lang-go"><code class="language-lang-go">var name stringvar age intvar married boolvar delay time.Durationflag.StringVar(&name, "name", "张三", "姓名")flag.IntVar(&age, "age", 18, "年龄")flag.BoolVar(&married, "married", false, "婚否")flag.DurationVar(&delay, "d", 0, "时间间隔")</code></pre><h3 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h3><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p><p>支持的命令行参数格式有以下几种：</p><ul><li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li><li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li><li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li><li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li></ul><p>其中，布尔类型的参数必须使用等号的方式指定。</p><p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p><h3 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h3><pre class=" language-lang-go"><code class="language-lang-go">flag.Args()  ////返回命令行参数后的其他参数，以[]string类型flag.NArg()  //返回命令行参数后的其他参数个数flag.NFlag() //返回使用的命令行参数个数</code></pre><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><pre class=" language-lang-go"><code class="language-lang-go">func main() {    //定义命令行参数方式1    var name string    var age int    var married bool    var delay time.Duration    flag.StringVar(&name, "name", "张三", "姓名")    flag.IntVar(&age, "age", 18, "年龄")    flag.BoolVar(&married, "married", false, "婚否")    flag.DurationVar(&delay, "d", 0, "延迟的时间间隔")    //解析命令行参数    flag.Parse()    fmt.Println(name, age, married, delay)    //返回命令行参数后的其他参数    fmt.Println(flag.Args())    //返回命令行参数后的其他参数个数    fmt.Println(flag.NArg())    //返回使用的命令行参数个数    fmt.Println(flag.NFlag())}</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>命令行参数使用提示：</p><pre class=" language-lang-bash"><code class="language-lang-bash">$ ./flag_demo -helpUsage of ./flag_demo:  -age int        年龄 (default 18)  -d duration        时间间隔  -married        婚否  -name string        姓名 (default "张三")</code></pre><p>正常使用命令行flag参数：</p><pre class=" language-lang-bash"><code class="language-lang-bash">$ ./flag_demo -name 沙河娜扎 --age 28 -married=false -d=1h30m沙河娜扎 28 false 1h30m0s[]04</code></pre><p>使用非flag命令行参数：</p><pre class=" language-lang-bash"><code class="language-lang-bash">$ ./flag_demo a b c张三 18 false 0s[a b c]30</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>context包</title>
      <link href="/2021/120331663.html"/>
      <url>/2021/120331663.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go标准库Context"><a href="#Go标准库Context" class="headerlink" title="Go标准库Context"></a>Go标准库Context</h1><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><h2 id="为什么需要Context"><a href="#为什么需要Context" class="headerlink" title="为什么需要Context"></a>为什么需要Context</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "sync"    "time")var wg sync.WaitGroup// 初始的例子func worker() {    for {        fmt.Println("worker")        time.Sleep(time.Second)    }    // 如何接收外部命令实现退出    wg.Done()}func main() {    wg.Add(1)    go worker()    // 如何优雅的实现结束子goroutine    wg.Wait()    fmt.Println("over")}</code></pre><h3 id="全局变量方式"><a href="#全局变量方式" class="headerlink" title="全局变量方式"></a>全局变量方式</h3><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "sync"    "time")var wg sync.WaitGroupvar exit bool// 全局变量方式存在的问题：// 1. 使用全局变量在跨包调用时不容易统一// 2. 如果worker中再启动goroutine，就不太好控制了。func worker() {    for {        fmt.Println("worker")        time.Sleep(time.Second)        if exit {            break        }    }    wg.Done()}func main() {    wg.Add(1)    go worker()    time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出    exit = true                 // 修改全局变量实现子goroutine的退出    wg.Wait()    fmt.Println("over")}</code></pre><h3 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h3><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "sync"    "time")var wg sync.WaitGroup// 管道方式存在的问题：// 1. 使用全局变量在跨包调用时不容易实现规范和统一，需要维护一个共用的channelfunc worker(exitChan chan struct{}) {LOOP:    for {        fmt.Println("worker")        time.Sleep(time.Second)        select {        case <-exitChan: // 等待接收上级通知            break LOOP        default:        }    }    wg.Done()}func main() {    var exitChan = make(chan struct{})    wg.Add(1)    go worker(exitChan)    time.Sleep(time.Second * 3) // sleep3秒以免程序过快退出    exitChan <- struct{}{}      // 给子goroutine发送退出信号    close(exitChan)    wg.Wait()    fmt.Println("over")}</code></pre><h3 id="官方版的方案"><a href="#官方版的方案" class="headerlink" title="官方版的方案"></a>官方版的方案</h3><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "context"    "fmt"    "sync"    "time")var wg sync.WaitGroupfunc worker(ctx context.Context) {LOOP:    for {        fmt.Println("worker")        time.Sleep(time.Second)        select {        case <-ctx.Done(): // 等待上级通知            break LOOP        default:        }    }    wg.Done()}func main() {    ctx, cancel := context.WithCancel(context.Background())    wg.Add(1)    go worker(ctx)    time.Sleep(time.Second * 3)    cancel() // 通知子goroutine结束    wg.Wait()    fmt.Println("over")}</code></pre><p>当子goroutine又开启另外一个goroutine时，只需要将ctx传入即可：</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "context"    "fmt"    "sync"    "time")var wg sync.WaitGroupfunc worker(ctx context.Context) {    go worker2(ctx)LOOP:    for {        fmt.Println("worker")        time.Sleep(time.Second)        select {        case <-ctx.Done(): // 等待上级通知            break LOOP        default:        }    }    wg.Done()}func worker2(ctx context.Context) {LOOP:    for {        fmt.Println("worker2")        time.Sleep(time.Second)        select {        case <-ctx.Done(): // 等待上级通知            break LOOP        default:        }    }}func main() {    ctx, cancel := context.WithCancel(context.Background())    wg.Add(1)    go worker(ctx)    time.Sleep(time.Second * 3)    cancel() // 通知子goroutine结束    wg.Wait()    fmt.Println("over")}</code></pre><h2 id="Context初识"><a href="#Context初识" class="headerlink" title="Context初识"></a>Context初识</h2><p>Go1.7加入了一个新的标准库<code>context</code>，它定义了<code>Context</code>类型，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p><h2 id="Context接口"><a href="#Context接口" class="headerlink" title="Context接口"></a>Context接口</h2><p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p><pre class=" language-lang-go"><code class="language-lang-go">type Context interface {    Deadline() (deadline time.Time, ok bool)    Done() <-chan struct{}    Err() error    Value(key interface{}) interface{}}</code></pre><p>其中：</p><ul><li><p><code>Deadline</code>方法需要返回当前<code>Context</code>被取消的时间，也就是完成工作的截止时间（deadline）；</p></li><li><p><code>Done</code>方法需要返回一个<code>Channel</code>，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用<code>Done</code>方法会返回同一个Channel；</p></li><li><pre><code>Err</code></pre><p>方法会返回当前</p><pre><code>Context</code></pre><p>结束的原因，它只会在</p><pre><code>Done</code></pre><p>返回的Channel被关闭时才会返回非空的值；</p><ul><li>如果当前<code>Context</code>被取消就会返回<code>Canceled</code>错误；</li><li>如果当前<code>Context</code>超时就会返回<code>DeadlineExceeded</code>错误；</li></ul></li><li><p><code>Value</code>方法会从<code>Context</code>中返回键对应的值，对于同一个上下文来说，多次调用<code>Value</code> 并传入相同的<code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p></li></ul><h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><p>Go内置两个函数：<code>Background()</code>和<code>TODO()</code>，这两个函数分别返回一个实现了<code>Context</code>接口的<code>background</code>和<code>todo</code>。我们代码中最开始都是以这两个内置的上下文对象作为最顶层的<code>partent context</code>，衍生出更多的子上下文对象。</p><p><code>Background()</code>主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</p><p><code>TODO()</code>，它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</p><p><code>background</code>和<code>todo</code>本质上都是<code>emptyCtx</code>结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p><h2 id="With系列函数"><a href="#With系列函数" class="headerlink" title="With系列函数"></a>With系列函数</h2><p>此外，<code>context</code>包中还定义了四个With系列函数。</p><h3 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a>WithCancel</h3><p><code>WithCancel</code>的函数签名如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></pre><p><code>WithCancel</code>返回带有新Done通道的父节点的副本。当调用返回的cancel函数或当关闭父上下文的Done通道时，将关闭返回上下文的Done通道，无论先发生什么情况。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><pre class=" language-lang-go"><code class="language-lang-go">func gen(ctx context.Context) <-chan int {        dst := make(chan int)        n := 1        go func() {            for {                select {                case <-ctx.Done():                    return // return结束该goroutine，防止泄露                case dst <- n:                    n++                }            }        }()        return dst    }func main() {    ctx, cancel := context.WithCancel(context.Background())    defer cancel() // 当我们取完需要的整数后调用cancel    for n := range gen(ctx) {        fmt.Println(n)        if n == 5 {            break        }    }}</code></pre><p>上面的示例代码中，<code>gen</code>函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免<code>gen</code>启动的内部goroutine发生泄漏。</p><h3 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a>WithDeadline</h3><p><code>WithDeadline</code>的函数签名如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</code></pre><p>返回父上下文的副本，并将deadline调整为不迟于d。如果父上下文的deadline已经早于d，则WithDeadline(parent, d)在语义上等同于父上下文。当截止日过期时，当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p><p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    d := time.Now().Add(50 * time.Millisecond)    ctx, cancel := context.WithDeadline(context.Background(), d)    // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。    // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。    defer cancel()    select {    case <-time.After(1 * time.Second):        fmt.Println("overslept")    case <-ctx.Done():        fmt.Println(ctx.Err())    }}</code></pre><p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印<code>overslept</code>退出或者等待ctx过期后退出。</p><p>在上面的示例代码中，因为ctx 50毫秒后就会过期，所以<code>ctx.Done()</code>会先接收到context到期通知，并且会打印ctx.Err()的内容。</p><h3 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a>WithTimeout</h3><p><code>WithTimeout</code>的函数签名如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code></pre><p><code>WithTimeout</code>返回<code>WithDeadline(parent, time.Now().Add(timeout))</code>。</p><p>取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。具体示例如下：</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "context"    "fmt"    "sync"    "time")// context.WithTimeoutvar wg sync.WaitGroupfunc worker(ctx context.Context) {LOOP:    for {        fmt.Println("db connecting ...")        time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒        select {        case <-ctx.Done(): // 50毫秒后自动调用            break LOOP        default:        }    }    fmt.Println("worker done!")    wg.Done()}func main() {    // 设置一个50毫秒的超时    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)    wg.Add(1)    go worker(ctx)    time.Sleep(time.Second * 5)    cancel() // 通知子goroutine结束    wg.Wait()    fmt.Println("over")}</code></pre><h3 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a>WithValue</h3><p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func WithValue(parent Context, key, val interface{}) Context</code></pre><p><code>WithValue</code>返回父节点的副本，其中与key关联的值为val。</p><p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p><p>所提供的键必须是可比较的，并且不应该是<code>string</code>类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型<code>struct{}</code>。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "context"    "fmt"    "sync"    "time")// context.WithValuetype TraceCode stringvar wg sync.WaitGroupfunc worker(ctx context.Context) {    key := TraceCode("TRACE_CODE")    traceCode, ok := ctx.Value(key).(string) // 在子goroutine中获取trace code    if !ok {        fmt.Println("invalid trace code")    }LOOP:    for {        fmt.Printf("worker, trace code:%s\n", traceCode)        time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒        select {        case <-ctx.Done(): // 50毫秒后自动调用            break LOOP        default:        }    }    fmt.Println("worker done!")    wg.Done()}func main() {    // 设置一个50毫秒的超时    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)    // 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合    ctx = context.WithValue(ctx, TraceCode("TRACE_CODE"), "12512312234")    wg.Add(1)    go worker(ctx)    time.Sleep(time.Second * 5)    cancel() // 通知子goroutine结束    wg.Wait()    fmt.Println("over")}</code></pre><h2 id="使用Context的注意事项"><a href="#使用Context的注意事项" class="headerlink" title="使用Context的注意事项"></a>使用Context的注意事项</h2><ul><li>推荐以参数的方式显示传递Context</li><li>以Context作为参数的函数方法，应该把Context作为第一个参数。</li><li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li><li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li><li>Context是线程安全的，可以放心的在多个goroutine中传递</li></ul><h2 id="客户端超时取消示例"><a href="#客户端超时取消示例" class="headerlink" title="客户端超时取消示例"></a>客户端超时取消示例</h2><p>调用服务端API时如何在客户端实现超时控制？</p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><pre class=" language-lang-go"><code class="language-lang-go">// context_timeout/server/main.gopackage mainimport (    "fmt"    "math/rand"    "net/http"    "time")// server端，随机出现慢响应func indexHandler(w http.ResponseWriter, r *http.Request) {    number := rand.Intn(2)    if number == 0 {        time.Sleep(time.Second * 10) // 耗时10秒的慢响应        fmt.Fprintf(w, "slow response")        return    }    fmt.Fprint(w, "quick response")}func main() {    http.HandleFunc("/", indexHandler)    err := http.ListenAndServe(":8000", nil)    if err != nil {        panic(err)    }}</code></pre><h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><pre class=" language-lang-go"><code class="language-lang-go">// context_timeout/client/main.gopackage mainimport (    "context"    "fmt"    "io/ioutil"    "net/http"    "sync"    "time")// 客户端type respData struct {    resp *http.Response    err  error}func doCall(ctx context.Context) {    transport := http.Transport{       // 请求频繁可定义全局的client对象并启用长链接       // 请求不频繁使用短链接       DisableKeepAlives: true,     }    client := http.Client{        Transport: &transport,    }    respChan := make(chan *respData, 1)    req, err := http.NewRequest("GET", "http://127.0.0.1:8000/", nil)    if err != nil {        fmt.Printf("new requestg failed, err:%v\n", err)        return    }    req = req.WithContext(ctx) // 使用带超时的ctx创建一个新的client request    var wg sync.WaitGroup    wg.Add(1)    defer wg.Wait()    go func() {        resp, err := client.Do(req)        fmt.Printf("client.do resp:%v, err:%v\n", resp, err)        rd := &respData{            resp: resp,            err:  err,        }        respChan <- rd        wg.Done()    }()    select {    case <-ctx.Done():        //transport.CancelRequest(req)        fmt.Println("call api timeout")    case result := <-respChan:        fmt.Println("call server api success")        if result.err != nil {            fmt.Printf("call server api failed, err:%v\n", result.err)            return        }        defer result.resp.Body.Close()        data, _ := ioutil.ReadAll(result.resp.Body)        fmt.Printf("resp:%v\n", string(data))    }}func main() {    // 定义一个100毫秒的超时    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)    defer cancel() // 调用cancel释放子goroutine资源    doCall(ctx)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件属性filemode</title>
      <link href="/2021/120347090.html"/>
      <url>/2021/120347090.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><ul><li><p>-表示普通文件</p></li><li><p>r表示可读</p></li><li><p>w表示可写</p></li><li><p>x表示可执行</p></li></ul><p>然后各个位置表示对应的用户权限，可以参考下面这段东西</p><pre class=" language-lang-text"><code class="language-lang-text">一般都文件属性标识如下： -rwxrwxrwx第1位：文件属性，一般常用的是"-"，表示是普通文件；"d"表示是一个目录。第2～4位：文件所有者的权限rwx (可读/可写/可执行)。第5～7位：文件所属用户组的权限rwx (可读/可写/可执行)。第8～10位：其他人的权限rwx (可读/可写/可执行)。在golang中，可以使用os.FileMode(perm).String()来查看权限标识：os.FileMode(0777).String()    //返回 -rwxrwxrwxos.FileMode(0666).String()   //返回 -rw-rw-rw-os.FileMode(0644).String()   //返回 -rw-r--r--0777表示：创建了一个普通文件，所有人拥有所有的读、写、执行权限0666表示：创建了一个普通文件，所有人拥有对该文件的读、写权限，但是都不可执行0644表示：创建了一个普通文件，文件所有者对该文件有读写权限，用户组和其他人只有读权限，都没有执行权限</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/2021/120316177.html"/>
      <url>/2021/120316177.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言文件操作"><a href="#Go语言文件操作" class="headerlink" title="Go语言文件操作"></a>Go语言文件操作</h1><p>本文主要介绍了Go语言中文件读写的相关操作。</p><p>文件是什么？</p><p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "os")func main() {    // 只读方式打开当前目录下的main.go文件    file, err := os.Open("./main.go")    if err != nil {        fmt.Println("open file failed!, err:", err)        return    }    // 关闭文件    file.Close()}</code></pre><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><h3 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Read方法定义如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func (f *File) Read(b []byte) (n int, err error)</code></pre><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    // 只读方式打开当前目录下的main.go文件    file, err := os.Open("./main.go")    if err != nil {        fmt.Println("open file failed!, err:", err)        return    }    defer file.Close()    // 使用Read方法读取数据    var tmp = make([]byte, 128)    n, err := file.Read(tmp)    if err == io.EOF {        fmt.Println("文件读完了")        return    }    if err != nil {        fmt.Println("read file failed, err:", err)        return    }    fmt.Printf("读取了%d字节数据\n", n)    fmt.Println(string(tmp[:n]))}</code></pre><h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h4><p>使用for循环读取文件中的所有数据。</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    // 只读方式打开当前目录下的main.go文件    file, err := os.Open("./main.go")    if err != nil {        fmt.Println("open file failed!, err:", err)        return    }    defer file.Close()    // 循环读取文件    var content []byte    var tmp = make([]byte, 128)    for {        n, err := file.Read(tmp)        if err == io.EOF {            fmt.Println("文件读完了")            break        }        if err != nil {            fmt.Println("read file failed, err:", err)            return        }        content = append(content, tmp[:n]...)    }    fmt.Println(string(content))}</code></pre><h3 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h3><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "bufio"    "fmt"    "io"    "os")// bufio按行读取示例func main() {    //打开文件    file, err := os.Open("./xx.txt")    if err != nil {        fmt.Println("open file failed, err:", err)        return    }    defer file.Close()    //读取文件    reader := bufio.NewReader(file)    for {        line, err := reader.ReadString('\n') //注意是字符        if err == io.EOF {            if len(line) != 0 {                fmt.Println(line)            }            fmt.Println("文件读完了")            break        }        if err != nil {            fmt.Println("read file failed, err:", err)            return        }        fmt.Print(line)    }}</code></pre><h3 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h3><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "io/ioutil")// ioutil.ReadFile读取整个文件func main() {    content, err := ioutil.ReadFile("./main.go")    if err != nil {        fmt.Println("read file failed, err:", err)        return    }    fmt.Println(string(content))}</code></pre><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><pre class=" language-lang-go"><code class="language-lang-go">func OpenFile(name string, flag int, perm FileMode) (*File, error) {    ...}</code></pre><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>os.O_WRONLY</code></td><td style="text-align:center">只写</td></tr><tr><td style="text-align:center"><code>os.O_CREATE</code></td><td style="text-align:center">创建文件</td></tr><tr><td style="text-align:center"><code>os.O_RDONLY</code></td><td style="text-align:center">只读</td></tr><tr><td style="text-align:center"><code>os.O_RDWR</code></td><td style="text-align:center">读写</td></tr><tr><td style="text-align:center"><code>os.O_TRUNC</code></td><td style="text-align:center">清空</td></tr><tr><td style="text-align:center"><code>os.O_APPEND</code></td><td style="text-align:center">追加</td></tr></tbody></table></div><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h3 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h3><pre class=" language-lang-go"><code class="language-lang-go">func main() {    //打开文件    file, err := os.OpenFile("xx.txt", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)    if err != nil {        fmt.Println("open file failed, err:", err)        return    }    defer file.Close()    //写入数据    str := "hello 武子"    file.Write([]byte(str))       //写入字节切片数据    file.WriteString("hello 康康") //直接写入字符串数据}</code></pre><h3 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h3><pre class=" language-lang-go"><code class="language-lang-go">func main() {    //打开文件    file, err := os.OpenFile("xx.txt", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)    if err != nil {        fmt.Println("open file failed, err:", err)        return    }    defer file.Close()    //写入数据    writer := bufio.NewWriter(file)    for i := 0; i < 10; i++ {        writer.WriteString("hello 康康\n") //将数据先写入缓存    }    writer.Flush() //将缓存中的内容写入文件}</code></pre><h3 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h3><pre class=" language-lang-go"><code class="language-lang-go">func main() {    str := "hello 沙河"    err := ioutil.WriteFile("./xx.txt", []byte(str), 0666)    if err != nil {        fmt.Println("write file failed, err:", err)        return    }}</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h3><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><pre class=" language-lang-go"><code class="language-lang-go">// CopyFile 拷贝文件函数func CopyFile(dstName, srcName string) (written int64, err error) {    // 以读方式打开源文件    src, err := os.Open(srcName)    if err != nil {        fmt.Printf("open %s failed, err:%v.\n", srcName, err)        return    }    defer src.Close()    // 以写|创建的方式打开目标文件    dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)    if err != nil {        fmt.Printf("open %s failed, err:%v.\n", dstName, err)        return    }    defer dst.Close()    return io.Copy(dst, src) //调用io.Copy()拷贝内容}func main() {    _, err := CopyFile("dst.txt", "src.txt")    if err != nil {        fmt.Println("copy file failed, err:", err)        return    }    fmt.Println("copy done!")}</code></pre><h3 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h3><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "bufio"    "flag"    "fmt"    "io"    "os")// cat命令实现func cat(r *bufio.Reader) {    for {        buf, err := r.ReadBytes('\n') //注意是字符        if err == io.EOF {            // 退出之前将已读到的内容输出            fmt.Fprintf(os.Stdout, "%s", buf)            break        }        fmt.Fprintf(os.Stdout, "%s", buf)    }}func main() {    flag.Parse() // 解析命令行参数    if flag.NArg() == 0 {        // 如果没有参数默认从标准输入读取内容        cat(bufio.NewReader(os.Stdin))    }    // 依次读取每个指定文件的内容并打印到终端    for i := 0; i < flag.NArg(); i++ {        f, err := os.Open(flag.Arg(i))        if err != nil {            fmt.Fprintf(os.Stdout, "reading from %s failed, err:%v\n", flag.Arg(i), err)            continue        }        cat(bufio.NewReader(f))    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机数</title>
      <link href="/2021/120324120.html"/>
      <url>/2021/120324120.html</url>
      
        <content type="html"><![CDATA[<h2 id="GO获取随机数"><a href="#GO获取随机数" class="headerlink" title="GO获取随机数"></a>GO获取随机数</h2><p>使用的”math/rand”包。</p><h3 id="基本随机数"><a href="#基本随机数" class="headerlink" title="基本随机数"></a><strong>基本随机数</strong></h3><pre class=" language-lang-go"><code class="language-lang-go">a := rand.Int()b := rand.Intn(100)  //生成0-99之间的随机数fmt.Println(a)fmt.Println(b)</code></pre><p>可以生成随机数，但是数值不会变。</p><h3 id="生成可变随机数"><a href="#生成可变随机数" class="headerlink" title="生成可变随机数"></a><strong>生成可变随机数</strong></h3><pre class=" language-lang-go"><code class="language-lang-go">//将时间戳设置成种子数rand.Seed(time.Now().UnixNano())//生成10个0-99之间的随机数for i:=0;i<10;i++{    fmt.Println(rand.Intn(100))}</code></pre><h3 id="生成指定范围内的随机数"><a href="#生成指定范围内的随机数" class="headerlink" title="生成指定范围内的随机数"></a><strong>生成指定范围内的随机数</strong></h3><pre class=" language-lang-go"><code class="language-lang-go">//生成[15，88]之间的随机数,括号左包含右不包含n:=rand.Intn(73)+15 //(88-15 )+15fmt.Println(n)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 标准库的基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 标准库的基础使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入Golang调度器之GMP模型</title>
      <link href="/2021/120325221.html"/>
      <url>/2021/120325221.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入Golang调度器之GMP模型"><a href="#深入Golang调度器之GMP模型" class="headerlink" title="深入Golang调度器之GMP模型"></a>深入Golang调度器之GMP模型</h1><blockquote><p> 作者：sunsky303</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着服务器硬件迭代升级，配置也越来越高。为充分利用服务器资源，并发编程也变的越来越重要。在开始之前，需要了解一下并发(concurrency)和并行(parallesim)的区别。</p><p><strong>并发:</strong> 逻辑上具有处理多个同时性任务的能力。</p><p><strong>并行:</strong>  物理上同一时刻执行多个并发任务。</p><p>通常所说的并发编程，也就是说它允许多个任务同时执行，但实际上并不一定在同一时刻被执行。在单核处理器上，通过多线程共享CPU时间片串行执行(并发非并行)。而并行则依赖于多核处理器等物理资源，让多个任务可以实现并行执行(并发且并行)。</p><p>多线程或多进程是并行的基本条件，但单线程也可以用协程(coroutine)做到并发。简单将Goroutine归纳为协程并不合适，因为它运行时会创建多个线程来执行并发任务，且任务单元可被调度到其它线程执行。这更像是多线程和协程的结合体，能最大限度提升执行效率，发挥多核处理器能力。</p><p>Go编写一个并发编程程序很简单，只需要在函数之前使用一个Go关键字就可以实现并发编程。</p><pre><code>func main() {    go func(){        fmt.Println("Hello,World!")    }()}</code></pre><p>Go调度器组成</p><p>Go语言虽然使用一个Go关键字即可实现并发编程，但Goroutine被调度到后端之后，具体的实现比较复杂。先看看调度器有哪几部分组成。</p><p> <strong>1、G</strong></p><p>G是Goroutine的缩写，相当于操作系统中的进程控制块，在这里就是Goroutine的控制结构，是对Goroutine的抽象。其中包括执行的函数指令及参数；G保存的任务对象；线程上下文切换，现场保护和现场恢复需要的寄存器(SP、IP)等信息。</p><p>Go不同版本Goroutine默认栈大小不同。</p><pre><code>// Go1.11版本默认stack大小为2KB_StackMin = 2048 // 创建一个g对象,然后放到g队列// 等待被执行func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) {    _g_ := getg()    _g_.m.locks++    siz := narg    siz = (siz + 7) &amp;^ 7    _p_ := _g_.m.p.ptr()    newg := gfget(_p_)        if newg == nil {               // 初始化g stack大小        newg = malg(_StackMin)        casgstatus(newg, _Gidle, _Gdead)        allgadd(newg)    }        // 以下省略}</code></pre><p><strong>2、M</strong></p><p>M是一个线程或称为Machine，所有M是有线程栈的。如果不对该线程栈提供内存的话，系统会给该线程栈提供内存(不同操作系统提供的线程栈大小不同)。当指定了线程栈，则M.stack→G.stack，M的PC寄存器指向G提供的函数，然后去执行。</p><pre><code>type m struct {        /*        1.  所有调用栈的Goroutine,这是一个比较特殊的Goroutine。        2.  普通的Goroutine栈是在Heap分配的可增长的stack,而g0的stack是M对应的线程栈。        3.  所有调度相关代码,会先切换到该Goroutine的栈再执行。    */    g0       *g    curg     *g         // M当前绑定的结构体G    // SP、PC寄存器用于现场保护和现场恢复    vdsoSP uintptr    vdsoPC uintptr    // 省略…}</code></pre><p><strong>3、P</strong></p><p>P(Processor)是一个抽象的概念，并不是真正的物理CPU。所以当P有任务时需要创建或者唤醒一个系统线程来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元。</p><p>P决定了同时可以并发任务的数量，可通过GOMAXPROCS限制同时执行用户级任务的操作系统线程。可以通过runtime.GOMAXPROCS进行指定。在Go1.5之后GOMAXPROCS被默认设置可用的核数，而之前则默认为1。</p><pre><code>// 自定义设置GOMAXPROCS数量func GOMAXPROCS(n int) int {        /*        1.  GOMAXPROCS设置可执行的CPU的最大数量,同时返回之前的设置。        2.  如果n &lt; 1,则不更改当前的值。    */    ret := int(gomaxprocs)    stopTheWorld("GOMAXPROCS")        // startTheWorld启动时,使用newprocs。    newprocs = int32(n)    startTheWorld()        return ret}// 默认P被绑定到所有CPU核上// P == cpu.coresfunc getproccount() int32 {        const maxCPUs = 64 * 1024    var buf [maxCPUs / 8]byte    // 获取CPU Core    r := sched_getaffinity(0, unsafe.Sizeof(buf), &amp;buf[0])    n := int32(0)        for _, v := range buf[:r] {               for v != 0 {            n += int32(v &amp; 1)            v &gt;&gt;= 1        }    }        if n == 0 {       n = 1    }        return n}// 一个进程默认被绑定在所有CPU核上,返回所有CPU core。// 获取进程的CPU亲和性掩码系统调用// rax 204                          ; 系统调用码// system_call sys_sched_getaffinity; 系统调用名称// rid  pid                         ; 进程号// rsi unsigned int len             // rdx unsigned long *user_mask_ptrsys_linux_amd64.s:TEXT runtime·sched_getaffinity(SB),NOSPLIT,$0    MOVQ    pid+0(FP), DI    MOVQ    len+8(FP), SI    MOVQ    buf+16(FP), DX    MOVL    $SYS_sched_getaffinity, AX    SYSCALL    MOVL    AX, ret+24(FP)    RET</code></pre><p>Go调度器调度过程</p><p>首先创建一个G对象，G对象保存到P本地队列或者是全局队列。P此时去唤醒一个M。P继续执行它的执行序。M寻找是否有空闲的P，如果有则将该G对象移动到它本身。接下来M执行一个调度循环(调用G对象-&gt;执行-&gt;清理线程→继续找新的Goroutine执行)。</p><p>M执行过程中，随时会发生上下文切换。当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go调度器M的栈保存在G对象上，只需要将M所需要的寄存器(SP、PC等)保存到G对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时G任务还没有执行完，M可以将任务重新丢到P的任务队列，等待下一次被调度执行。当再次被调度执行时，M通过访问G的vdsoSP、vdsoPC寄存器进行现场恢复(从上次中断位置继续执行)。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><p><strong>1、P 队列</strong><br>通过上图可以发现，P有两种队列：本地队列和全局队列。</p><ul><li><strong>本地队列：</strong> 当前P的队列，本地队列是Lock-Free，没有数据竞争问题，无需加锁处理，可以提升处理速度。</li><li><strong>全局队列：</strong>全局队列为了保证多个P之间任务的平衡。所有M共享P全局队列，为保证数据竞争问题，需要加锁处理。相比本地队列处理速度要低于全局队列。</li></ul><p>2、<strong>上线文切换</strong></p><p>简单理解为当时的环境即可，环境可以包括当时程序状态以及变量状态。例如线程切换的时候在内核会发生上下文切换，这里的上下文就包括了当时寄存器的值，把寄存器的值保存起来，等下次该线程又得到cpu时间的时候再恢复寄存器的值，这样线程才能正确运行。</p><p>对于代码中某个值说，上下文是指这个值所在的局部(全局)作用域对象。相对于进程而言，上下文就是进程执行时的环境，具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存(堆栈)信息等。</p><p><strong>3、线程清理</strong><br>Goroutine被调度执行必须保证P/M进行绑定，所以线程清理只需要将P释放就可以实现线程的清理。什么时候P会释放，保证其它G可以被执行。P被释放主要有两种情况。</p><ul><li>主动释放：最典型的例子是，当执行G任务时有系统调用，当发生系统调用时M会处于Block状态。调度器会设置一个超时时间，当超时时会将P释放。</li><li><strong>被动释放：</strong>如果发生系统调用，有一个专门监控程序，进行扫描当前处于阻塞的P/M组合。当超过系统程序设置的超时时间，会自动将P资源抢走。去执行队列的其它G任务。</li></ul><p>终于要来说说Golang中最吸引人的goroutine了，这也是Golang能够横空出世的主要原因。不同于Python基于进程的并发模型，以及C++、Java等基于线程的并发模型。Golang采用轻量级的goroutine来实现并发，可以大大减少CPU的切换。现在已经有太多的文章来介绍goroutine的用法，在这里，我们从源码的角度来看看其内部实现。</p><h2 id="重申一下重点：goroutine中的三个实体"><a href="#重申一下重点：goroutine中的三个实体" class="headerlink" title="重申一下重点：goroutine中的三个实体"></a>重申一下重点：goroutine中的三个实体</h2><p>goroutine中最主要的是三个实体为GMP，其中：</p><p><code>G:</code> 代表一个goroutine对象，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息，比如阻塞它的任何channel，其主要数据结构：</p><pre><code>type g struct {  stack       stack   // 描述了真实的栈内存，包括上下界  m              *m     // 当前的m  sched          gobuf   // goroutine切换时，用于保存g的上下文        param          unsafe.Pointer // 用于传递参数，睡眠时其他goroutine可以设置param，唤醒时该goroutine可以获取  atomicstatus   uint32  stackLock      uint32   goid           int64  // goroutine的ID  waitsince      int64 // g被阻塞的大体时间  lockedm        *m     // G被锁定只在这个m上运行}</code></pre><p>其中最主要的当然是sched了，保存了goroutine的上下文。goroutine切换的时候不同于线程有OS来负责这部分数据，而是由一个gobuf对象来保存，这样能够更加轻量级，再来看看gobuf的结构：</p><pre><code>type gobuf struct {    sp   uintptr    pc   uintptr    g    guintptr    ctxt unsafe.Pointer    ret  sys.Uintreg    lr   uintptr    bp   uintptr // for GOEXPERIMENT=framepointer}</code></pre><p>其实就是保存了当前的栈指针，计数器，当然还有g自身，这里记录自身g的指针是为了能快速的访问到goroutine中的信息。</p><p><code>M：</code>代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行，其主要数据结构：</p><pre><code>type m struct {    g0      *g     // 带有调度栈的goroutine    gsignal       *g         // 处理信号的goroutine    tls           [6]uintptr // thread-local storage    mstartfn      func()    curg          *g       // 当前运行的goroutine    caughtsig     guintptr     p             puintptr // 关联p和执行的go代码    nextp         puintptr    id            int32    mallocing     int32 // 状态    spinning      bool // m是否out of work    blocked       bool // m是否被阻塞    inwb          bool // m是否在执行写屏蔽    printlock     int8    incgo         bool // m在执行cgo吗    fastrand      uint32    ncgocall      uint64      // cgo调用的总数    ncgo          int32       // 当前cgo调用的数目    park          note    alllink       *m // 用于链接allm    schedlink     muintptr    mcache        *mcache // 当前m的内存缓存    lockedg       *g // 锁定g在当前m上执行，而不会切换到其他m    createstack   [32]uintptr // thread创建的栈}</code></pre><p>结构体M中有两个G是需要关注一下的，一个是curg，代表结构体M当前绑定的结构体G。另一个是g0，是带有调度栈的goroutine，这是一个比较特殊的goroutine。普通的goroutine的栈是在堆上分配的可增长的栈，而g0的栈是M对应的线程的栈。所有调度相关的代码，会先切换到该goroutine的栈中再执行。也就是说线程的栈也是用的g实现，而不是使用的OS的。</p><p><code>P：</code>代表一个处理器，每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；M的个数和P的个数不一定一样多（会有休眠的M或者不需要太多的M）（最大10000）；每一个P保存着本地G任务队列，也有一个全局G任务队列。P的数据结构：</p><pre><code>type p struct {    lock mutex    id          int32    status      uint32 // 状态，可以为pidle/prunning/...    link        puintptr    schedtick   uint32     // 每调度一次加1    syscalltick uint32     // 每一次系统调用加1    sysmontick  sysmontick     m           muintptr   // 回链到关联的m    mcache      *mcache    racectx     uintptr    goidcache    uint64 // goroutine的ID的缓存    goidcacheend uint64    // 可运行的goroutine的队列    runqhead uint32    runqtail uint32    runq     [256]guintptr    runnext guintptr // 下一个运行的g    sudogcache []*sudog    sudogbuf   [128]*sudog    palloc persistentAlloc // per-P to avoid mutex    pad [sys.CacheLineSize]byte</code></pre><p>其中P的状态有Pidle, Prunning, Psyscall, Pgcstop, Pdead；在其内部队列runqhead里面有可运行的goroutine，P优先从内部获取执行的g，这样能够提高效率。</p><p>除此之外，还有一个数据结构需要在这里提及，就是schedt，可以看做是一个全局的调度者：</p><pre><code>type schedt struct {   goidgen  uint64    lastpoll uint64    lock mutex    midle        muintptr // idle状态的m    nmidle       int32    // idle状态的m个数    nmidlelocked int32    // lockde状态的m个数    mcount       int32    // 创建的m的总数    maxmcount    int32    // m允许的最大个数    ngsys uint32 // 系统中goroutine的数目，会自动更新    pidle      puintptr // idle的p    npidle     uint32    nmspinning uint32     // 全局的可运行的g队列    runqhead guintptr    runqtail guintptr    runqsize int32    // dead的G的全局缓存    gflock       mutex    gfreeStack   *g    gfreeNoStack *g    ngfree       int32    // sudog的缓存中心    sudoglock  mutex    sudogcache *sudog}</code></pre><p>大多数需要的信息都已放在了结构体M、G和P中，schedt结构体只是一个壳。可以看到，其中有M的idle队列，P的idle队列，以及一个全局的就绪的G队列。schedt结构体中的Lock是非常必须的，如果M或P等做一些非局部的操作，它们一般需要先锁住调度器。</p><h2 id="goroutine的运行过程"><a href="#goroutine的运行过程" class="headerlink" title="goroutine的运行过程"></a>goroutine的运行过程</h2><p>所有的goroutine都是由函数<code>newproc</code>来创建的，但是由于该函数不能调用分段栈，最后真正调用的是<code>newproc1</code>。在<code>newproc1</code>中主要进行如下动作：</p><pre><code>func newproc1(fn *funcval, argp *uint8, narg int32, nret int32, callerpc uintptr) *g {    newg = malg(_StackMin)    casgstatus(newg, _Gidle, _Gdead)    allgadd(newg)     newg.sched.sp = sp    newg.stktopsp = sp    newg.sched.pc = funcPC(goexit) + sys.PCQuantum     newg.sched.g = guintptr(unsafe.Pointer(newg))    gostartcallfn(&amp;newg.sched, fn)    newg.gopc = callerpc    newg.startpc = fn.fn    ......}</code></pre><p>分配一个g的结构体<br>初始化这个结构体的一些域<br>将g挂在就绪队列<br>绑定g到一个m上</p><p>这个绑定只要m没有突破上限GOMAXPROCS,就拿一个m绑定一个g。如果m的waiting队列中有就从队列中拿,否则就要新建一个m,调用<code>newm</code>。</p><pre><code>func newm(fn func(), _p_ *p) {    mp := allocm(_p_, fn)    mp.nextp.set(_p_)    mp.sigmask = initSigmask    execLock.rlock()    newosproc(mp, unsafe.Pointer(mp.g0.stack.hi))    execLock.runlock()}</code></pre><p>该函数其实就是创建一个m，跟<code>newproc</code>有些相似，之前也说了m在底层就是一个线程的创建，也即是<code>newosproc</code>函数，在往下挖可以看到会根据不同的OS来执行不同的<code>bsdthread_create</code>函数，而底层就是调用的<code>runtime.clone</code>：</p><pre><code>clone(cloneFlags,stk,unsafe.Pointer(mp),unsafe.Pointer(mp.g0),unsafe.Pointer(funcPC(mstart)))</code></pre><p>m创建好之后，线程的入口是mstart，最后调用的即是<code>mstart1</code>：</p><pre><code>func mstart1() {    _g_ := getg()    gosave(&amp;_g_.m.g0.sched)    _g_.m.g0.sched.pc = ^uintptr(0)    asminit()    minit()    if _g_.m == &amp;m0 {        initsig(false)    }    if fn := _g_.m.mstartfn; fn != nil {        fn()    }    schedule()}</code></pre><p>里面最重要的就是schedule了，在schedule中的动作大体就是找到一个等待运行的g，然后然后搬到m上，设置其状态为<code>Grunning</code>,直接切换到g的上下文环境,恢复g的执行。</p><pre><code>func schedule() {    _g_ := getg()    if _g_.m.lockedg != nil {        stoplockedm()        execute(_g_.m.lockedg, false) // Never returns.    }}</code></pre><p><code>schedule</code>的执行可以大体总结为：</p><p><em>schedule函数获取g =&gt; [必要时休眠] =&gt; [唤醒后继续获取] =&gt; execute函数执行g =&gt; 执行后返回到goexit =&gt; 重新执行schedule函数</em></p><p>简单来说g所经历的几个主要的过程就是：Gwaiting-&gt;Grunnable-&gt;Grunning。经历了创建,到挂在就绪队列,到从就绪队列拿出并运行整个过程。</p><pre><code>casgstatus(gp, _Gwaiting, _Grunnable)casgstatus(gp, _Grunnable, _Grunning)</code></pre><p>引入了struct M这层抽象。m就是这里的worker,但不是线程。处理系统调用中的m不会占用mcpu数量,只有干事的m才会对应到线程.当mcpu数量少于GOMAXPROCS时可以一直开新的线程干活.而goroutine的执行则是在m和g都满足之后通过schedule切换上下文进入的.</p><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>当有很多goroutine需要执行的时候，是怎么调度的了，上面说的P还没有出场呢，在<code>runtime.main</code>中会创建一个额外m运行<code>sysmon</code>函数，抢占就是在sysmon中实现的。</p><p>sysmon会进入一个无限循环, 第一轮回休眠20us, 之后每次休眠时间倍增, 最终每一轮都会休眠10ms. sysmon中有netpool(获取fd事件), retake(抢占), forcegc(按时间强制执行gc), scavenge heap(释放自由列表中多余的项减少内存占用)等处理.</p><pre><code>func sysmon() {    lasttrace := int64(0)    idle := 0 // how many cycles in succession we had not wokeup somebody    delay := uint32(0)    for {        if idle == 0 { // start with 20us sleep...            delay = 20        } else if idle &gt; 50 { // start doubling the sleep after 1ms...            delay *= 2        }        if delay &gt; 10*1000 { // up to 10ms            delay = 10 * 1000        }        usleep(delay)        ......    }       }</code></pre><p>里面的函数<code>retake</code>负责抢占：</p><pre><code>func retake(now int64) uint32 {    n := 0    for i := int32(0); i &lt; gomaxprocs; i++ {        _p_ := allp[i]        if _p_ == nil {            continue        }        pd := &amp;_p_.sysmontick        s := _p_.status        if s == _Psyscall {            // 如果p的syscall时间超过一个sysmon tick则抢占该p            t := int64(_p_.syscalltick)            if int64(pd.syscalltick) != t {                pd.syscalltick = uint32(t)                pd.syscallwhen = now                continue            }            if runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; 0 &amp;&amp; pd.syscallwhen+10*1000*1000 &gt; now {                continue            }            incidlelocked(-1)            if atomic.Cas(&amp;_p_.status, s, _Pidle) {                if trace.enabled {                    traceGoSysBlock(_p_)                    traceProcStop(_p_)                }                n++                _p_.syscalltick++                handoffp(_p_)            }            incidlelocked(1)        } else if s == _Prunning {            // 如果G运行时间过长，则抢占该G            t := int64(_p_.schedtick)            if int64(pd.schedtick) != t {                pd.schedtick = uint32(t)                pd.schedwhen = now                continue            }            if pd.schedwhen+forcePreemptNS &gt; now {                continue            }            preemptone(_p_)        }    }    return uint32(n)}</code></pre><p>枚举所有的P 如果P在系统调用中(_Psyscall), 且经过了一次sysmon循环(20us~10ms), 则抢占这个P， 调用handoffp解除M和P之间的关联， 如果P在运行中(_Prunning), 且经过了一次sysmon循环并且G运行时间超过forcePreemptNS(10ms), 则抢占这个P</p><p>并设置g.preempt = true，g.stackguard0 = stackPreempt。</p><p>为什么设置了stackguard就可以实现抢占?</p><p>因为这个值用于检查当前栈空间是否足够, go函数的开头会比对这个值判断是否需要扩张栈。</p><p>newstack函数判断g.stackguard0等于stackPreempt, 就知道这是抢占触发的, 这时会再检查一遍是否要抢占。</p><p>抢占机制保证了不会有一个G长时间的运行导致其他G无法运行的情况发生。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比大多数并行设计模型，Go比较优势的设计就是P上下文这个概念的出现，如果只有G和M的对应关系，那么当G阻塞在IO上的时候，M是没有实际在工作的，这样造成了资源的浪费，没有了P，那么所有G的列表都放在全局，这样导致临界区太大，对多核调度造成极大影响。</p><p>而goroutine在使用上面的特点，感觉既可以用来做密集的多核计算，又可以做高并发的IO应用，做IO应用的时候，写起来感觉和对程序员最友好的同步阻塞一样，而实际上由于runtime的调度，底层是以同步非阻塞的方式在运行（即IO多路复用）。</p><p>所以说保护现场的抢占式调度和G被阻塞后传递给其他m调用的核心思想，使得goroutine的产生。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>本文从宏观角度介绍了一下Go调度器的调度过程。Go调度器也是Go语言最精华的部分，希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子操作</title>
      <link href="/2021/120336864.html"/>
      <url>/2021/120336864.html</url>
      
        <content type="html"><![CDATA[<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>锁机制的底层是基于原子操作的，其一般直接通过CPU指令实现。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><div class="table-container"><table><thead><tr><th style="text-align:center">读取操作</th></tr></thead><tbody><tr><td style="text-align:center">func LoadInt32(addr *int32) (val int32)</td></tr><tr><td style="text-align:center">func LoadInt64(addr *int64) (val int64)</td></tr><tr><td style="text-align:center">func LoadUint32(addr *uint32) (val uint32)</td></tr><tr><td style="text-align:center">func LoadUint64(addr *uint64) (val uint64)</td></tr><tr><td style="text-align:center">func LoadUintptr(addr *uintptr) (val uintptr)</td></tr><tr><td style="text-align:center">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">写入操作</th></tr></thead><tbody><tr><td style="text-align:center">func StoreInt32(addr *int32, val int32)</td></tr><tr><td style="text-align:center">func StoreInt64(addr *int64, val int64)</td></tr><tr><td style="text-align:center">func StoreUint32(addr *uint32, val uint32)</td></tr><tr><td style="text-align:center">func StoreUint64(addr *uint64, val uint64)</td></tr><tr><td style="text-align:center">func StoreUintptr(addr *uintptr, val uintptr)</td></tr><tr><td style="text-align:center">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">修改操作</th></tr></thead><tbody><tr><td style="text-align:center">func AddInt32(addr *int32, delta int32) (new int32)</td></tr><tr><td style="text-align:center">func AddInt64(addr *int64, delta int64) (new int64)</td></tr><tr><td style="text-align:center">func AddUint32(addr *uint32, delta uint32) (new uint32)</td></tr><tr><td style="text-align:center">func AddUint64(addr *uint64, delta uint64) (new uint64)</td></tr><tr><td style="text-align:center">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">交换操作</th></tr></thead><tbody><tr><td style="text-align:center">func SwapInt32(addr *int32, new int32) (old int32)</td></tr><tr><td style="text-align:center">func SwapInt64(addr *int64, new int64) (old int64)</td></tr><tr><td style="text-align:center">func SwapUint32(addr *uint32, new uint32) (old uint32)</td></tr><tr><td style="text-align:center">func SwapUint64(addr *uint64, new uint64) (old uint64)</td></tr><tr><td style="text-align:center">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</td></tr><tr><td style="text-align:center">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">比较并交换操作</th></tr></thead><tbody><tr><td style="text-align:center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</td></tr><tr><td style="text-align:center">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</td></tr><tr><td style="text-align:center">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</td></tr><tr><td style="text-align:center">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</td></tr><tr><td style="text-align:center">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</td></tr><tr><td style="text-align:center">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td></tr></tbody></table></div><p>举例：比较下互斥锁和原子操作的性能。</p><pre class=" language-lang-go"><code class="language-lang-go">package mainimport (    "fmt"    "sync"    "sync/atomic"    "time")type Counter interface {    Inc()    Load() int64}// 普通版type CommonCounter struct {    counter int64}func (c CommonCounter) Inc() {    c.counter++}func (c CommonCounter) Load() int64 {    return c.counter}// 互斥锁版type MutexCounter struct {    counter int64    lock    sync.Mutex}func (m *MutexCounter) Inc() {    m.lock.Lock()    defer m.lock.Unlock()    m.counter++}func (m *MutexCounter) Load() int64 {    m.lock.Lock()    defer m.lock.Unlock()    return m.counter}// 原子操作版type AtomicCounter struct {    counter int64}func (a *AtomicCounter) Inc() {    atomic.AddInt64(&a.counter, 1)}func (a *AtomicCounter) Load() int64 {    return atomic.LoadInt64(&a.counter)}func test(c Counter) {    var wg sync.WaitGroup    start := time.Now()    for i := 0; i < 1000; i++ {        wg.Add(1)        go func() {            c.Inc()            wg.Done()        }()    }    wg.Wait()    end := time.Now()    fmt.Println(c.Load(), end.Sub(start))}func main() {    c1 := CommonCounter{} // 非并发安全    test(c1)    c2 := MutexCounter{} // 使用互斥锁实现并发安全    test(&c2)    c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高    test(&c3)}</code></pre><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发任务和通道</title>
      <link href="/2021/120315684.html"/>
      <url>/2021/120315684.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>并发：同一时间段内执行多个任务</li><li>并行：同一时刻执行多个任务</li></ul><p>Go语言中，并发通过<code>goroutine</code>实现，<code>goroutine</code>类似线程，属于用户态的线程。<code>goroutine</code>是由Go语言的运行时调度完成，线程是由操作系统调度完成。</p><p>Go语言提供了<code>channel</code>在多个<code>goroutine</code>间进行通信。</p><p><code>goroutine</code>和<code>channel</code>是由Go语言秉承的CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>在java/c++中实现并发编程，需要自行维护一个线程池，需要包装若干任务，自己去调度线程执行任务并维护上下文切换。</p><p>而Go语言中，通过<code>goroutine</code>机制，我们只需要定义若干任务，然后让系统帮助我们把这些任务分配到CPU上实现并发执行。</p><p>在Go语言编程中，我们不需要去自己写进程、线程、协程，只需要一个<code>goroutine</code>。当需要让某个任务并发执行的时候，只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了。</p><h5 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h5><p>只需要在调用函数前加<code>go</code>关键字，就可以为该函数创建一个<code>goroutine</code></p><p>tips：可以创建多个<code>goroutine</code>去执行相同的函数</p><h5 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h5><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func hello(){    fmt.Println("Hello World")}func main(){    go hello()    fmt.Println("main")}</code></pre><p>这里在调用hello函数时启动了一个<code>goroutine</code>来执行</p><p>执行结果：只打印了<code>main</code>，没有打印<code>Hello World</code></p><p>原因：<code>main()</code>的<code>goroutine</code>结束则整个程序结束，所以打印了<code>main</code>信息后未打印出<code>Hello World</code></p><p>如果将main函数改为如下形式：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    go hello()    fmt.Println("main")    time.Sleep(time.Second)}</code></pre><p>呢么将先打印出<code>main</code>，然后打印出<code>Hello World</code></p><p>因为创建新的<code>goroutine</code>需要花费一些时间，此时<code>main</code>的<code>goroutine</code>是继续执行的。</p><h5 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h5><p>举例：（这里使用<code>sync.WaitGroup</code>实现<code>goroutine</code>的同步）</p><pre class=" language-lang-go"><code class="language-lang-go">var wg sync.WaitGroupfunc hello(i int) {    defer wg.Done() // goroutine结束就登记-1    fmt.Println("Hello ", i)}func main() {    for i := 0; i < 10; i++ {        wg.Add(1) // 启动一个goroutine就登记+1        go hello(i)    }    wg.Wait() // 等待所有登记的goroutine都结束}</code></pre><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h3 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h3><h5 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h5><p>OS线程（操作系统线程）一般有固定的栈内存（通常为2MB）</p><p>一个<code>goroutine</code>的栈在生命周期开始时只有很小的栈，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB。</p><h5 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h5><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是Go语言自身实现的一套调度系统，区别于操作系统调度OS线程。</p><ul><li>G：<code>goroutine</code>，存放了本<code>goroutine</code>信息以及所在<code>P</code>的绑定等信息。</li><li>P：<code>P</code>管理着一组<code>goroutine</code>队列，<code>P</code>里面会存储着当前<code>goroutine</code>运行的上下文环境（函数指针，堆栈地址及地址边界），<code>P</code>会对自己管理的<code>goroutine</code>进行调度（比如把占用CPU时间长的<code>goroutine</code>暂停，运行后续的<code>goroutine</code>等）。当自己的队列消费完后会从全局队列中取，如果全局队列消费完了会从其他<code>P</code>的队列里抢任务。</li><li>M：<code>machine</code>是Go运行时<code>runtime</code>对操作系统内核线程的模拟，<code>M</code>与内核线程一般是一一映射的关系，一个<code>goroutine</code>最终要在<code>M</code>上执行。</li></ul><p><code>P</code>与<code>M</code>一般也是一一对应的，他们的关系为：<code>P</code>管理一组<code>G</code>，搭载在<code>M</code>上运行</p><p>当一个<code>G</code>长久阻塞在一个<code>M</code>上，<code>runtime</code>会新建一个<code>M</code>，阻塞<code>G</code>所在的<code>P</code>会把其他的<code>G</code>挂载在新的<code>M</code>上，当旧的<code>G</code>阻塞完成或者认为其已死去时回收旧的<code>M</code></p><p><code>P</code>的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本后默认为物理线程数，在并发量大时会增加一些<code>P</code>和<code>M</code>，但不会太多。</p><p>详见：<a href="https://www.cnblogs.com/sunsky303/p/9705727.html">深入Golang调度器之GMP模型</a></p><h5 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h5><p>Go运行时（runtime）的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。</p><p><code>GOMAXPROCS</code>的默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上</p><blockquote><p>（GOMAXPROCS是m:n调度中的n）。</p></blockquote><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><pre class=" language-lang-go"><code class="language-lang-go">func a() {    for i := 1; i < 10; i++ {        fmt.Println("A:", i)    }}func b() {    for i := 1; i < 10; i++ {        fmt.Println("B:", i)    }}func main() {    runtime.GOMAXPROCS(1)    go a()    go b()    time.Sleep(time.Second)}</code></pre><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><pre class=" language-lang-go"><code class="language-lang-go">func a() {    for i := 1; i < 10; i++ {        fmt.Println("A:", i)    }}func b() {    for i := 1; i < 10; i++ {        fmt.Println("B:", i)    }}func main() {    runtime.GOMAXPROCS(2)    go a()    go b()    time.Sleep(time.Second)}</code></pre><p>Go语言中的操作系统线程和<code>goroutine</code>的关系：</p><ul><li>一个操作系统线程对应用户态多个<code>goroutine</code>。</li><li>go程序可以同时使用多个操作系统线程。</li><li><code>goroutine</code>和OS线程是多对多的关系，即m:n。</li></ul><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>单纯将函数并发执行没有意义，函数之间需要有数据交换。</p><blockquote><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中可能会发生竞态问题，为了保证数据交换的正确，必须使用互斥量对内存进行加锁，这种做法会造成性能问题。</p></blockquote><p>Go语言的并发模型是<code>CSP(Communicating Sequential Processes)</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，呢么<code>channel</code>是他们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go语言中的<code>通道(channel)</code>是一种特殊的类型，他类似队列，遵循<code>FIFO(先入先出)</code>的规则，保证收发数据的顺序，每一个通道都是一个具体类型的导管，也就是声明<code>channel</code>的时候需要为其制定元素类型。</p><h5 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h5><p><code>channel</code>是一种引用类型。声明<code>通道（channel）</code>类型的格式如下：</p><pre class=" language-lang-go"><code class="language-lang-go">var 变量 chan 元素类型</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var ch1 chan int   // 声明一个传递int的通道var ch2 chan bool  // 声明一个传递bool的通道var ch3 chan []int // 声明一个传递int切片的通道</code></pre><h5 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h5><p>通道类型的空值是<code>nil</code>。</p><p>声明的通道后需要使用<code>make</code>函数初始化才可以使用。</p><p>创建<code>channel</code>的格式：</p><pre class=" language-lang-go"><code class="language-lang-go">make(chan 元素类型, [缓冲大小])        //缓冲大小可选</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">ch1 := make(chan int)ch2 := make(chan bool)ch3 := make(chan []int)</code></pre><h5 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h5><p>通道有发送(send)、接收(receive)、关闭(close)三种操作</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>举例：定义一个通道：</p><pre class=" language-lang-go"><code class="language-lang-go">ch := make(chan int)</code></pre><p><em>发送</em>：将一个值发送到通道中。</p><pre class=" language-lang-go"><code class="language-lang-go">ch <- 10    //将10发送到ch中</code></pre><p><em>接收</em>：从一个通道中接收值。</p><pre class=" language-lang-go"><code class="language-lang-go">x := <- ch    //从ch中接收值并赋值给x<-ch        //从ch中接收值，忽略结果</code></pre><p><em>关闭</em>：调用<code>close</code>函数关闭通道</p><pre class=" language-lang-go"><code class="language-lang-go">close(ch)</code></pre><blockquote><p>只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的。</p><p>在结束操作之后必须关闭文件，但并不必须关闭通道。</p></blockquote><p>关闭后的通道有以下特点：</p><ul><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ul><h5 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h5><p>无缓冲的通道又称为阻塞的通道。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    ch := make(chan int)    ch <- 10    fmt.Println("发送成功")}</code></pre><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><pre class=" language-lang-bash"><code class="language-lang-bash">fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main()        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</code></pre><p><strong><em>为什么会出现<code>deadlock</code>错误呢？</em></strong></p><p>因为无缓冲的通道必须有接收才能发送，而我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁。</p><p><strong><em>那如何解决这个问题呢？</em></strong></p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><pre class=" language-lang-go"><code class="language-lang-go">func recv(c chan int) {    ret := <-c    fmt.Println("接收成功", ret)}func main() {    ch := make(chan int)    go recv(ch) // 启用goroutine从通道接收值    ch <- 10    fmt.Println("发送成功")}</code></pre><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。</p><p>相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h5 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h5><p>解决上面问题，我们还可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道    ch <- 10    fmt.Println("发送成功")}</code></pre><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量。</p><h5 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h5><p>判断一个通道是否被关闭，举例：</p><pre class=" language-lang-go"><code class="language-lang-go">// channel 练习func main() {    ch1 := make(chan int)    ch2 := make(chan int)    // 开启goroutine将0~100的数发送到ch1中    go func() {        for i := 0; i < 100; i++ {            ch1 <- i        }        close(ch1)    }()    // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中    go func() {        for {            i, ok := <-ch1 // 通道关闭后再取值ok=false            if !ok {                break            }            ch2 <- i * i        }        close(ch2)    }()    // 在主goroutine中从ch2中接收值打印    for i := range ch2 { // 通道关闭后会退出for range循环        fmt.Println(i)    }}</code></pre><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h5 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h5><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func counter(out chan<- int) {    for i := 0; i < 100; i++ {        out <- i    }    close(out)}func squarer(out chan<- int, in <-chan int) {    for i := range in {        out <- i * i    }    close(out)}func printer(in <-chan int) {    for i := range in {        fmt.Println(i)    }}func main() {    ch1 := make(chan int)    ch2 := make(chan int)    go counter(ch1)    go squarer(ch2, ch1)    printer(ch2)}</code></pre><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的</p><h5 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h5><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h3 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h3><p>在工作中我们通常会使用可以指定启动的<code>goroutine</code>数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><pre class=" language-lang-go"><code class="language-lang-go">func worker(id int, jobs <-chan int, results chan<- int) {    for j := range jobs {        fmt.Printf("worker:%d start job:%d\n", id, j)        time.Sleep(time.Second)        fmt.Printf("worker:%d end job:%d\n", id, j)        results <- j * 2    }}func main() {    jobs := make(chan int, 100)    results := make(chan int, 100)    // 开启3个goroutine    for w := 1; w <= 3; w++ {        go worker(w, jobs, results)    }    // 5个任务    for j := 1; j <= 5; j++ {        jobs <- j    }    close(jobs)    // 输出结果    for a := 1; a <= 5; a++ {        <-results    }}</code></pre><h3 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h3><p>Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。格式：</p><pre class=" language-lang-go"><code class="language-lang-go">select{    case <-ch1:        ...    case data := <-ch2:        ...    case ch3<-data:        ...    default:        默认操作}</code></pre><p>举个小例子来演示下<code>select</code>的使用：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    ch := make(chan int, 1)    for i := 0; i < 10; i++ {        select {        case x := <-ch:            fmt.Println(x)        case ch <- i:        }    }}</code></pre><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发安全和锁</title>
      <link href="/2021/120348792.html"/>
      <url>/2021/120348792.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h1><h3 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h3><p>在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。</p><p>举个例子：</p><pre class=" language-lang-go"><code class="language-lang-go">var x int64var wg sync.WaitGroupfunc add() {    for i := 0; i < 5000; i++ {        x = x + 1    }    wg.Done()}func main() {    wg.Add(2)    go add()    go add()    wg.Wait()    fmt.Println(x)}</code></pre><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，他可以确保同时只有一个<code>goroutine</code>访问共享资源。</p><p>Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁</p><p>举例：使用互斥锁解决上例问题。</p><pre class=" language-lang-go"><code class="language-lang-go">var x int64var wg sync.WaitGroupvar lock sync.Mutexfunc add() {    for i := 0; i < 5000; i++ {        lock.Lock() // 加锁        x = x + 1        lock.Unlock() // 解锁    }    wg.Done()}func main() {    wg.Add(2)    go add()    go add()    wg.Wait()    fmt.Println(x)}</code></pre><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁</p><p>当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h5 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h5><p>互斥锁是完全互斥的，但是很多情况下<code>读操作</code>频率大于<code>写操作</code>，并发读取资源是没必要加锁的，此时使用<code>读写锁</code>是更好的选择。</p><p>读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型</p><p>读写锁分为：读锁、写锁</p><p>当一个<code>goroutine</code>获取读锁后，其他<code>goroutine</code>可以获取读锁，不能获取写锁（需要等待）</p><p>当一个<code>goroutine</code>获取写锁后，其他<code>goroutine</code>不能获取锁（需要等待）</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var (    x      int64    wg     sync.WaitGroup    lock   sync.Mutex    rwlock sync.RWMutex)func write() {    // lock.Lock()   // 加互斥锁    rwlock.Lock() // 加写锁    x = x + 1    time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒    rwlock.Unlock()                   // 解写锁    // lock.Unlock()                     // 解互斥锁    wg.Done()}func read() {    // lock.Lock()                  // 加互斥锁    rwlock.RLock()               // 加读锁    time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒    rwlock.RUnlock()             // 解读锁    // lock.Unlock()                // 解互斥锁    wg.Done()}func main() {    start := time.Now()    for i := 0; i < 10; i++ {        wg.Add(1)        go write()    }    for i := 0; i < 1000; i++ {        wg.Add(1)        go read()    }    wg.Wait()    end := time.Now()    fmt.Println(end.Sub(start))}</code></pre><p>读写锁适合读多写少的情况，如果读写差别不大则发挥不出优势。</p><h5 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h5><p>在代码中生硬使用<code>time.Sleep</code>肯定是不合适的。</p><p>Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务同步。</p><p><code>sync.WaitGroup</code>的方法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">(wg * WaitGroup) Add(delta int)</td><td style="text-align:center">计数器+delta</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Done()</td><td style="text-align:center">计数器-1</td></tr><tr><td style="text-align:center">(wg *WaitGroup) Wait()</td><td style="text-align:center">阻塞直到计数器变为0</td></tr></tbody></table></div><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。</p><p>例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。</p><p>通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var wg sync.WaitGroupfunc hello() {    defer wg.Done()    fmt.Println("Hello Goroutine!")}func main() {    wg.Add(1)    go hello() // 启动另外一个goroutine去执行hello函数    fmt.Println("main goroutine done!")    wg.Wait()}</code></pre><p>注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h5 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h5><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件，只关闭一次通道等。</p><p><code>sync.Once</code>可以解决只执行一次场景的问题。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，签名为：</p><pre class=" language-lang-go"><code class="language-lang-go">func (o *Once) Do(f func() ){}</code></pre><blockquote><p>如果要执行的函数需要传递参数，则需要搭配闭包使用</p></blockquote><h6 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h6><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var icons map[string]image.Imagefunc loadIcons() {    icons = map[string]image.Image{        "left":  loadIcon("left.png"),        "up":    loadIcon("up.png"),        "right": loadIcon("right.png"),        "down":  loadIcon("down.png"),    }}// Icon 被多个goroutine调用时不是并发安全的func Icon(name string) image.Image {    if icons == nil {        loadIcons()    }    return icons[name]}</code></pre><p>多个<code>goroutine</code>并发调用<code>Icon</code>函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。</p><p>loadIcons函数可能会被重排为以下结果：</p><pre class=" language-lang-go"><code class="language-lang-go">func loadIcons() {    icons = make(map[string]image.Image)    icons["left"] = loadIcon("left.png")    icons["up"] = loadIcon("up.png")    icons["right"] = loadIcon("right.png")    icons["down"] = loadIcon("down.png")}</code></pre><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。而添加互斥锁又会引发性能问题。</p><p>举例：将上面代码使用<code>sync.Once</code>改造：</p><pre class=" language-lang-go"><code class="language-lang-go">var icons map[string]image.Imagevar loadIconsOnce sync.Oncefunc loadIcons() {    icons = map[string]image.Image{        "left":  loadIcon("left.png"),        "up":    loadIcon("up.png"),        "right": loadIcon("right.png"),        "down":  loadIcon("down.png"),    }}// Icon 是并发安全的func Icon(name string) image.Image {    loadIconsOnce.Do(loadIcons)    return icons[name]}</code></pre><h6 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h6><p>举例：借助<code>sync.Once</code>实现的并发安全的单例模式：</p><pre class=" language-lang-go"><code class="language-lang-go">package singletonimport (    "sync")type singleton struct {}var instance *singletonvar once sync.Oncefunc GetInstance() *singleton {    once.Do(func() {        instance = &singleton{}    })    return instance}</code></pre><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。</p><p>这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h5 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h5><p>Go语言中内置的map不是并发安全的。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var m = make(map[string]int)func get(key string) int {    return m[key]}func set(key string, value int) {    m[key] = value}func main() {    wg := sync.WaitGroup{}    for i := 0; i < 20; i++ {        wg.Add(1)        go func(n int) {            key := strconv.Itoa(n)            set(key, n)            fmt.Printf("k=:%v,v:=%v\n", key, get(key))            wg.Done()        }(i)    }    wg.Wait()}</code></pre><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。</p><p>开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><pre class=" language-lang-go"><code class="language-lang-go">var m = sync.Map{}func main() {    wg := sync.WaitGroup{}    for i := 0; i < 20; i++ {        wg.Add(1)        go func(n int) {            key := strconv.Itoa(n)            m.Store(key, n)            value, _ := m.Load(key)            fmt.Printf("k=:%v,v:=%v\n", key, value)            wg.Done()        }(i)    }    wg.Wait()}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2021/120321513.html"/>
      <url>/2021/120321513.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>Go语言中定义函数使用<code>func</code>，格式：</p><pre class=" language-lang-go"><code class="language-lang-go">func 函数名(参数)(返回值){    函数体}</code></pre><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字，且在同一个包内，函数名不能重名</li><li>参数：参数由<code>参数变量</code>和<code>参数变量类型</code>组成，多个参数之间使用<code>，</code>分隔</li><li>返回值：返回值由<code>返回值变量</code>和<code>其变量类型</code>组成，也可以只写返回值的类型，多个返回值之间使用<code>，</code>分隔</li><li>函数体：实现指定功能的代码块</li></ul><p>举例：求两数之和</p><pre class=" language-lang-go"><code class="language-lang-go">func intSum(x int, y int) int {    return x + y}</code></pre><p>函数的参数和返回值都是可选的</p><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>定义了函数之后可以通过<code>函数名(参数)</code>调用函数，如</p><pre class=" language-lang-go"><code class="language-lang-go">sum := intSum(1, 1)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h5 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h5><p>函数的参数中如果相邻变量类型相同，可以省略其类型，如</p><pre class=" language-lang-go"><code class="language-lang-go">func intSum(x, y int) int {    return x + y}</code></pre><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>可变参数是指函数的参数数量不固定，Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><blockquote><p>可变参数通常作为函数的最后一个参数。</p></blockquote><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func intSum2(x ... int) int {    fmt.Println(x)    //x是一个切片    sum := 0    for _, val := range x{        sum = sum + val    }    return sum}</code></pre><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><h5 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h5><p>Go语言中函数支持多返回值，用<code>,</code>区分</p><h5 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h5><p>函数定义时可以给返回值命名，并在函数中直接使用这些变量</p><p>最后需要通过<code>return</code>返回</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func calc(x, y int) (sum, sub int) {    sum = x + y    sub = x - y    return}</code></pre><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>全局变量是定义在函数外部的变量，它在程序整个运行周期都有效</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>有两种：</p><ul><li>函数内定义的变量(无法在函数外使用)</li><li>语句块内定义的变量（无法在语句块外使用）</li></ul><h3 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h3><h5 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h5><p>可以用<code>type</code>关键字定义一个函数类型，格式：</p><pre class=" language-lang-go"><code class="language-lang-go">type calculation func(int, int) int</code></pre><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型</p><p>与<code>calculation</code>相同类型的函数都可以赋值给<code>calculation</code>的变量</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">type calculation func(int, int) intfunc add(x, y int) int {    return x + y}func sub(x, y int) int {    return x - y}func main(){    var cal calculation    cal = add    cal = sub}</code></pre><p>add和sub都能赋值给calculation类型的变量。</p><h5 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h5><p>我们可以声明函数类型的变量并为之赋值</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var c calculation      // 声明一个calculation类型的变量c    c = add                         // 把add赋值给c    fmt.Println(c(1, 2))            // 像调用add一样调用c    fmt.Printf("type of c:%T\n", c)     // type of c:main.calculation    f := add                        // 将函数add赋值给变量f1    fmt.Println(f(10, 20))          // 像调用add一样调用f    fmt.Printf("type of f:%T\n", f)     // type of f:func(int, int) int}</code></pre><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数即函数的参数或返回值也是函数</p><h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h5><p>函数作为参数：</p><pre class=" language-lang-go"><code class="language-lang-go">func add(x, y int) int {    return x + y}func calc(x, y int, op func(int, int) int) int {    return op(x, y)}func main() {    ret2 := calc(10, 20, add)    fmt.Println(ret2) //30}</code></pre><p>函数作为返回值：</p><pre class=" language-lang-go"><code class="language-lang-go">func do(s string) (func(int, int) int, error) {    switch s {    case "+":        return add, nil    case "-":        return sub, nil    default:        err := errors.New("无法识别的操作符")        return nil, err    }}</code></pre><h3 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h3><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>Go语言的函数内部不能定义函数，但可以定义匿名函数。</p><p>匿名函数的定义格式为：</p><pre class=" language-lang-go"><code class="language-lang-go">func(参数)(返回值){    函数体}</code></pre><p>匿名函数因为没有函数名，所以不能像普通函数那样调用</p><p>一般匿名函数需要保存在某个变量或者立即执行</p><pre class=" language-lang-go"><code class="language-lang-go">func main(){    //将匿名函数保存到变量    add := func(x, y int){        fmt.Println(x + y)    }    add(10, 20)    //通过变量调用匿名函数    //自执行函数：匿名函数定义完加()直接执行    func(x, y int){        fmt.Println(x + y)    }(10, 20)}</code></pre><p>匿名函数多用于实现回调函数和闭包</p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体</p><pre><code>闭包 = 函数 + 引用环境</code></pre><blockquote><p>举例：</p></blockquote><pre class=" language-lang-go"><code class="language-lang-go">func adder() func(int) int {    var x int    return func(y int) int {        x += y        return x    }}func main() {    var f = adder()    fmt.Println(f(10)) //10    fmt.Println(f(20)) //30    fmt.Println(f(30)) //60    f1 := adder()    fmt.Println(f1(40)) //40    fmt.Println(f1(50)) //90}</code></pre><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p><blockquote><p>举例2：</p></blockquote><pre class=" language-lang-go"><code class="language-lang-go">func adder2(x int) func(int) int {    return func(y int) int {        x += y        return x    }}func main() {    var f = adder2(10)    fmt.Println(f(10)) //20    fmt.Println(f(20)) //40    fmt.Println(f(30)) //70    f1 := adder2(20)    fmt.Println(f1(40)) //60    fmt.Println(f1(50)) //110}</code></pre><blockquote><p>举例3：</p></blockquote><pre class=" language-lang-go"><code class="language-lang-go">func makeSuffixFunc(suffix string) func(string) string {    return func(name string) string {        if !strings.HasSuffix(name, suffix) {            return name + suffix        }        return name    }}func main() {    jpgFunc := makeSuffixFunc(".jpg")    txtFunc := makeSuffixFunc(".txt")    fmt.Println(jpgFunc("test")) //test.jpg    fmt.Println(txtFunc("test")) //test.txt}</code></pre><blockquote><p>举例4：</p></blockquote><pre class=" language-lang-go"><code class="language-lang-go">func calc(base int) (func(int) int, func(int) int) {    add := func(i int) int {        base += i        return base    }    sub := func(i int) int {        base -= i        return base    }    return add, sub}func main() {    f1, f2 := calc(10)    fmt.Println(f1(1), f2(2)) //11 9    fmt.Println(f1(3), f2(4)) //12 8    fmt.Println(f1(5), f2(6)) //13 7}</code></pre><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。</p><p>在<code>defer</code>所在的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    fmt.Println("start")    defer fmt.Println(1)    defer fmt.Println(2)    defer fmt.Println(3)    fmt.Println("end")}</code></pre><p>输出结果：</p><pre class=" language-lang-go"><code class="language-lang-go">startend321</code></pre><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h5 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h5><p><img src="https://www.liwenzhou.com/images/Go/func/defer.png" alt="defer执行时机"></p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">内置函数</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">close</td><td style="text-align:center">主要用来关闭channel</td></tr><tr><td style="text-align:center">len</td><td style="text-align:center">用来求长度，比如string、array、slice、map、channel</td></tr><tr><td style="text-align:center">new</td><td style="text-align:center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td style="text-align:center">make</td><td style="text-align:center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td style="text-align:center">append</td><td style="text-align:center">用来追加元素到数组、slice中</td></tr><tr><td style="text-align:center">panic和recover</td><td style="text-align:center">用来做错误处理</td></tr></tbody></table></div><h5 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h5><p>Go语言中目前没有异常机制，使用<code>panic/recover</code>处理错误</p><p><code>panic</code>可以在任何地方引发，<code>recover</code>只在<code>defer</code>调用的函数有效</p><pre class=" language-lang-go"><code class="language-lang-go">func funcA() {    fmt.Println("func A")}func funcB() {    panic("panic in B")}func funcC() {    fmt.Println("func C")}func main() {    funcA()    funcB()    funcC()}</code></pre><p>输出：</p><pre class=" language-lang-bash"><code class="language-lang-bash">func Apanic: panic in Bgoroutine 1 [running]:main.funcB(...)        .../code/func/main.go:12main.main()        .../code/func/main.go:20 +0x98</code></pre><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><pre class=" language-lang-go"><code class="language-lang-go">func funcA() {    fmt.Println("func A")}func funcB() {    defer func() {        err := recover()        //如果程序出出现了panic错误,可以通过recover恢复过来        if err != nil {            fmt.Println("recover in B")        }    }()    panic("panic in B")}func funcC() {    fmt.Println("func C")}func main() {    funcA()    funcB()    funcC()}</code></pre><p><strong>注意：</strong></p><ol><li><code>recover()</code>必须搭配<code>defer</code>使用。</li><li><code>defer</code>一定要在可能引发<code>panic</code>的语句之前定义。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 函数与接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 函数与接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2021/120327497.html"/>
      <url>/2021/120327497.html</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>接口是一种抽象类型。</p><p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的体现。</p><p>接口做的事情是定义一个协议，不关心属性(数据)，只关心行为(方法)</p><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>Go语言提倡面向接口编程</p><p>每个接口由数个方法组成，接口的定义格式：</p><pre class=" language-lang-go"><code class="language-lang-go">type 接口名 interface{    方法名1( 参数列表1 ) 返回值列表1    方法名2( 参数列表2 ) 返回值列表2}</code></pre><p>其中：</p><ul><li>接口名：使用<code>type</code>将接口定义为自定义的类型名，Go的接口在命名时通常在单词后面添加<code>er</code></li><li>方法名：可以公有也可以私有</li><li>参数列表、返回值列表：参数变量名可以省略</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">type writer interface{    Write([]byte) error}</code></pre><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个对象只要实现了接口中的全部方法，就实现了这个接口，所以接口就是一个需要实现的方法列表。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">// Sayer 接口type Sayer interface {    say()}</code></pre><pre class=" language-lang-go"><code class="language-lang-go">//定义dog和cat两个结构体：type dog struct {}type cat struct {}// dog实现了Sayer接口func (d dog) say() {    fmt.Println("汪汪汪")}// cat实现了Sayer接口func (c cat) say() {    fmt.Println("喵喵喵")}</code></pre><h3 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h3><p>实现了接口，就可以通过接口实现多态</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var x Sayer // 声明一个Sayer类型的变量x    a := cat{}  // 实例化一个cat    b := dog{}  // 实例化一个dog    x = a       // 可以把cat实例直接赋值给x    x.say()     // 喵喵喵    x = b       // 可以把dog实例直接赋值给x    x.say()     // 汪汪汪}</code></pre><h3 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h3><p><strong>使用值接收者实现接口后</strong></p><p>不管是类型变量，还是指针类型变量，都可以赋给该接口变量</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func (d dog) move() {    fmt.Println("狗会动")}func main() {    var x Mover    var wangcai = dog{} // 旺财是dog类型    x = wangcai         // x可以接收dog类型    var fugui = &dog{}  // 富贵是*dog类型    x = fugui           // x可以接收*dog类型}</code></pre><p><strong>使用指针接收者实现接口后：</strong></p><p>只有指针类型变量可以赋给该接口变量</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func (d *dog) move() {    fmt.Println("狗会动")}func main() {    var x Mover    var wangcai = dog{} // 旺财是dog类型    x = wangcai         // x不可以接收dog类型    var fugui = &dog{}  // 富贵是*dog类型    x = fugui           // x可以接收*dog类型}</code></pre><h3 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h3><p>一个类型可以实现多个接口，且接口直接相互独立。</p><p>多个类型也可以实现一个接口。</p><h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>接口之间可以嵌套产生新的接口，这里类似继承的关系</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">// Sayer 接口type Sayer interface {    say()}// Mover 接口type Mover interface {    move()}// 接口嵌套type animal interface {    Sayer    Mover}</code></pre><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><h5 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h5><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><pre class=" language-lang-go"><code class="language-lang-go">// 定义一个空接口xvar x interface{}</code></pre><h5 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h5><p><strong>空接口作为函数的参数</strong></p><p>使用空接口实现可以接收任意类型的函数参数。</p><pre class=" language-lang-go"><code class="language-lang-go">// 空接口作为函数参数func show(a interface{}) {    fmt.Printf("type:%T value:%v\n", a, a)}</code></pre><p><strong>空接口作为map的值</strong></p><p>使用空接口实现可以保存任意值的字典。</p><pre class=" language-lang-go"><code class="language-lang-go">// 空接口作为map值var studentInfo = make(map[string]interface{})</code></pre><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><h5 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h5><p>接口值是由<code>具体类型</code>和<code>具体类型的值</code>两部分组成，这两部分称为接口的<code>动态类型</code>和<code>动态值</code></p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var w io.Writerw = os.Stdoutw = new(bytes.Buffer)w = nil</code></pre><p><img src="https://www.liwenzhou.com/images/Go/interface/interface.png" alt="接口值图解"></p><h5 id="类型断言-1"><a href="#类型断言-1" class="headerlink" title="类型断言"></a>类型断言</h5><p>判断空接口中的值可以使用类型断言：</p><pre class=" language-lang-go"><code class="language-lang-go">x.(T)</code></pre><p>其中：</p><ul><li>x：表示类型为<code>interface{}</code>的变量</li><li>T：表示断言x可能的类型</li></ul><p>该函数返回两个参数</p><ul><li>参数一：x转化为T类型后的变量</li><li>参数二：如果断言正确则为<code>true</code>，否则为<code>false</code></li></ul><p>可以使用<code>switch</code>语句实现多次断言</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">switch v := x.(type) {    case string:    fmt.Printf("x is a string，value is %v\n", v)    case int:    fmt.Printf("x is a int is %v\n", v)    case bool:    fmt.Printf("x is a bool is %v\n", v)    default:    fmt.Println("unsupport type！")}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 函数与接口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 函数与接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包</title>
      <link href="/2021/120338068.html"/>
      <url>/2021/120338068.html</url>
      
        <content type="html"><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p><code>包(package)</code>是多个Go源码的集合，Go语言提供了许多内置包，如</p><ul><li><code>fmt</code></li><li><code>os</code></li><li><code>io</code></li></ul><h3 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h3><p>包可以理解为存放<code>.go</code>文件的文件夹</p><p>该文件夹下的所有go文件需要在代码第一行添加</p><pre class=" language-lang-go"><code class="language-lang-go">package 包名</code></pre><p>作用是声明文件所属的包</p><p>注意：</p><ul><li>一个文件夹下的文件只能归属于一个package</li><li>一个package的文件只能在一个文件夹下</li><li>包名可以和文件夹的名字不一样，不能包含<code>-</code>符号</li><li>包名为<code>main</code>的包是应用程序的入口包，这个包编译后会得到一个可执行文件</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>在包外引用包内部的标识符，则该标识符必须对外可见。</p><p>在Go语言中通过将标识符首字母大写表示标识符对外可见。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">// 首字母大写，外部包可见，可在其他包中使用func Add(x, y int) int {    return x + y}func age() { // 首字母小写，外部包不可见，只能在当前包内使用    var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用    fmt.Println(Age)}</code></pre><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>在代码中引入其他包的内容，需要通过<code>import</code>导入使用的包：</p><pre class=" language-lang-go"><code class="language-lang-go">import "包的路径"</code></pre><p>注意：</p><ul><li><code>import</code>导入语句通常放在包声明语句的下方</li><li>导入的包名需要通过双引号包裹</li><li>包名是从<code>$GOPATH/src/</code>后开始计算</li><li>Go语言中禁止循环导入包</li></ul><h5 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h5><p>单行导入：</p><pre class=" language-lang-go"><code class="language-lang-go">import "Bag1"import "Bag2"</code></pre><p>多行导入：</p><pre class=" language-lang-go"><code class="language-lang-go">import{    "bag1"    "bag2"}</code></pre><h5 id="自定义包名"><a href="#自定义包名" class="headerlink" title="自定义包名"></a>自定义包名</h5><p>导入包时，可以为导入的包设置别名，格式：</p><pre class=" language-lang-go"><code class="language-lang-go">import 别名 "包的路径"</code></pre><p>多行导入时，格式为：</p><pre class=" language-lang-go"><code class="language-lang-go">import{    别名1 "路径1"    别名2 "路径2"}</code></pre><h5 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a>匿名导入包</h5><p>如果只希望导入包，不使用内部数据时，可以匿名导入包，格式为：</p><pre class=" language-lang-go"><code class="language-lang-go">import _ "包的路径"</code></pre><p>匿名导入的包与其他方式导入的包一样会编译入可执行文件中</p><p>这里是为了利用包的<code>init</code>初始化函数或者包级变量的初始化表达式，但同时又避免没有使用包内数据带来的<code>unused import</code>编译错误</p><p>举例：<code>image/png</code>包的注册</p><pre class=" language-lang-go"><code class="language-lang-go">package png // image/pngfunc Decode(r io.Reader) (image.Image, error)func DecodeConfig(r io.Reader) (image.Config, error)func init() {    const pngHeader = "\x89PNG\r\n\x1a\n"    image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)}</code></pre><blockquote><p>Go图像的解码器通过一个驱动入口使用，而驱动入口时通过调用<code>image.RegisterFormat</code>函数注册，一般是在每个格式包的<code>init</code>初始化函数中调用。</p><p>在例子中的最终效果是，主程序只需要匿名导入特定图像驱动包，就可以使用<code>image.Decode</code>解码对应格式的图像了。</p><p>数据库<code>database/sql</code>也采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。</p></blockquote><h3 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a>init()初始化函数</h3><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。</p><ul><li><code>init()</code>函数没有参数，没有返回值</li><li><code>init()</code>函数在程序运行时自动调用执行，不能被主动调用。</li></ul><p>包初始化执行的顺序：</p><p><img src="https://www.liwenzhou.com/images/Go/package/init01.png" alt="包中的init()执行时机"></p><h5 id="init-函数执行顺序"><a href="#init-函数执行顺序" class="headerlink" title="init() 函数执行顺序"></a><code>init()</code> 函数执行顺序</h5><p>Go语言中，包会从<code>main</code>包开始检查导入的所有包，每个包又可能导入了其他的包，Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译</title>
      <link href="/2021/120360503.html"/>
      <url>/2021/120360503.html</url>
      
        <content type="html"><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h4 id="go-build编译go文件"><a href="#go-build编译go文件" class="headerlink" title="go build编译go文件"></a><code>go build</code>编译go文件</h4><ol><li>在项目目录下执行<code>go build</code></li><li>在其他地方执行<code>go build src后的路径</code></li><li><code>go build -o xxx.exe</code>取名</li></ol><h4 id="go-run直接运行go文件"><a href="#go-run直接运行go文件" class="headerlink" title="go run直接运行go文件"></a><code>go run</code>直接运行go文件</h4><h4 id="go-install编译go文件并将编译结果移动到bin"><a href="#go-install编译go文件并将编译结果移动到bin" class="headerlink" title="go install编译go文件并将编译结果移动到bin"></a><code>go install</code>编译go文件并将编译结果移动到bin</h4><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>Go支持跨平台编译</p><p>比如：在windows平台编译一个能在linux平台执行的可执行文件</p><pre><code>SET CGO_ENABLED=0    //禁用CGOSET GOOS=linux        //目标平台是linuxSET GOARCH=amd64    //目标处理器架构是amd64</code></pre><p>执行<code>go build</code></p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量与常量</title>
      <link href="/2021/120224977.html"/>
      <url>/2021/120224977.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>与C类似，只能以字母，下划线，数字组成且不能由数字开始，推荐使用驼峰式命名</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字是编程语言中预先定义好的具有特殊含义的标识符</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Go语言的每一个变量都有自己的类型，需要提前声明</p><p>go语言的变量声明格式为</p><pre class=" language-lang-go"><code class="language-lang-go">var 变量名 变量类型</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">var name stringvar age intvar isOk bool</code></pre><h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><pre class=" language-lang-go"><code class="language-lang-go">var(    a string    b int    c bool    d float32)</code></pre><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>声明代码同时赋值可以自动检测类型</p><p>举例： <code>var name = "Hanmur"</code></p><h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><p>只能在函数里面使用，声明代码同时赋值的一种方式</p><p>举例： <code>h3 := "hhh"</code></p><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>在使用多重赋值时，如果想忽略某个值，可以使用匿名变量：<code>_</code></p><p>举例： </p><pre class=" language-lang-go"><code class="language-lang-go">func foo()(int, string){    return 100, "Hanmur"}func main(){    x, _ := foo()    //将100赋值与x    _, y := foo()    //将Hanmur赋值与y}</code></pre><p>匿名变量不占用命名空间，不分配内存，多用于占位表示忽略值</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>变量具有生命期，在声明开始到自身所在语句块结束。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>go语言的常量声明格式为</p><p><code>const pi = 3.1415</code></p><h3 id="批量声明-1"><a href="#批量声明-1" class="headerlink" title="批量声明"></a>批量声明</h3><pre class=" language-lang-go"><code class="language-lang-go">const(    pi = 3.1415926    USER = "Hanmur")</code></pre><p>注意批量声明中如果在后面的值没有被初始化会默认和上面一行一致</p><pre class=" language-lang-go"><code class="language-lang-go">const(            //n1 = n2 = n3 = 100    n1 = 100    n2    n3)</code></pre><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota是go语言的常量计数器，只能在常量的表达式中使用</p><p><code>iota</code>在<code>const</code>出现时被重置为零</p><p><code>const</code>中每新增一行声明使iota计数一次</p><p>（类似C++的枚举使用）</p><pre class=" language-lang-go"><code class="language-lang-go">const(    n1 = iota     //0    n2 = iota    //1    n3 = iota    //2)</code></pre><p>应用：定义数量级</p><pre class=" language-lang-go"><code class="language-lang-go">const(    _ = iota    //0    KB = 1 << (10 * iota) //1024    MB = 1 << (10 * iota) //1024^2    GB = 1 << (10 * iota) //1024^3    TB = 1 << (10 * iota) //1024^4    PB = 1 << (10 * iota) //1024^5)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2021/120253772.html"/>
      <url>/2021/120253772.html</url>
      
        <content type="html"><![CDATA[<h1 id="反射（不熟练）"><a href="#反射（不熟练）" class="headerlink" title="反射（不熟练）"></a>反射（不熟练）</h1><h3 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h3><p>Go语言中的变量分为两部分：</p><ul><li>类型信息：预先定义好的原信息</li><li>值信息：程序运行中可动态变化的信息</li></ul><h3 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h3><p>反射是指在程序运行期对程序本身进行访问和修改的能力。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期使用reflect包访问程序的反射信息。</p><h3 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h3><p>在Go语言的反射机制中，接口值是由<code>具体类型</code>和<code>具体类型的值</code>组成的</p><p>在Go语言中反射的相关功能由<code>reflect</code>包提供</p><p>接口值在反射中可以分为两个部分</p><ul><li><code>reflect.Type</code></li><li><code>reflect.Value</code></li></ul><p><code>reflect</code>包对应提供了两个函数获取对象的<code>Type</code>和<code>Value</code></p><ul><li><code>reflect.TypeOf</code></li><li><code>reflect.ValueOf</code></li></ul><h3 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h3><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象<code>reflect.Type</code></p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">typeX := reflect.TypeOf(x)fmt.Printf("%v\n", typeX)</code></pre><h5 id="type-name-和-type-kind"><a href="#type-name-和-type-kind" class="headerlink" title="type name 和 type kind"></a>type name 和 type kind</h5><p>在反射中，类型又划分为两种：</p><ul><li>名字（Name）：可以使用type关键字自定义的类型名</li><li>种类（Kind）：底层的类型</li></ul><pre class=" language-lang-go"><code class="language-lang-go">typeX := reflect.TypeOf(x)fmt.Printf("%v -- %v\n", typeX.Name(), typeX.Kind() )</code></pre><p>其中数组、切片、Map、指针等类型的变量，他们的<code>.Name()</code>均返回<code>空</code></p><p>在<code>reflect</code>包定义的Kind类型：</p><pre class=" language-lang-go"><code class="language-lang-go">type Kind uintconst (    Invalid Kind = iota  // 非法类型    Bool                 // 布尔型    Int                  // 有符号整型    Int8                 // 有符号8位整型    Int16                // 有符号16位整型    Int32                // 有符号32位整型    Int64                // 有符号64位整型    Uint                 // 无符号整型    Uint8                // 无符号8位整型    Uint16               // 无符号16位整型    Uint32               // 无符号32位整型    Uint64               // 无符号64位整型    Uintptr              // 指针    Float32              // 单精度浮点数    Float64              // 双精度浮点数    Complex64            // 64位复数类型    Complex128           // 128位复数类型    Array                // 数组    Chan                 // 通道    Func                 // 函数    Interface            // 接口    Map                  // 映射    Ptr                  // 指针    Slice                // 切片    String               // 字符串    Struct               // 结构体    UnsafePointer        // 底层指针)</code></pre><h3 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h3><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法：</p><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Interface() interface {}</td><td style="text-align:center">将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td></tr><tr><td style="text-align:center">Int() int64</td><td style="text-align:center">将值以 int 类型返回，所有有符号整型均可以此方式返回</td></tr><tr><td style="text-align:center">Uint() uint64</td><td style="text-align:center">将值以 uint 类型返回，所有无符号整型均可以此方式返回</td></tr><tr><td style="text-align:center">Float() float64</td><td style="text-align:center">将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td></tr><tr><td style="text-align:center">Bool() bool</td><td style="text-align:center">将值以 bool 类型返回</td></tr><tr><td style="text-align:center">Bytes() []bytes</td><td style="text-align:center">将值以字节数组 []bytes 类型返回</td></tr><tr><td style="text-align:center">String() string</td><td style="text-align:center">将值以字符串类型返回</td></tr></tbody></table></div><h5 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h5><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func reflectValue(x interface{}) {    v := reflect.ValueOf(x)    k := v.Kind()    switch k {    case reflect.Int64:        // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换        fmt.Printf("type is int64, value is %d\n", int64(v.Int()))    case reflect.Float32:        // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换        fmt.Printf("type is float32, value is %f\n", float32(v.Float()))    case reflect.Float64:        // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换        fmt.Printf("type is float64, value is %f\n", float64(v.Float()))    }}func main() {    var a float32 = 3.14    var b int64 = 100    reflectValue(a) // type is float32, value is 3.140000    reflectValue(b) // type is int64, value is 100    // 将int类型的原始值转换为reflect.Value类型    c := reflect.ValueOf(10)    fmt.Printf("type c :%T\n", c) // type c :reflect.Value}</code></pre><h5 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h5><p>想要在函数中通过反射修改变量的值，必须传递变量地址才能修改变量值。</p><p>反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func reflectSetValue1(x interface{}) {    v := reflect.ValueOf(x)    if v.Kind() == reflect.Int64 {        v.SetInt(200) //修改的是副本，reflect包会引发panic    }}func reflectSetValue2(x interface{}) {    v := reflect.ValueOf(x)    // 反射中使用 Elem()方法获取指针对应的值    if v.Elem().Kind() == reflect.Int64 {        v.Elem().SetInt(200)    }}func main() {    var a int64 = 100    // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value    reflectSetValue2(&a)    fmt.Println(a)}</code></pre><h5 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a><code>isNil()</code>和<code>isValid()</code></h5><p>判断是否为空<code>IsNil()</code></p><pre class=" language-lang-go"><code class="language-lang-go">func (v Value) IsNil() bool</code></pre><p><code>IsNil()</code>报告v持有的值是否为nil。</p><p>v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则<code>IsNil</code>函数会导致<code>panic</code>。</p><p>判断是否为零<code>IsValid()</code></p><pre class=" language-lang-go"><code class="language-lang-go">func (v Value) IsValid() bool</code></pre><p><code>IsValid()</code>返回<code>v</code>是否持有一个值。</p><p>如果<code>v</code>是<code>Value</code>零值会返回假，此时<code>v</code>除了<code>IsValid</code>、<code>String</code>、<code>Kind</code>之外的方法都会导致<code>panic</code>。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    // *int类型空指针    var a *int    fmt.Println("var a *int IsNil:", reflect.ValueOf(a).IsNil())    // nil值    fmt.Println("nil IsValid:", reflect.ValueOf(nil).IsValid())    // 实例化一个匿名结构体    b := struct{}{}    // 尝试从结构体中查找"abc"字段    fmt.Println("不存在的结构体成员:", reflect.ValueOf(b).FieldByName("abc").IsValid())    // 尝试从结构体中查找"abc"方法    fmt.Println("不存在的结构体方法:", reflect.ValueOf(b).MethodByName("abc").IsValid())    // map    c := map[string]int{}    // 尝试从map中查找一个不存在的键    fmt.Println("map中不存在的键：", reflect.ValueOf(c).MapIndex(reflect.ValueOf("娜扎")).IsValid())}</code></pre><h3 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h3><h5 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h5><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（<code>reflect.Type</code>）的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Field(i int) StructField</td><td style="text-align:center">根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td style="text-align:center">NumField() int</td><td style="text-align:center">返回结构体成员字段数量。</td></tr><tr><td style="text-align:center">FieldByName(name string) (StructField, bool)</td><td style="text-align:center">根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td style="text-align:center">FieldByIndex(index []int) StructField</td><td style="text-align:center">多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td></tr><tr><td style="text-align:center">FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td style="text-align:center">根据传入的匹配函数匹配需要的字段。</td></tr><tr><td style="text-align:center">NumMethod() int</td><td style="text-align:center">返回该类型的方法集中方法的数目</td></tr><tr><td style="text-align:center">Method(int) Method</td><td style="text-align:center">返回该类型方法集中的第i个方法</td></tr><tr><td style="text-align:center">MethodByName(string)(Method, bool)</td><td style="text-align:center">根据方法名返回该类型方法集中的方法</td></tr></tbody></table></div><h5 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h5><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><pre class=" language-lang-go"><code class="language-lang-go">type StructField struct {    // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为""。    // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers    Name    string    PkgPath string    Type      Type      // 字段的类型    Tag       StructTag // 字段的标签    Offset    uintptr   // 字段在结构体中的字节偏移量    Index     []int     // 用于Type.FieldByIndex时的索引切片    Anonymous bool      // 是否匿名字段}</code></pre><h5 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h5><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><pre class=" language-lang-go"><code class="language-lang-go">type student struct {    Name  string `json:"name"`    Score int    `json:"score"`}func main() {    stu1 := student{        Name:  "小王子",        Score: 90,    }    t := reflect.TypeOf(stu1)    fmt.Println(t.Name(), t.Kind()) // student struct    // 通过for循环遍历结构体的所有字段信息    for i := 0; i < t.NumField(); i++ {        field := t.Field(i)        fmt.Printf("name:%s index:%d type:%v json tag:%v\n", field.Name, field.Index, field.Type, field.Tag.Get("json"))    }    // 通过字段名获取指定结构体字段信息    if scoreField, ok := t.FieldByName("Score"); ok {        fmt.Printf("name:%s index:%d type:%v json tag:%v\n", scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get("json"))    }}</code></pre><p>接下来编写一个函数<code>printMethod(s interface{})</code>来遍历打印s包含的方法。</p><pre class=" language-lang-go"><code class="language-lang-go">// 给student添加两个方法 Study和Sleep(注意首字母大写)func (s student) Study() string {    msg := "好好学习，天天向上。"    fmt.Println(msg)    return msg}func (s student) Sleep() string {    msg := "好好睡觉，快快长大。"    fmt.Println(msg)    return msg}func printMethod(x interface{}) {    t := reflect.TypeOf(x)    v := reflect.ValueOf(x)    fmt.Println(t.NumMethod())    for i := 0; i < v.NumMethod(); i++ {        methodType := v.Method(i).Type()        fmt.Printf("method name:%s\n", t.Method(i).Name)        fmt.Printf("method:%s\n", methodType)        // 通过反射调用方法传递的参数必须是 []reflect.Value 类型        var args = []reflect.Value{}        v.Method(i).Call(args)    }}</code></pre><h1 id="反射的坏处"><a href="#反射的坏处" class="headerlink" title="反射的坏处"></a>反射的坏处</h1><p>反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制</title>
      <link href="/2021/120256303.html"/>
      <url>/2021/120256303.html</url>
      
        <content type="html"><![CDATA[<h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p>Go语言中<code>if</code>条件判断的格式：</p><pre class=" language-lang-go"><code class="language-lang-go">if 表达式1{    分支1}else if 表达式2{    分支2}else{    分支3}</code></pre><h1 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h1><p>Go语言中<code>for</code>循环的格式：</p><pre class=" language-lang-go"><code class="language-lang-go">for 初始语句;条件表达式;结束语句{    循环语句}</code></pre><p>举例：打印1 - 100</p><pre class=" language-lang-go"><code class="language-lang-go">for i:= 1; i <= 100; i++{    fmt.println(i)}</code></pre><p>也可以同时省略初始语句与结束语句，类似<code>while</code></p><pre class=" language-lang-go"><code class="language-lang-go">for 条件表达式{    循环语句}</code></pre><h1 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h1><p>go语言中可以使用<code>for range</code>遍历数组，切片，字符串，map及通道</p><p>通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组，切片，字符串返回索引值</li><li>map返回键和值</li><li>通道只返回通道内的值</li></ol><h1 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h1><p>使用<code>switch</code>语句可方便地对大量数据进行条件判断</p><pre class=" language-lang-go"><code class="language-lang-go">n1 := 1switch(n1){case 1:    语句1case 2:    语句2default:    语句3}</code></pre><blockquote><p>在go中一个分支可以有多个值</p><p>如：<code>case 1, 2, 3:</code></p><p>分支也可以使用表达式</p><p>如：<code>case age &lt; 25:</code></p><p><code>fallthrough</code>语法可以执行满足case的下一个case</p><p>是为了兼容C中的case而设计的</p></blockquote><h1 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h1><p><code>break</code>语句常用于中断当前for循环或跳出switch语句</p><p><code>continue</code>语句跳过当前循环的剩余语句，继续进行下一循环</p><p><code>goto</code>语句 将控制转移到被标记的语句</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2021/12024074.html"/>
      <url>/2021/12024074.html</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table></div><p>注意： <code>++</code> 和 <code>--</code>是单独的语句，不是运算符</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>是否相等</td></tr><tr><td>!=</td><td>是否不等</td></tr><tr><td>&gt;</td><td>是否大于</td></tr><tr><td>&lt;</td><td>是否小于</td></tr><tr><td>&gt;=</td><td>是否大于等于</td></tr><tr><td>&lt;=</td><td>是否小于等于</td></tr></tbody></table></div><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与逻辑运算</td></tr><tr><td>\</td><td>\</td><td></td><td>或逻辑运算</td></tr><tr><td>!</td><td>非逻辑运算</td></tr></tbody></table></div><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>\</td><td></td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>&lt;&lt;</td><td>左移n位</td></tr><tr><td>&gt;&gt;</td><td>右移n位</td></tr></tbody></table></div><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>赋值运算符</td></tr><tr><td>+=</td><td>相加后赋值</td></tr><tr><td>-=</td><td>相减后赋值</td></tr><tr><td>*=</td><td>相乘后赋值</td></tr><tr><td>/=</td><td>相除后赋值</td></tr><tr><td>%=</td><td>取模后赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>\</td><td>=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile</title>
      <link href="/2021/12027120.html"/>
      <url>/2021/12027120.html</url>
      
        <content type="html"><![CDATA[<h1 id="为Go项目编写Makefile"><a href="#为Go项目编写Makefile" class="headerlink" title="为Go项目编写Makefile"></a>为Go项目编写Makefile</h1><p>借助<code>Makefile</code>我们在编译过程中不再需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程。</p><h2 id="make介绍"><a href="#make介绍" class="headerlink" title="make介绍"></a>make介绍</h2><p><code>make</code>是一个构建自动化工具，会在当前目录下寻找<code>Makefile</code>或<code>makefile</code>文件。如果存在相应的文件，它就会依据其中定义好的规则完成构建任务。</p><h2 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h2><p>我们可以把<code>Makefile</code>简单理解为它定义了一个项目文件的编译规则。借助<code>Makefile</code>我们在编译过程中不再需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程。同时使用<code>Makefile</code>也可以在项目中确定具体的编译规则和流程，很多开源项目中都会定义<code>Makefile</code>文件。</p><p>本文不会详细介绍<code>Makefile</code>的各种规则，只会给出Go项目中常用的<code>Makefile</code>示例。</p><p>关于<code>Makefile</code>的详细内容推荐阅读<a href="http://c.biancheng.net/view/7097.html">Makefile教程</a>。</p><h3 id="规则概述"><a href="#规则概述" class="headerlink" title="规则概述"></a>规则概述</h3><p><code>Makefile</code>由多条规则组成，每条规则主要由两个部分组成，分别是依赖的关系和执行的命令。</p><p>其结构如下所示：</p><pre class=" language-lang-makefile"><code class="language-lang-makefile">[target] ... : [prerequisites] ...<tab>[command]    ...    ...</code></pre><p>其中：</p><ul><li>targets：规则的目标</li><li>prerequisites：可选的要生成 targets 需要的文件或者是目标。</li><li>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li></ul><p>举个例子：</p><pre class=" language-lang-makefile"><code class="language-lang-makefile">build:    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o xx</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class=" language-lang-makefile"><code class="language-lang-makefile">.PHONY: all build run gotool clean helpBINARY="bluebell"all: gotool buildbuild:    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o ${BINARY}run:    @go run ./gotool:    go fmt ./    go vet ./clean:    @if [ -f ${BINARY} ] ; then rm ${BINARY} ; fihelp:    @echo "make - 格式化 Go 代码, 并编译生成二进制文件"    @echo "make build - 编译 Go 代码, 生成二进制文件"    @echo "make run - 直接运行 Go 代码"    @echo "make clean - 移除二进制文件和 vim swap files"    @echo "make gotool - 运行 Go 工具 'fmt' and 'vet'"</code></pre><p>其中：</p><ul><li><code>BINARY="bluebell"</code>是定义变量。</li><li><code>.PHONY</code>用来定义伪目标。不创建目标文件，而是去执行这个目标下面的命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/2021/120260565.html"/>
      <url>/2021/120260565.html</url>
      
        <content type="html"><![CDATA[<h1 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h1><p>整型可以分为两个大类</p><div class="table-container"><table><thead><tr><th>有符号整型</th><th>无符号整型</th></tr></thead><tbody><tr><td>int8</td><td>uint8</td></tr><tr><td>int16</td><td>uint16</td></tr><tr><td>int32</td><td>uint32</td></tr><tr><td>int64</td><td>uint64</td></tr></tbody></table></div><p>其中<code>uint8</code>对应<code>byte</code>型，<code>int16</code>对应<code>short</code>型，<code>int64</code>对应<code>long</code>型</p><p><strong>特殊整型</strong></p><div class="table-container"><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>随操作系统对应32或64</td></tr><tr><td>int</td><td>随操作系统对应32或64</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放指针</td></tr></tbody></table></div><p><strong>八进制&amp;十六进制</strong></p><pre class=" language-lang-go"><code class="language-lang-go">var a int = 10     //10进制var b int = 077    //8进制var c int = 0xff //16进制</code></pre><div class="table-container"><table><thead><tr><th>二进制</th><th>八进制</th><th>十进制</th><th>十六进制</th></tr></thead><tbody><tr><td>%b</td><td>%o</td><td>%d</td><td>%x</td></tr></tbody></table></div><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数分为<code>float32</code>和<code>float64</code></p><p>遵循<code>IEEE 754</code>标准</p><p>对应符号<code>%f</code></p><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>复数分为<code>complex64</code>和<code>complex128</code></p><pre class=" language-lang-go"><code class="language-lang-go">var c1 complex64c1 = 1 + 2ivar c2 complex128c2 = 2 + 3i</code></pre><h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>布尔值<code>bool</code> 只有两个值：<code>true</code>和<code>false</code></p><p>默认值为<code>false</code></p><p>go语言中不允许将整数型强制转换成布尔型</p><p>go语言中也不允许参与数值运算</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Go语言类型转换格式：</p><pre class=" language-lang-go"><code class="language-lang-go">type_name(expression)</code></pre><p><code>type_name</code>为类型，<code>expression</code>为表达式</p><p>举例：将整型转换为浮点型</p><pre class=" language-lang-go"><code class="language-lang-go">var intNum int = 17var floatNum float32floatNum = float32(intNum)    //floatNum = 17</code></pre><p>Go不支持隐式类型转化</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/2021/12026880.html"/>
      <url>/2021/12026880.html</url>
      
        <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中没有类，但是有结构体</p><p>通过结构体的<code>内嵌</code>配合<code>接口</code>实现“没有对象的面向对象编程”</p><h3 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h3><h5 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h5><p>Go语言中使用<code>type</code>关键字定义自定义类型</p><p>自定义类型的格式：</p><pre class=" language-lang-go"><code class="language-lang-go">type NewType Type</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">type MyInt int</code></pre><p>这里<code>MyInt</code>是一个新的类型</p><h5 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h5><p>类型别名是<code>Go1.9</code>添加的功能</p><p>类型别名指：<code>TypeAlias</code>是<code>Type</code>的别名，他们本质上是同一个类型</p><p>类型别名的格式：</p><pre class=" language-lang-go"><code class="language-lang-go">type TypeAlias = Type</code></pre><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">type byte = uint8type rune = int32</code></pre><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><h5 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h5><p>使用<code>Type</code>和<code>struct</code>定义结构体，格式为：</p><pre class=" language-lang-go"><code class="language-lang-go">type 类型名 struct{    字段名 字段类型    字段名 字段类型    ...}</code></pre><p>其中，</p><ul><li>类型名：表示结构体名称</li><li>字段名：结构体中元素名称</li><li>字段类型：结构体中元素类型</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">type person struct{    name, city    string    age            int8}</code></pre><h5 id="结构体成员访问"><a href="#结构体成员访问" class="headerlink" title="结构体成员访问"></a>结构体成员访问</h5><p>通过<code>.</code>访问结构体的字段（成员变量）</p><h3 id="结构体的实例化"><a href="#结构体的实例化" class="headerlink" title="结构体的实例化"></a>结构体的实例化</h3><h5 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h5><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">type person struct {    name string    city string    age  int8}func main() {    var man person    man.name = "康康"    man.city = "广州"    man.age = 17    fmt.Printf("%v\n", man)      //{沙河娜扎 北京 18}    fmt.Printf("%#v\n", man)     //main.person{name:"沙河娜扎", city:"北京", age:18}}</code></pre><h5 id="匿名实例化"><a href="#匿名实例化" class="headerlink" title="匿名实例化"></a>匿名实例化</h5><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var user struct{name string; age int}    user.name = "康康"    user.age = 17    fmt.Printf("%#v\n", user)    //main.person{name:"康康", age:17}}</code></pre><h5 id="指针类型结构体"><a href="#指针类型结构体" class="headerlink" title="指针类型结构体"></a>指针类型结构体</h5><p>使用<code>new</code>得到结构体的地址:</p><pre class=" language-lang-go"><code class="language-lang-go">var man = new(person)// man的类型为 *main.person</code></pre><p>Go语言里支持结构体指针直接使用<code>.</code>访问结构体的成员</p><p>即代码中<code>man.name = "康康"</code>在底层是<code>(*man).name</code> = “康康”</p><p>这是Go语言自动翻译的。</p><h3 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h3><p>没有初始化的结构体，成员变量都是对应的零值</p><h5 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h5><p>使用键值对初始化时，键对应字段，值对应初始值</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">man := person{    name: "康康",    city: "广州",    age:  17,}fmt.Printf("%#v\n", man) //main.person{name:"康康", city:"广州", age:17}</code></pre><p>类似的，结构体指针也可以键值对初始化：</p><pre class=" language-lang-go"><code class="language-lang-go">man := &person{    name: "康康",    city: "广州",    age:  17,}fmt.Printf("%#v\n", man) //&main.person{name:"康康", city:"广州", age:17}</code></pre><p>某些字段没有初始值时可以不写，没有指定初始值的字段值为零值</p><h5 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h5><p>初始化结构体时可以只写值</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">man := &person{    "康康",    "广州",    17,}fmt.Printf("%#v\n", man)//&main.person{name:"康康", city:"广州", age:17}</code></pre><p>用值的列表进行初始化时，结构体的所有字段都需要初始化</p><p>初始值的填充顺序需要和结构体的声明顺序一致。</p><h3 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h3><p>结构体占用一块连续的内存。</p><pre class=" language-lang-go"><code class="language-lang-go">type test struct {    a int8    b int8    c int8    d int8}n := test{    1, 2, 3, 4,}fmt.Printf("n.a %p\n", &n.a)fmt.Printf("n.b %p\n", &n.b)fmt.Printf("n.c %p\n", &n.c)fmt.Printf("n.d %p\n", &n.d)</code></pre><p>输出：</p><pre class=" language-lang-bash"><code class="language-lang-bash">n.a 0xc0000a0060n.b 0xc0000a0061n.c 0xc0000a0062n.d 0xc0000a0063</code></pre><p><a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com">在 Go 中恰到好处的内存对齐</a></p><h5 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h5><p>空结构体是不占用空间的。</p><pre class=" language-lang-go"><code class="language-lang-go">var v struct{}fmt.Println(unsafe.Sizeof(v))  // 0</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Go语言中结构体没有构造函数，但是可以自己实现</p><p>例如：</p><pre class=" language-lang-go"><code class="language-lang-go">func newPerson(name, city string, age int8) *person {    return &person{        name: name,        city: city,        age:  age,    }}func main(){    man := newPerson("康康"，"广州"， 17)    fmt.println(man)}</code></pre><h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h3><p>Go语言中的<code>方法(Method)</code>是一种作用于特定类型变量的函数，这种特定类型变量叫做<code>接收者(Receiver)</code>。接收者类似c中<code>this</code></p><p>方法的定义格式：</p><pre class=" language-lang-go"><code class="language-lang-go">func(接收者变量 接收者类型) 方法名(参数列表)(返回参数){    函数体}</code></pre><p>其中，</p><ul><li>接收者变量：接收者变量官方建议命名是首字母的小写，如<code>Person</code>对应<code>p</code>，<code>Counter</code>对应<code>c</code></li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">//Person 结构体type Person struct {    name string}//NewPerson 构造函数func NewPerson(name string) *Person {    return &Person{        name: name,    }}//Dream Person做梦的方法func (p Person) Dream() {    fmt.Printf("%s的梦想是学好数值计算与分析！\n", p.name)}func main() {    p1 := NewPerson("康康")    p1.Dream()}</code></pre><blockquote><p>非本地类型不能定义方法，也就是说不能给别的包的类型定义方法</p></blockquote><h5 id="值类型与指针类型的接收者"><a href="#值类型与指针类型的接收者" class="headerlink" title="值类型与指针类型的接收者"></a>值类型与指针类型的接收者</h5><p>当方法的接收者是指针时，方法内对接收者的修改在方法外依然有效</p><pre class=" language-lang-go"><code class="language-lang-go">// SetAge 设置p的年龄// 使用指针接收者func (p *Person) SetAge(newAge int8) {    p.age = newAge}</code></pre><p>调用该方法：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    man := NewPerson("康康", 17)    fmt.Println(man.age) // 17    p1.SetAge(18)    fmt.Println(man.age) // 18}</code></pre><p>当方法的接收者是值类型时，方法内对接收者的修改在方法外无效。</p><h3 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h3><p>匿名字段：结构体允许成员字段在声明时没有字段名只有类型</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">//Person 结构体Person类型type Person struct {    string    int}</code></pre><p>这里Person类型的字段名默认为了类型名</p><p>因为字段名称必须唯一，所以同种类型的匿名字段只能有一个</p><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><p>一个结构体中可以嵌套包含其他结构体或结构体指针</p><p>在嵌套结构体中也可以使用匿名字段</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">//Address 地址结构体type Address struct {    Province string    City     string}//User 用户结构体type User struct {    Name    string    Gender  string    Address //匿名字段}</code></pre><h3 id="结构体的”继承“"><a href="#结构体的”继承“" class="headerlink" title="结构体的”继承“"></a>结构体的”继承“</h3><p>Go语言中可以使用结构体实现其他语言中的继承</p><pre class=" language-lang-go"><code class="language-lang-go">//Animal 动物type Animal struct {    name string}//Cat 猫type Cat struct {    Feet    int8    *Animal //通过嵌套匿名结构体实现继承}func main() {    cat := &Cat{        Feet: 4,        Animal: &Animal{ //注意嵌套的是结构体指针            name: "秋收",        },    }    fmt.println(cat)}</code></pre><h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h3><p>结构体中</p><ul><li>字段大写开头表示可公开访问</li><li>字段小写开头表示私有访问（仅在定义当前结构体的包中可访问）</li></ul><h3 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h3><p>结构体-&gt;JSON</p><p>格式：</p><pre class=" language-lang-go"><code class="language-lang-go">JSON数据, err := json.Marshal(结构体)</code></pre><p>JSON-&gt;结构体</p><p>格式：</p><pre class=" language-lang-go"><code class="language-lang-go">err = json.Unmarshal([]byte(JSON字符串), 结构体)</code></pre><h3 id="结构体标签-TAG"><a href="#结构体标签-TAG" class="headerlink" title="结构体标签(TAG)"></a>结构体标签(TAG)</h3><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来</p><p>TAG格式：</p><pre class=" language-lang-bash"><code class="language-lang-bash">`key1:"value1" key2:"value2"`</code></pre><ul><li>结构体tag由一个或多个键值对组成。</li><li>键与值使用冒号分隔，值用双引号括起来。</li><li>同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</li></ul><p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。例如不要在key和value之间添加空格。</p><p> 举例：Student的 <code>json tag</code></p><pre class=" language-lang-go"><code class="language-lang-go">//Student 学生type Student struct {    ID     int    `json:"id"` //通过指定tag实现json序列化该字段时的key    Gender string //json序列化是默认使用字段名作为key    name   string //私有不能被json包访问}//转换的json语句样例//{"id":1,"Gender":"男"}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="/2021/120217741.html"/>
      <url>/2021/120217741.html</url>
      
        <content type="html"><![CDATA[<h1 id="在-Go-中恰到好处的内存对齐"><a href="#在-Go-中恰到好处的内存对齐" class="headerlink" title="在 Go 中恰到好处的内存对齐"></a>在 Go 中恰到好处的内存对齐</h1><p>作者：<a href="https://segmentfault.com/u/eddycjy"><strong>煎鱼</strong></a></p><p>原文地址：<a href="https://link.segmentfault.com/?url=https%3A%2F%2Fbook.eddycjy.com%2Fgolang%2Ftalk%2Fgo-memory-align.html">在 Go 中恰到好处的内存对齐</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>type Part1 struct {    a bool    b int32    c int8    d int64    e byte}</code></pre><p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p><pre><code>func main() {    fmt.Printf("bool size: %d\n", unsafe.Sizeof(bool(true)))    fmt.Printf("int32 size: %d\n", unsafe.Sizeof(int32(0)))    fmt.Printf("int8 size: %d\n", unsafe.Sizeof(int8(0)))    fmt.Printf("int64 size: %d\n", unsafe.Sizeof(int64(0)))    fmt.Printf("byte size: %d\n", unsafe.Sizeof(byte(0)))    fmt.Printf("string size: %d\n", unsafe.Sizeof("EDDYCJY"))}</code></pre><p>输出结果：</p><pre><code>bool size: 1int32 size: 4int8 size: 1int64 size: 8byte size: 1string size: 16</code></pre><p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p><p>真实情况是怎么样的呢？我们实际调用看看，如下：</p><pre><code>type Part1 struct {    a bool    b int32    c int8    d int64    e byte}func main() {    part1 := Part1{}    fmt.Printf("part1 size: %d, align: %d\n", unsafe.Sizeof(part1), unsafe.Alignof(part1))}</code></pre><p>输出结果：</p><pre><code>part1 size: 32, align: 8</code></pre><p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。这充分地说明了先前的计算方式是错误的。为什么呢？</p><p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p><p><img src="https://segmentfault.com/img/remote/1460000017527315?w=319&amp;h=149" alt="image"></p><p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p><p><img src="https://segmentfault.com/img/remote/1460000017527316?w=424&amp;h=149" alt="image"></p><p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p><h3 id="为什么要关心对齐"><a href="#为什么要关心对齐" class="headerlink" title="为什么要关心对齐"></a>为什么要关心对齐</h3><ul><li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li><li>你正在处理向量方面的指令</li><li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li></ul><p>另外作为一个工程师，你也很有必要学习这块知识点哦 :)</p><h3 id="为什么要做对齐"><a href="#为什么要做对齐" class="headerlink" title="为什么要做对齐"></a>为什么要做对齐</h3><ul><li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li><li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li></ul><p><img src="https://segmentfault.com/img/remote/1460000017527317?w=574&amp;h=424" alt="image"></p><p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p><ol><li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li><li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li><li>合并 1-4 字节的数据</li><li>合并后放入寄存器</li></ol><p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作</p><p>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法</p><h3 id="默认系数"><a href="#默认系数" class="headerlink" title="默认系数"></a>默认系数</h3><p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p><ul><li>32 位：4</li><li>64 位：8</li></ul><p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p><h3 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h3><pre><code>func main() {    fmt.Printf("bool align: %d\n", unsafe.Alignof(bool(true)))    fmt.Printf("int32 align: %d\n", unsafe.Alignof(int32(0)))    fmt.Printf("int8 align: %d\n", unsafe.Alignof(int8(0)))    fmt.Printf("int64 align: %d\n", unsafe.Alignof(int64(0)))    fmt.Printf("byte align: %d\n", unsafe.Alignof(byte(0)))    fmt.Printf("string align: %d\n", unsafe.Alignof("EDDYCJY"))    fmt.Printf("map align: %d\n", unsafe.Alignof(map[string]string{}))}</code></pre><p>输出结果：</p><pre><code>bool align: 1int32 align: 4int8 align: 1int64 align: 8byte align: 1string align: 8map align: 8</code></pre><p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐系数。通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p><h3 id="整体对齐"><a href="#整体对齐" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p><h3 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h3><ul><li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>。其偏移量必须为对齐值的整数倍</li><li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li><li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li></ul><h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>接下来我们一起分析一下，“它” 到底经历了些什么，影响了 “预期” 结果</p><div class="table-container"><table><thead><tr><th>成员变量</th><th>类型</th><th>偏移量</th><th>自身占用</th></tr></thead><tbody><tr><td>a</td><td>bool</td><td>0</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>1</td><td>3</td></tr><tr><td>b</td><td>int32</td><td>4</td><td>4</td></tr><tr><td>c</td><td>int8</td><td>8</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>9</td><td>7</td></tr><tr><td>d</td><td>int64</td><td>16</td><td>8</td></tr><tr><td>e</td><td>byte</td><td>24</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>25</td><td>7</td></tr><tr><td>总占用大小</td><td>-</td><td>-</td><td>32</td></tr></tbody></table></div><h3 id="成员对齐-1"><a href="#成员对齐-1" class="headerlink" title="成员对齐"></a>成员对齐</h3><ul><li>第一个成员 a<ul><li>类型为 bool</li><li>大小/对齐值为 1 字节</li><li>初始地址，偏移量为 0。占用了第 1 位</li></ul></li><li>第二个成员 b<ul><li>类型为 int32</li><li>大小/对齐值为 4 字节</li><li>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li></ul></li><li>第三个成员 c<ul><li>类型为 int8</li><li>大小/对齐值为 1 字节</li><li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li></ul></li><li>第四个成员 d<ul><li>类型为 int64</li><li>大小/对齐值为 8 字节</li><li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li></ul></li><li>第五个成员 e<ul><li>类型为 byte</li><li>大小/对齐值为 1 字节</li><li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li></ul></li></ul><h3 id="整体对齐-1"><a href="#整体对齐-1" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p><p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过本节的分析，可得知先前的 “推算” 为什么错误？</p><p>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p><h2 id="巧妙的结构体"><a href="#巧妙的结构体" class="headerlink" title="巧妙的结构体"></a>巧妙的结构体</h2><p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 :-)</p><pre><code>type Part1 struct {    a bool    b int32    c int8    d int64    e byte}type Part2 struct {    e byte    c int8    a bool    b int32    d int64}func main() {    part1 := Part1{}    part2 := Part2{}    fmt.Printf("part1 size: %d, align: %d\n", unsafe.Sizeof(part1), unsafe.Alignof(part1))    fmt.Printf("part2 size: %d, align: %d\n", unsafe.Sizeof(part2), unsafe.Alignof(part2))}</code></pre><p>输出结果：</p><pre><code>part1 size: 32, align: 8part2 size: 16, align: 8</code></pre><p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p><p>接下来我们一起剖析一下 <code>Part2</code>，看看它的内部到底和上一位之间有什么区别，才导致了这样的结果？</p><h3 id="分析流程-1"><a href="#分析流程-1" class="headerlink" title="分析流程"></a>分析流程</h3><div class="table-container"><table><thead><tr><th>成员变量</th><th>类型</th><th>偏移量</th><th>自身占用</th></tr></thead><tbody><tr><td>e</td><td>byte</td><td>0</td><td>1</td></tr><tr><td>c</td><td>int8</td><td>1</td><td>1</td></tr><tr><td>a</td><td>bool</td><td>2</td><td>1</td></tr><tr><td>字节对齐</td><td>无</td><td>3</td><td>1</td></tr><tr><td>b</td><td>int32</td><td>4</td><td>4</td></tr><tr><td>d</td><td>int64</td><td>8</td><td>8</td></tr><tr><td>总占用大小</td><td>-</td><td>-</td><td>16</td></tr></tbody></table></div><h4 id="成员对齐-2"><a href="#成员对齐-2" class="headerlink" title="成员对齐"></a>成员对齐</h4><ul><li>第一个成员 e<ul><li>类型为 byte</li><li>大小/对齐值为 1 字节</li><li>初始地址，偏移量为 0。占用了第 1 位</li></ul></li><li>第二个成员 c<ul><li>类型为 int8</li><li>大小/对齐值为 1 字节</li><li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li></ul></li><li>第三个成员 a<ul><li>类型为 bool</li><li>大小/对齐值为 1 字节</li><li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li></ul></li><li>第四个成员 b<ul><li>类型为 int32</li><li>大小/对齐值为 4 字节</li><li>根据规则1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li></ul></li><li>第五个成员 d<ul><li>类型为 int64</li><li>大小/对齐值为 8 字节</li><li>根据规则1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li></ul></li></ul><h4 id="整体对齐-2"><a href="#整体对齐-2" class="headerlink" title="整体对齐"></a>整体对齐</h4><p>符合规则 2，不需要额外对齐</p><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>Part2 内存布局：ecax|bbbb|dddd|dddd</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p><ul><li>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</li><li>Part2：ecax|bbbb|dddd|dddd</li></ul><p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p><p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p><p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p><p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片</title>
      <link href="/2021/120223369.html"/>
      <url>/2021/120223369.html</url>
      
        <content type="html"><![CDATA[<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p><code>slice</code>切片是一个拥有相同类型元素的可变长度的序列</p><p>它是基于数组类型的一层封装</p><p>它非常的灵活，支持自动扩容</p><p>切片是一个引用类型</p><p>它内部包括<code>地址</code> <code>长度</code> <code>容量</code></p><p>切片一般用来快速地操作一块数据集合</p><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>声明切片类型的语法：</p><pre class=" language-lang-go"><code class="language-lang-go">var name []T</code></pre><p>其中<code>name</code>指变量名，<code>T</code>指切片中的元素类型</p><p>举例：定义一个存放<code>int</code>类型的切片</p><pre class=" language-lang-go"><code class="language-lang-go">var name []int</code></pre><p>初始化：</p><pre class=" language-lang-go"><code class="language-lang-go">var isMe []bool{false, true}</code></pre><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量</p><p>可以通过<code>len()</code>函数求长度，<code>cap()</code>函数求容量</p><p>切片的容量是指底层数组的容量</p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20210721234733324.png" alt="image-20210721234733324"></p><h3 id="由数组得到切片"><a href="#由数组得到切片" class="headerlink" title="由数组得到切片"></a>由数组得到切片</h3><pre class=" language-lang-go"><code class="language-lang-go">a1 := [...]int{1, 3, 5, 7, 9, 11, 13}s1 := a1[0:4]    //基于a1切割，左闭右开（左右都支持缺省）</code></pre><p>切片也可以从切片中再切片，方式和数组类似</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>如果要动态地创建一个切片，我们需要使用<code>make()</code>函数：</p><pre class=" language-lang-go"><code class="language-lang-go">make([]T, size, cap)</code></pre><p>其中</p><ul><li><code>T</code>是切片的元素类型</li><li><code>size</code>是切片中元素的数量</li><li><code>cap</code>是切片的容量</li></ul><h3 id="切片之间不能相互比较"><a href="#切片之间不能相互比较" class="headerlink" title="切片之间不能相互比较"></a>切片之间不能相互比较</h3><p>不能用<code>==</code>操作符来判断两个切片是否含有全部相等元素</p><p>切片唯一合法的比较操作是和<code>nil</code>比较</p><p>一个<code>nil</code>的切片并没有底层数组</p><p><code>nil</code>值的切片的长度和容量都是0</p><p>但是并不是一个长度和容量都是0的切片是<code>nil</code></p><p>要判断一个切片是否为空，要用<code>len(s) == 0</code>来判断</p><h3 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h3><p>切片是引用！</p><p>切片是引用！</p><p>切片是引用！</p><h3 id="append-方法为切片增加元素"><a href="#append-方法为切片增加元素" class="headerlink" title="append()方法为切片增加元素"></a>append()方法为切片增加元素</h3><h5 id="append-可以为切片动态添加元素。"><a href="#append-可以为切片动态添加元素。" class="headerlink" title="append()可以为切片动态添加元素。"></a><code>append()</code>可以为切片动态添加元素。</h5><p>可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><pre class=" language-lang-go"><code class="language-lang-go">func main(){    var s []int    s = append(s, 1)        // [1]    s = append(s, 2, 3, 4)  // [1 2 3 4]    s2 := []int{5, 6, 7}      s = append(s, s2...)    // [1 2 3 4 5 6 7]}</code></pre><p><strong>注意：</strong>通过<code>var</code>声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><pre class=" language-lang-go"><code class="language-lang-go">var s []ints = append(s, 1, 2, 3)</code></pre><h5 id="append方法使得切片扩容"><a href="#append方法使得切片扩容" class="headerlink" title="append方法使得切片扩容"></a><code>append</code>方法使得切片扩容</h5><p>当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。</p><p>“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    //append()添加元素和切片扩容    var numSlice []int    for i := 0; i < 10; i++ {        numSlice = append(numSlice, i)        fmt.Printf("%v  len:%d  cap:%d  ptr:%p\n", numSlice, len(numSlice), cap(numSlice), numSlice)    }}</code></pre><p>输出：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[0]  len:1  cap:1  ptr:0xc0000a8000[0 1]  len:2  cap:2  ptr:0xc0000a8040[0 1 2]  len:3  cap:4  ptr:0xc0000b2020[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000</code></pre><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>每次扩容后都是扩容前的2倍。</li></ol><h3 id="copy-函数复制切片"><a href="#copy-函数复制切片" class="headerlink" title="copy()函数复制切片"></a><code>copy()</code>函数复制切片</h3><p>由于切片是引用类型，所以直接将切片赋值给其他切片传递的是引用</p><p>而<code>copy()</code>函数将一个切片空间的数据复制到另外一个切片空间中</p><p><code>copy()</code>函数的使用格式如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">copy(destSlice, srcSlice []T)</code></pre><p>其中：</p><ul><li><code>srcSlice</code>: 数据来源切片</li><li><code>destSlice</code>: 目标切片</li><li><code>T</code>:类型</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    // copy()复制切片    destSlice := []int{1, 2, 3, 4, 5}    srcSlice := make([]int, 5, 5)    copy(destSlice, srcSlice)     //使用copy()函数    fmt.Println(destSlice)     //[1 2 3 4 5]    fmt.Println(srcSlice)     //[1 2 3 4 5]    srcSlice[0] = 1000        //改变srcSlice中的值    fmt.Println(destSlice)    //[1 2 3 4 5]    fmt.Println(srcSlice)     //[1000 2 3 4 5]}</code></pre><h3 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h3><p>Go语言中没有删除切片元素的方法</p><p>我们可以用切片的特性删除元素</p><pre class=" language-lang-go"><code class="language-lang-go">n := []int{1, 2, 3, 4, 5, 6, 7}n = append(n[:2], n[3:]...)        //将除2号索引之外的元素加入n中</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片的小技巧</title>
      <link href="/2021/120222742.html"/>
      <url>/2021/120222742.html</url>
      
        <content type="html"><![CDATA[<h2 id="切片操作常用技巧"><a href="#切片操作常用技巧" class="headerlink" title="切片操作常用技巧"></a>切片操作常用技巧</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>将切片a中的元素复制到切片b中。</p><p>最简单的、最常用的方法就是使用内置的<code>copy</code>函数。</p><pre class=" language-lang-go"><code class="language-lang-go">b = make([]T, len(a))  // 一次将内存申请到位copy(b, a)</code></pre><p>除了使用内置的<code>copy</code>函数外，还有下面两种使用<code>append</code>函数复制切片的方法。</p><pre class=" language-lang-go"><code class="language-lang-go">b = append([]T(nil), a...)b = append(a[:0:0], a...)</code></pre><p>这两种方法通常比使用<code>copy</code>函数复制的方法要慢一些，但是如果在复制之后有更多的元素要添加到b中，那么它们的效率会更高。</p><h3 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h3><p>将切片a中索引i~j位置的元素剪切掉。</p><p>可以按照下面的方式，使用<code>append</code>函数完成。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a[:i], a[j:]...)</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>将切片a中索引位置为i的元素删除。</p><p>同样可以按照上面剪切的方式使用<code>append</code>函数完成删除操作。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a[:i], a[i+1:]...)</code></pre><p>或者搭配<code>copy</code>函数使用切片表达式完成删除操作。</p><pre class=" language-lang-go"><code class="language-lang-go">a = a[:i+copy(a[i:], a[i+1:])]</code></pre><p>此外，如果只需要删除掉索引为i的元素，无需保留切片元素原有的顺序，那么还可以使用下面这种简单的方式进行删除。</p><pre class=" language-lang-go"><code class="language-lang-go">a[i] = a[len(a)-1]  // 将最后一个元素移到索引i处a = a[:len(a)-1]    // 截掉最后一个元素</code></pre><h3 id="剪切或删除操作可能引起的内存泄露"><a href="#剪切或删除操作可能引起的内存泄露" class="headerlink" title="剪切或删除操作可能引起的内存泄露"></a>剪切或删除操作可能引起的内存泄露</h3><p>需要特别注意的是。如果切片a中的元素是一个指针类型或包含指针字段的结构体类型（需要被垃圾回收），上面剪切和删除的示例代码会存在一个潜在的内存泄漏问题：一些具有值的元素仍被切片a引用，因此无法被垃圾回收机制回收掉。下面的代码可以解决这个问题。</p><h4 id="剪切-1"><a href="#剪切-1" class="headerlink" title="剪切"></a>剪切</h4><pre class=" language-lang-go"><code class="language-lang-go">copy(a[i:], a[j:])for k, n := len(a)-j+i, len(a); k < n; k++ {    a[k] = nil // 或类型T的零值}a = a[:len(a)-j+i]</code></pre><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><pre class=" language-lang-go"><code class="language-lang-go">copy(a[i:], a[i+1:])a[len(a)-1] = nil // 或类型T的零值a = a[:len(a)-1]</code></pre><h4 id="删除但不保留元素原有顺序"><a href="#删除但不保留元素原有顺序" class="headerlink" title="删除但不保留元素原有顺序"></a>删除但不保留元素原有顺序</h4><pre class=" language-lang-go"><code class="language-lang-go">a[i] = a[len(a)-1]a[len(a)-1] = nila = a[:len(a)-1]</code></pre><h3 id="内部扩张"><a href="#内部扩张" class="headerlink" title="内部扩张"></a>内部扩张</h3><p>在切片a的索引i之后扩张j个元素。</p><p>使用两个<code>append</code>函数完成，即先将索引i之后的元素追加到一个长度为j的切片后，再将这个切片中的所有元素追加到切片a的索引i之后。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a[:i], append(make([]T, j), a[i:]...)...)</code></pre><p>扩张的这一部分元素为T类型的零值。</p><h3 id="尾部扩张"><a href="#尾部扩张" class="headerlink" title="尾部扩张"></a>尾部扩张</h3><p>将切片a的尾部扩张j个元素的空间。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a, make([]T, j)...)</code></pre><p>扩张的这一部分元素同样为T类型的零值。</p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>按照一定的规则将切片a中的元素进行就地过滤。</p><p>这里假设过滤的条件已封装为<code>keep</code>函数，使用<code>for range</code>遍历切片a的所有元素逐一调用<code>keep</code>函数进行过滤。</p><pre class=" language-lang-go"><code class="language-lang-go">n := 0for _, x := range a {    if keep(x) {        a[n] = x  // 保留该元素        n++    }}a = a[:n]  // 截取切片中需保留的元素</code></pre><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>将元素x插入切片a的索引i处。</p><p>还是使用两个<code>append</code>函数完成插入x的操作。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a[:i], append([]T{x}, a[i:]...)...)</code></pre><p>第二个<code>append</code>函数创建了一个具有自己底层数组的新切片，并将<code>a[i:]</code>中的元素复制到该切片，然后由第一个<code>append</code>函数将这些元素复制回切片a。</p><p>我们可以通过使用另一种方法来避免新切片的创建（以及由此产生的内存垃圾）和第二个副本：</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a, 0 /* 这里应使用元素类型的零值 */)copy(a[i+1:], a[i:])a[i] = x</code></pre><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>将元素x追加到切片a的最后。</p><p>这里使用<code>append</code>函数即可。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append(a, x)</code></pre><h3 id="弹出"><a href="#弹出" class="headerlink" title="弹出"></a>弹出</h3><p>将切片a的最后一个元素弹出。</p><p>这里使用切片表达式完成弹出操作。</p><pre class=" language-lang-go"><code class="language-lang-go">x, a = a[len(a)-1], a[:len(a)-1]</code></pre><p>弹出切片a的第一个元素。</p><pre class=" language-lang-go"><code class="language-lang-go">x, a = a[0], a[1:]</code></pre><h3 id="前插"><a href="#前插" class="headerlink" title="前插"></a>前插</h3><p>将元素x前插到切片a的开始。</p><pre class=" language-lang-go"><code class="language-lang-go">a = append([]T{x}, a...)</code></pre><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><h3 id="过滤而不分配内存"><a href="#过滤而不分配内存" class="headerlink" title="过滤而不分配内存"></a>过滤而不分配内存</h3><p>此技巧使用了一个事实，即切片b与原始切片a共享相同的底层数组和容量，因此原存储空间已重新用于过滤后的切片。当然原始切片的内容被修改了。</p><pre class=" language-lang-go"><code class="language-lang-go">b := a[:0]for _, x := range a {    if f(x) {        b = append(b, x)    }}</code></pre><p>对于必须被垃圾回收的元素，在完成上述操作后可以添加以下代码：</p><pre class=" language-lang-go"><code class="language-lang-go">for i := len(b); i < len(a); i++ {    a[i] = nil // 或T类型的零值}</code></pre><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>将切片a的元素顺序翻转。</p><p>通过迭代两两互换元素完成。</p><pre class=" language-lang-go"><code class="language-lang-go">for i := len(a)/2-1; i >= 0; i-- {    opp := len(a)-1-i    a[i], a[opp] = a[opp], a[i]}</code></pre><p>同样的操作：</p><pre class=" language-lang-go"><code class="language-lang-go">for left, right := 0, len(a)-1; left < right; left, right = left+1, right-1 {    a[left], a[right] = a[right], a[left]}</code></pre><h3 id="洗牌"><a href="#洗牌" class="headerlink" title="洗牌"></a>洗牌</h3><p>打乱切片a中元素的顺序。</p><p>Fisher–Yates算法：</p><pre class=" language-lang-go"><code class="language-lang-go">for i := len(a) - 1; i > 0; i-- {    j := rand.Intn(i + 1)    a[i], a[j] = a[j], a[i]}</code></pre><p>从go1.10开始，可以使用<a href="https://pkg.go.dev/math/rand?utm_source=godoc#Shuffle">math/rand.Shuffle</a>。</p><pre class=" language-lang-go"><code class="language-lang-go">rand.Shuffle(len(a), func(i, j int) {    a[i], a[j] = a[j], a[i]})</code></pre><h3 id="使用最小分配进行批处理"><a href="#使用最小分配进行批处理" class="headerlink" title="使用最小分配进行批处理"></a>使用最小分配进行批处理</h3><p>如果你想对一个大型切片a的元素分批进行处理，这会很有用。</p><pre class=" language-lang-go"><code class="language-lang-go">actions := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}batchSize := 3batches := make([][]int, 0, (len(actions) + batchSize - 1) / batchSize)for batchSize < len(actions) {    actions, batches = actions[batchSize:], append(batches, actions[0:batchSize:batchSize])}batches = append(batches, actions)</code></pre><p>得到的效果如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[0 1 2] [3 4 5] [6 7 8] [9]]</code></pre><h3 id="原地删除重复元素（元素可比较）"><a href="#原地删除重复元素（元素可比较）" class="headerlink" title="原地删除重复元素（元素可比较）"></a>原地删除重复元素（元素可比较）</h3><pre class=" language-lang-go"><code class="language-lang-go">import "sort"in := []int{3,2,1,4,3,2,1,4,1} // 切片元素可以是任意可排序的类型sort.Ints(in)j := 0for i := 1; i < len(in); i++ {    if in[j] == in[i] {        continue    }    j++    // 需要保存原始数据时    // in[i], in[j] = in[j], in[i]    // 只需要保存需要的数据时    in[j] = in[i]}result := in[:j+1]fmt.Println(result) // [1 2 3 4]</code></pre><h3 id="存在就移到前面，不存在就插入到前面"><a href="#存在就移到前面，不存在就插入到前面" class="headerlink" title="存在就移到前面，不存在就插入到前面"></a>存在就移到前面，不存在就插入到前面</h3><p>如果给定的元素在切片中存在则把该元素移到切片的头部，如果不存在则将该元素插入到切片的头部。</p><pre class=" language-lang-go"><code class="language-lang-go">// moveToFront 把needle移动或添加到haystack的前面func moveToFront(needle string, haystack []string) []string {    if len(haystack) != 0 && haystack[0] == needle {        return haystack    }    prev := needle    for i, elem := range haystack {        switch {        case i == 0:            haystack[0] = needle            prev = elem        case elem == needle:            haystack[i] = prev            return haystack        default:            haystack[i] = prev            prev = elem        }    }    return append(haystack, prev)}haystack := []string{"a", "b", "c", "d", "e"} // [a b c d e]haystack = moveToFront("c", haystack)         // [c a b d e]haystack = moveToFront("f", haystack)         // [f c a b d e]</code></pre><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>将切片input生成size大小的滑动窗口。</p><pre class=" language-lang-go"><code class="language-lang-go">func slidingWindow(size int, input []int) [][]int {    // 返回入参的切片作为第一个元素    if len(input) <= size {        return [][]int{input}    }    // 以所需的精确大小分配切片    r := make([][]int, 0, len(input)-size+1)    for i, j := 0, size; j <= len(input); i, j = i+1, j+1 {        r = append(r, input[i:j])    }    return r}</code></pre><p>示例：</p><pre class=" language-lang-go"><code class="language-lang-go">a := []int{1, 2, 3, 4, 5}res := slidingWindow(2, a)fmt.Println(res)</code></pre><p>输出：</p><pre class=" language-lang-bash"><code class="language-lang-bash">[[1 2] [2 3] [3 4] [4 5]]</code></pre><p>参考资料： <a href="https://github.com/golang/go/wiki/SliceTricks">https://github.com/golang/go/wiki/SliceTricks</a></p>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2021/120232767.html"/>
      <url>/2021/120232767.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是同一种类型的数据集合</p><p>在Go语言中数组声明时确定长度和存放元素的类型</p><p>且数组是值类型的传递</p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><pre class=" language-lang-go"><code class="language-lang-go">var 数组变量名 [元素数量]T</code></pre><p>比如：<code>var a [5]int</code> 创建了一个名为a的长度为5的[5]int类型数组</p><p>数组的长度必须是常量，并且不能改变</p><p>数组可以通过下标访问，下标从<code>0</code>开始，最后一个元素是<code>len - 1</code></p><p>数组访问越界会panic</p><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><ol><li>使用初始化列表设置数组元素的值</li></ol><pre class=" language-lang-go"><code class="language-lang-go">var array = [3]int{1, 2}    //[1 2 0]</code></pre><ol><li>可以让编译器自行判定数组长度</li></ol><pre class=" language-lang-go"><code class="language-lang-go">var array = [...]int{1, 2}    //[1 2]</code></pre><ol><li>可以根据索引初始化数组</li></ol><pre class=" language-lang-go"><code class="language-lang-go">var array = [...]int[1:1, 3:5]    //[0 1 0 5]</code></pre><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><ol><li><p>for循环遍历</p><pre class=" language-lang-go"><code class="language-lang-go">var a = [...]string{"Hi", "Nihao"}for i := 0; i < len(a); i++{    fmt.println(a[i])    }</code></pre></li><li><p>for range遍历</p><pre class=" language-lang-go"><code class="language-lang-go">var a = [...]string{"Hi", "Nihao"}for index, value := range a{    fmt.println(index, value)}</code></pre></li></ol><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>Go语言支持多维数组</p><pre class=" language-lang-go"><code class="language-lang-go">a := [3][2]int{    {1, 2},    {3, 4},    {5, 6},}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2021/120240853.html"/>
      <url>/2021/120240853.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go语言的指针相较于C语言中的指针，它不能偏移和运算。</p><p>指针的三个性质</p><ul><li>指针地址</li><li>指针类型</li><li>指针取值</li></ul><p>指针的两个操作符</p><ul><li>&amp;：取地址符</li><li>*：取值符</li></ul><h3 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h3><p>变量在运行时有一个地址，代表变量在内存的位置</p><p>所有值类型都有对应的指针类型，如<code>*int</code></p><h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><p>new的函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func new(Type) *Type</code></pre><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针</li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">func main(){    a := new(int)    //声明并申请一个int的空间    *a = 10            //赋值    fmt.Println(*a)    //打印}</code></pre><h5 id="make"><a href="#make" class="headerlink" title="make"></a>make</h5><p>make也是内存分配的函数，区别于new，它只用于<code>slice</code>，<code>map</code>，<code>chan</code>的内存创建，且返回的类型是它们本身而不是指针类型。</p><p>make的函数签名：</p><pre class=" language-lang-go"><code class="language-lang-go">func make(t Type, size ...IntegerType) Type</code></pre><p>我们在使用<code>slice</code>、<code>map</code>、<code>channel</code>时，都需要使用make进行初始化</p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">scoreMap := make(map[string]int, 8)scoreMap["武子"] = 90scoreMap["康康"] = 100fmt.println(scoreMap)            //输出：map[康康:100 武子:90]fmt.println(scoreMap["武子"])       //输出：100</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map</title>
      <link href="/2021/120243450.html"/>
      <url>/2021/120243450.html</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的，基于<code>key_value</code>的数据结构</p><p>go语言中map是引用类型，必须初始化</p><h3 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h3><p><code>map</code>的定义语法：</p><pre class=" language-lang-go"><code class="language-lang-go">map[keyType]valueType</code></pre><p>其中，</p><ul><li><code>keyType</code>：键的类型</li><li><code>valueType</code>：值的类型</li></ul><p>map类型的变量初始值为<code>nil</code></p><p>需要使用<code>make()</code>函数分配内存</p><pre class=" language-lang-go"><code class="language-lang-go">make(map[keyType]valueType, [cap])</code></pre><p>其中，</p><ul><li><code>cap</code>：map的容量</li></ul><h3 id="map的使用"><a href="#map的使用" class="headerlink" title="map的使用"></a>map的使用</h3><p>map中数据是成对存在的，使用示例如下：</p><pre class=" language-lang-go"><code class="language-lang-go">scoreMap := make(map[string]int, 8)scoreMap["武子"] = 90scoreMap["康康"] = 100fmt.println(scoreMap)            //输出：map[康康:100 武子:90]fmt.println(scoreMap["武子"])       //输出：100</code></pre><p>map也可以在声明时初始化元素</p><pre class=" language-lang-go"><code class="language-lang-go">nMap := map[string]string{    "武子" : "90",    "康康" : "100",}</code></pre><h3 id="判断Map中某个键是否存在"><a href="#判断Map中某个键是否存在" class="headerlink" title="判断Map中某个键是否存在"></a>判断Map中某个键是否存在</h3><p>Go语言中判断map中键是否存在</p><pre class=" language-lang-go"><code class="language-lang-go">value,ok := map[key]</code></pre><p>举例</p><pre class=" language-lang-go"><code class="language-lang-go">//数分考试scoreMap := make(map[string] int)scoreMap["武子"] = 90scoreMap["康康"] = 100// 如果key存在     ok为true    v为对应的值；// 如果key不存在     ok为false   v为值类型的零值v, ok := scoreMap["武子"]if ok {    fmt.Println(v)} else {    fmt.Println("这人旷考？")}</code></pre><h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><p>使用<code>for range</code>遍历map</p><pre class=" language-lang-go"><code class="language-lang-go">scoreMap := make(map[string]int, 8)scoreMap["武子"] = 90scoreMap["康康"] = 100//遍历key和valuefor key, value := range scoreMap{    fmt.Println(key, value)}//遍历keyfor key := range scoreMap{    fmt.Println(key, value)}</code></pre><h3 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h3><p><code>delete</code>函数的格式：</p><pre class=" language-lang-go"><code class="language-lang-go">delete(map, key)</code></pre><p>其中，</p><ul><li><p><code>map</code>：要删除键值对的map</p></li><li><p><code>key</code>：要删除键值对的键</p></li></ul><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">scoreMap := make(map[string]int, 8)scoreMap["武子"] = 90scoreMap["康康"] = 100delete(scoreMap, "武子")    //delete 武子 对应的键值对fmt.println(scoreMap)    //输出：map[康康:100]</code></pre><h3 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h3><pre class=" language-lang-go"><code class="language-lang-go">rand.Seed(time.Now().UnixNano()) //初始化随机数种子var scoreMap = make(map[string]int, 200)for i := 0; i < 100; i++ {    key := fmt.Sprintf("stu%02d", i) //生成stu开头的字符串    value := rand.Intn(100)          //生成0~99的随机整数    scoreMap[key] = value}//取出map中的所有key存入切片keysvar keys = make([]string, 0, 200)for key := range scoreMap {    keys = append(keys, key)}//对切片进行排序sort.Strings(keys)//按照排序后的key遍历mapfor _, key := range keys {    fmt.Println(key, scoreMap[key])}</code></pre><h3 id="元素为map的切片"><a href="#元素为map的切片" class="headerlink" title="元素为map的切片"></a>元素为map的切片</h3><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var mapSlice = make([]map[string]string, 3)    // 对切片中的map元素进行初始化    mapSlice[0] = make(map[string]string, 10)    mapSlice[0]["name"] = "小王子"    mapSlice[0]["password"] = "123456"    mapSlice[0]["address"] = "沙河"    fmt.Println(mapSlice)}</code></pre><h3 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h3><p>下面的代码演示了map中值为切片类型的操作：</p><pre class=" language-lang-go"><code class="language-lang-go">func main() {    var sliceMap = make(map[string][]string, 3)    key := "中国"    //判定key是否在map中    value, ok := sliceMap[key]    if !ok {        value = make([]string, 0, 2)    }    value = append(value, "北京", "上海")    sliceMap[key] = value    fmt.Println(sliceMap)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作</title>
      <link href="/2021/120228165.html"/>
      <url>/2021/120228165.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>go语言中字符串的实现使用<code>UTF-8</code>编码</p><p>字符串的值为<code>双引号（""）</code>中的内容</p><h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>go语言中定义一个多行字符串时，必须使用<code>反引号</code>字符</p><pre class=" language-lang-go"><code class="language-lang-go">s1 := `第一行第二行第三行`</code></pre><p>反引号间换行被视作字符串中的换行</p><p>但是所有的转义字符无效，字符会原样输出</p><h1 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h1><div class="table-container"><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr></tbody></table></div><p>反斜杠也可以打印出<code>'</code> <code>"</code> <code>\</code> 等特殊字符</p><h1 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h1><div class="table-container"><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix, strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>strings.Index(), strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table></div><h1 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h1><p>字符串本身是无法被修改的，需要先将其转换成<code>[]rune</code>或<code>[]byte</code></p><p>完成后再转换为<code>string</code></p><p>举例：</p><pre class=" language-lang-go"><code class="language-lang-go">s1 := "big"byteS1 := []byte(s1)byteS1[0] = 'P'str := string(byteS1)    //str = "Pig"S2 := "你好"runeS2 := []rune(s2)runeS2[0] = "晚"str = string(runeS2)    //str = "晚好"</code></pre>]]></content>
      
      
      <categories>
          
          <category> Go语言 </category>
          
          <category> 数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/120216107.html"/>
      <url>/2021/120216107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
